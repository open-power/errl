/*
 * Automatically generated by Hostboot's ./genErrlParsers.pl
 * Do not modify this file in the FSP tree, it is provided by
 * Hostboot and will be overwritten
 *
 * TimeStamp:   Tue May 15 13:26:15 2018
 * Image Id:    hb0515b_1820.920
 *
 */

#include <errlplugins.H>
#include <errlusrparser.H>
#include <srcisrc.H>

static bool SrcDataParse(ErrlUsrParser & i_parser,
                         const SrciSrc & i_src)
{
    uint32_t l_error = (i_src.reasonCode() << 8) + i_src.moduleId();
    bool l_success = true;

    switch(l_error)
    {
    case 0x91011:
        i_parser.PrintString("devdesc", "Attempt to read an CVPD field using an invalid record");
        i_parser.PrintString("moduleid", "MOD_FAPI2_CVPD_ACCESS");
        i_parser.PrintString("reasoncode", "RC_RECORD_OUT_OF_BOUNDS");
        i_parser.PrintString("userdata1", "Record enumerator");
        i_parser.PrintString("userdata2[0:31]", "Index");
        i_parser.PrintString("userdata2[32:63]", "Max Index");
        break;

    case 0x91111:
        i_parser.PrintString("devdesc", "Attempt to read an CVPD field using an invalid keyword");
        i_parser.PrintString("moduleid", "MOD_FAPI2_CVPD_ACCESS");
        i_parser.PrintString("reasoncode", "RC_KEYWORD_OUT_OF_BOUNDS");
        i_parser.PrintString("userdata1", "Keyword enumerator");
        i_parser.PrintString("userdata2[0:31]", "Index");
        i_parser.PrintString("userdata2[32:63]", "Max Index");
        break;

    case 0x90A02:
        i_parser.PrintString("devdesc", "Unable to resolve FapiTarget from input");
        i_parser.PrintString("moduleid", "fapi2::MOD_FAPI2_GET_TARGETING_TARGET");
        i_parser.PrintString("reasoncode", "RC_NULL_FAPI_TARGET");
        i_parser.PrintString("userdata1[0:31]", "Fapi2 Expected Type");
        i_parser.PrintString("userdata1[32:63]", "<unused>");
        i_parser.PrintString("userdata2[0:7]", "Is Chip");
        i_parser.PrintString("userdata2[8:15]", "Is Chiplet");
        i_parser.PrintString("userdata2[16:63]", "<unused>");
        break;

    case 0x90802:
        i_parser.PrintString("devdesc", "When coverting from FAPI2::target to Targeting::target the resulting                                     Targeting::target's was incorrect");
        i_parser.PrintString("moduleid", "fapi2::MOD_FAPI2_GET_TARGETING_TARGET");
        i_parser.PrintString("reasoncode", "RC_MISMATCHED_FAPI_TARG_TARGET");
        i_parser.PrintString("userdata1[0:31]", "Actual Type");
        i_parser.PrintString("userdata1[32:63]", "Expected Type");
        i_parser.PrintString("userdata2[0:31]", "Initial FAPI2 Type");
        i_parser.PrintString("userdata2[32:47]", "Is Chip");
        i_parser.PrintString("userdata2[48:63]", "Is Chiplet");
        break;

    case 0x90902:
        i_parser.PrintString("devdesc", "HB target found with unknown model attribute");
        i_parser.PrintString("moduleid", "fapi2::MOD_FAPI2_GET_TARGETING_TARGET");
        i_parser.PrintString("reasoncode", "RC_UNKNOWN_MODEL");
        i_parser.PrintString("userdata1[0:31]", "FAPI2 Type");
        i_parser.PrintString("userdata1[32:63]", "HB Target HUID");
        i_parser.PrintString("userdata2[0:31]", "HB Type");
        i_parser.PrintString("userdata2[32:63]", "HB Model");
        break;

    case 0x93012:
        i_parser.PrintString("devdesc", "Extra bad bits set for DIMM");
        i_parser.PrintString("moduleid", "MOD_FAPI2_BAD_DQ_BITMAP");
        i_parser.PrintString("reasoncode", "RC_BAD_DQ_MFG_MODE_BITS");
        i_parser.PrintString("userdata1", "DIMM Target HUID");
        i_parser.PrintString("userdata2", "<unused>");
        break;

    case 0x9100A:
        i_parser.PrintString("devdesc", "Attempt to read an MVPD field using an invalid record");
        i_parser.PrintString("moduleid", "MOD_FAPI2_MVPD_ACCESS");
        i_parser.PrintString("reasoncode", "RC_RECORD_OUT_OF_BOUNDS");
        i_parser.PrintString("userdata1", "Record enumerator");
        i_parser.PrintString("userdata2[0:31]", "Index");
        i_parser.PrintString("userdata2[32:63]", "Max Index");
        break;

    case 0x90D0A:
        i_parser.PrintString("devdesc", "Attempt to read an MVPD field using an invalid record");
        i_parser.PrintString("moduleid", "MOD_FAPI2_MVPD_ACCESS");
        i_parser.PrintString("reasoncode", "RC_INVALID_RECORD");
        i_parser.PrintString("userdata1", "Record enumerator");
        break;

    case 0x9110A:
        i_parser.PrintString("devdesc", "Attempt to read an MVPD field using an invalid keyword");
        i_parser.PrintString("moduleid", "MOD_FAPI2_MVPD_ACCESS");
        i_parser.PrintString("reasoncode", "RC_KEYWORD_OUT_OF_BOUNDS");
        i_parser.PrintString("userdata1", "Keyword enumerator");
        i_parser.PrintString("userdata2[0:31]", "Index");
        i_parser.PrintString("userdata2[32:63]", "Max Index");
        break;

    case 0x90E0A:
        i_parser.PrintString("devdesc", "Attempt to read an MVPD field using an invalid keyword");
        i_parser.PrintString("moduleid", "MOD_FAPI2_MVPD_ACCESS");
        i_parser.PrintString("reasoncode", "RC_INVALID_KEYWORD");
        i_parser.PrintString("userdata1", "Keyword enumerator");
        break;

    case 0x90707:
        i_parser.PrintString("devdesc", "verifyCfamAccessTarget> Attempt to access CFAM on the master processor");
        i_parser.PrintString("moduleid", "fapi2::MOD_FAPI2_VERIFYCFAMACCESSTARGET");
        i_parser.PrintString("reasoncode", "fapi2::RC_INVALID_TARG_TARGET");
        i_parser.PrintString("userdata1", "CFAM Address");
        i_parser.PrintString("userdata2", "HUID of input target");
        break;

    case 0x90f01:
        i_parser.PrintString("devdesc", "HW Procedure generated error. See User Data.");
        i_parser.PrintString("moduleid", "MOD_FAPI2_RC_TO_ERRL");
        i_parser.PrintString("reasoncode", "RC_HWP_GENERATED_ERROR");
        i_parser.PrintString("userdata1", "RC value from HWP");
        i_parser.PrintString("userdata2", "<unused>");
        break;

    case 0x93120:
        i_parser.PrintString("devdesc", "PROC or OCC expected");
        i_parser.PrintString("moduleid", "fapi::MOD_GET_OCC_CHIP_TARGET");
        i_parser.PrintString("reasoncode", "fapi::RC_TARGET_UNSUPPORTED");
        i_parser.PrintString("userdata1", "Target Type");
        i_parser.PrintString("userdata2", "Target HUID");
        break;

    case 0x93221:
        i_parser.PrintString("devdesc", "Improper data size, data is not 8 byte aligned.");
        i_parser.PrintString("moduleid", "fapi::MOD_ACCESS_OCB_INDIRECT_CHANNEL");
        i_parser.PrintString("reasoncode", "fapi::RC_INVALID_DATA_BUFFER_LENGTH");
        i_parser.PrintString("userdata1", "Length of requested buffer size(in Bytes) to perform read operation.");
        i_parser.PrintString("userdata2", "OCI address");
        break;

    case 0x92817:
        i_parser.PrintString("devdesc", "HB got an incorrect type message.  HB did not provide the correct message type in the istep. Userdata1 shows the message type passed in");
        i_parser.PrintString("moduleid", "fapi::MOD_VDDR_SEND_MSG");
        i_parser.PrintString("reasoncode", "fapi::RC_INCORRECT_MSG_TYPE");
        i_parser.PrintString("userdata1", "i_msgType");
        i_parser.PrintString("userdata2", "0");
        break;

    case 0x92516:
        i_parser.PrintString("devdesc", "The hwsv returned a message where the extra data was null.  This should not happen so need to tell HostBoot to stop the ipl");
        i_parser.PrintString("moduleid", "fapi::MOD_VDDR_PROC_VDDR_MSG");
        i_parser.PrintString("reasoncode", "fapi::RC_VDDR_EMPTY_MSG");
        i_parser.PrintString("userdata1", "0");
        i_parser.PrintString("userdata2", "0");
        break;

    case 0x92716:
        i_parser.PrintString("devdesc", "The hwsv returned a message where there was an error when the powr function was called. userdata1 contains the errorlog plid from hwsv generated by the powr function");
        i_parser.PrintString("moduleid", "fapi::MOD_VDDR_PROC_VDDR_MSG");
        i_parser.PrintString("reasoncode", "fapi::RC_VDDR_POWR_ERR");
        i_parser.PrintString("userdata1", "l_errPlid");
        i_parser.PrintString("userdata2", "0");
        break;

    case 0x92815:
        i_parser.PrintString("devdesc", "HB got an incorrect type message. HWSV did not populate the message correctly or mbox corrupted the message");
        i_parser.PrintString("moduleid", "fapi::MOD_VDDR_PROC_MSG");
        i_parser.PrintString("reasoncode", "fapi::RC_INCORRECT_MSG_TYPE");
        i_parser.PrintString("userdata1", "0");
        i_parser.PrintString("userdata2", "0");
        break;

    case 0x92615:
        i_parser.PrintString("devdesc", "The hwsv found an error while processing the message so it sent an error message back to indicate to HostBoot to stop the IPL. Userdata1 will have the error PLID from hwsv's errorlog");
        i_parser.PrintString("moduleid", "fapi::MOD_VDDR_PROC_MSG");
        i_parser.PrintString("reasoncode", "fapi::RC_VDDR_ERROR_MSG");
        i_parser.PrintString("userdata1", "error PLID from hwsv");
        i_parser.PrintString("userdata2", "0");
        break;

    case 0x92A1C:
        i_parser.PrintString("devdesc", "messages from other nodes have not returned in time");
        i_parser.PrintString("moduleid", "fapi::MOD_HOST_COALESCE_HOST,");
        i_parser.PrintString("reasoncode", "fapi::RC_HOST_TIMER_EXPIRED,");
        i_parser.PrintString("userdata1", "MAX_TIME_ALLOWED_MS");
        i_parser.PrintString("userdata2", "Number of nodes that have not responded");
        break;

    case 0x92B1C:
        i_parser.PrintString("devdesc", "host coalesce host timer thread failed");
        i_parser.PrintString("moduleid", "fapi::MOD_HOST_COALESCE_HOST,");
        i_parser.PrintString("reasoncode", "fapi::RC_HOST_TIMER_THREAD_FAIL,,");
        i_parser.PrintString("userdata1", "l_tidretrc,");
        i_parser.PrintString("userdata2", "l_childsts,");
        break;

    case 0x93E2D:
        i_parser.PrintString("devdesc", "xz-embedded has returned an error. the return code can be found in xz.h");
        i_parser.PrintString("moduleid", "fapi::MOD_START_XZ_PAYLOAD");
        i_parser.PrintString("reasoncode", "fapi::RC_INVALID_RETURN_XZ_CODE");
        i_parser.PrintString("userdata1", "Return code from xz-embedded");
        i_parser.PrintString("userdata2[0:31]", "Original Payload Size");
        i_parser.PrintString("userdata2[32:63]", "Uncompressed Payload Size");
        break;

    case 0x9242D:
        i_parser.PrintString("devdesc", "mm_block_unmap returned incorrectly with 0");
        i_parser.PrintString("moduleid", "fapi::MOD_START_XZ_PAYLOAD");
        i_parser.PrintString("reasoncode", "fapi::RC_MM_UNMAP_ERR");
        break;

    case 0x90101:
        i_parser.PrintString("devdesc", "InitFile HW Procedure requested an invalid attribute");
        i_parser.PrintString("moduleid", "MOD_FAPI_RC_TO_ERRL");
        i_parser.PrintString("reasoncode", "RC_INVALID_ATTR_GET");
        break;

    case 0x90201:
        i_parser.PrintString("devdesc", "Request for EC features on an attribute without EC features");
        i_parser.PrintString("moduleid", "MOD_FAPI_RC_TO_ERRL");
        i_parser.PrintString("reasoncode", "RC_INVALID_CHIP_EC_FEATURE_GET");
        break;

    default:
        l_success = false;
        break;
    };
    return l_success;
}

static errl::SrcPlugin g_SrcPlugin(0x900, SrcDataParse, ERRL_CID_HOSTBOOT);
