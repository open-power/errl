/*
 * Automatically generated by Hostboot's ./genErrlParsers.pl
 * Do not modify this file in the FSP tree, it is provided by
 * Hostboot and will be overwritten
 *
 * TimeStamp:   Tue May 15 13:26:15 2018
 * Image Id:    hb0515b_1820.920
 *
 */

#include <errlplugins.H>
#include <errlusrparser.H>
#include <srcisrc.H>

static bool SrcDataParse(ErrlUsrParser & i_parser,
                         const SrciSrc & i_src)
{
    uint32_t l_error = (i_src.reasonCode() << 8) + i_src.moduleId();
    bool l_success = true;

    switch(l_error)
    {
    case 0x40503:
        i_parser.PrintString("devdesc", "mmio_dev_unmap() returns error");
        i_parser.PrintString("moduleid", "XSCOM_GET_TARGET_VIRT_ADDR");
        i_parser.PrintString("reasoncode", "XSCOM_MMIO_UNMAP_ERR");
        i_parser.PrintString("userdata1", "Return Code");
        i_parser.PrintString("userdata2", "Unmap address");
        break;

    case 0x40107:
        i_parser.PrintString("devdesc", "XSCom access error");
        i_parser.PrintString("moduleid", "XSCOM_DO_OP");
        i_parser.PrintString("reasoncode", "XSCOM_STATUS_ERR");
        i_parser.PrintString("userdata1", "HMER value (piberr in bits 21:23)");
        i_parser.PrintString("userdata2", "XSCom address");
        break;

    case 0x40402:
        i_parser.PrintString("devdesc", "Read back value doesn't match write");
        i_parser.PrintString("moduleid", "XSCOM::XSCOM_TEST_XSCOM1");
        i_parser.PrintString("reasoncode", "XSCOM::XSCOM_DATA_UNMATCHED");
        i_parser.PrintString("userdata1", "Write value");
        i_parser.PrintString("userdata2", "Read back value");
        break;

    case 0x40404:
        i_parser.PrintString("devdesc", "Read back value doesn't match write");
        i_parser.PrintString("moduleid", "XSCOM::XSCOM_TEST_XSCOM2");
        i_parser.PrintString("reasoncode", "XSCOM::XSCOM_DATA_UNMATCHED");
        i_parser.PrintString("userdata1", "Write value");
        i_parser.PrintString("userdata2", "Read back value");
        break;

    default:
        l_success = false;
        break;
    };
    return l_success;
}

static errl::SrcPlugin g_SrcPlugin(0x400, SrcDataParse, ERRL_CID_HOSTBOOT);
