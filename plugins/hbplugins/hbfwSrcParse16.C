/*
 * Automatically generated by Hostboot's ./genErrlParsers.pl
 * Do not modify this file in the FSP tree, it is provided by
 * Hostboot and will be overwritten
 *
 * TimeStamp:   Tue May 15 13:26:15 2018
 * Image Id:    hb0515b_1820.920
 *
 */

#include <errlplugins.H>
#include <errlusrparser.H>
#include <srcisrc.H>

static bool SrcDataParse(ErrlUsrParser & i_parser,
                         const SrciSrc & i_src)
{
    uint32_t l_error = (i_src.reasonCode() << 8) + i_src.moduleId();
    bool l_success = true;

    switch(l_error)
    {
    case 0x161C15:
        i_parser.PrintString("devdesc", "Lid not in PNOR or VFS for non-FSP systems");
        i_parser.PrintString("moduleid", "Util::UTIL_LIDMGR_CSTOR");
        i_parser.PrintString("reasoncode", "Util::UTIL_LIDMGR_INVAL_LID_REQUEST");
        i_parser.PrintString("userdata1", "LID ID");
        i_parser.PrintString("userdata2", "0");
        break;

    case 0x160404:
        i_parser.PrintString("devdesc", "The LID transfer code on the FSP side was unable to fulfill the LID GET_INFO request.");
        i_parser.PrintString("moduleid", "Util::UTIL_LIDMGR_GETLIDSIZE");
        i_parser.PrintString("reasoncode", "Util::UTIL_LIDMGR_RC_FAIL");
        i_parser.PrintString("userdata1", "return code from FSP");
        i_parser.PrintString("userdata2", "LID ID");
        break;

    case 0x160805:
        i_parser.PrintString("devdesc", "Insufficient space provided for LID by calling function.");
        i_parser.PrintString("moduleid", "Util::UTIL_LIDMGR_GETLIDPNOR");
        i_parser.PrintString("reasoncode", "Util::UTIL_LIDMGR_INVAL_SIZE_PNOR");
        i_parser.PrintString("userdata1[0:31]", "LID size found in pnor");
        i_parser.PrintString("userdata1[32:63]", "Reserved space provided");
        i_parser.PrintString("userdata2", "LID ID");
        break;

    case 0x160605:
        i_parser.PrintString("devdesc", "Insufficient space provided for LID by calling function.");
        i_parser.PrintString("moduleid", "Util::UTIL_LIDMGR_GETLIDPNOR");
        i_parser.PrintString("reasoncode", "Util::UTIL_LIDMGR_INVAL_SIZE");
        i_parser.PrintString("userdata1[0:31]", "LID size found in Ext Img");
        i_parser.PrintString("userdata1[32:63]", "Reserved space provided");
        i_parser.PrintString("userdata2", "LID ID");
        break;

    case 0x160403:
        i_parser.PrintString("devdesc", "The LID transfer code on the FSP side was unable to fulfill the LID SEND_TO_HB request.");
        i_parser.PrintString("moduleid", "Util::UTIL_LIDMGR_GETLID");
        i_parser.PrintString("reasoncode", "Util::UTIL_LIDMGR_RC_FAIL");
        i_parser.PrintString("userdata1", "return code from FSP");
        i_parser.PrintString("userdata2", "LID ID");
        break;

    case 0x160503:
        i_parser.PrintString("devdesc", "DMA message contains data for wrong LID.");
        i_parser.PrintString("moduleid", "Util::UTIL_LIDMGR_GETLID");
        i_parser.PrintString("reasoncode", "Util::UTIL_LIDMGR_INVAL_DATA");
        i_parser.PrintString("userdata1[0:31]", "received LID ID");
        i_parser.PrintString("userdata1[32:63]", "expected LID ID");
        i_parser.PrintString("userdata2[0:31]", "pointer to extra data");
        break;

    case 0x160603:
        i_parser.PrintString("devdesc", "Insufficient space provided for LID by calling function.");
        i_parser.PrintString("moduleid", "Util::UTIL_LIDMGR_GETLID");
        i_parser.PrintString("reasoncode", "Util::UTIL_LIDMGR_INVAL_SIZE");
        i_parser.PrintString("userdata1[0:31]", "Allocated Size");
        i_parser.PrintString("userdata1[32:63]", "Size needed for current data page");
        i_parser.PrintString("userdata2[32:63]", "Lid ID");
        break;

    case 0x160703:
        i_parser.PrintString("devdesc", "Invalid Message type received from FSP when transferring LID pages.");
        i_parser.PrintString("moduleid", "Util::UTIL_LIDMGR_GETLID");
        i_parser.PrintString("reasoncode", "Util::UTIL_LIDMGR_UNSUP_MSG");
        i_parser.PrintString("userdata1", "LID ID");
        i_parser.PrintString("userdata2", "Message Type");
        break;

    case 0x160B07:
        i_parser.PrintString("devdesc", "Error returned from mm_remove_pages when evicting lid from memory.");
        i_parser.PrintString("moduleid", "Util::UTIL_LIDMGR_CLEANUP");
        i_parser.PrintString("reasoncode", "Util::UTIL_LIDMGR_MM_FAIL");
        i_parser.PrintString("userdata1[00:31]", "LID ID");
        i_parser.PrintString("userdata1[32:63]", "rc from mm_remove_pages");
        i_parser.PrintString("userdata2", "Virtual address being removed");
        break;

    case 0x160C0C:
        i_parser.PrintString("devdesc", "TCE Table size requested too large.");
        i_parser.PrintString("moduleid", "Util::UTIL_TCE_CREATE_TABLE");
        i_parser.PrintString("reasoncode", "Util::UTIL_TCE_INVALID_SIZE");
        i_parser.PrintString("userdata1", "Size of of the table that is too large");
        i_parser.PrintString("userdata2", "Max TCE Table Size");
        break;

    case 0x16130C:
        i_parser.PrintString("devdesc", "TCE Table size requested too large.");
        i_parser.PrintString("moduleid", "Util::UTIL_TCE_CREATE_TABLE");
        i_parser.PrintString("reasoncode", "Util::UTIL_TCE_INVALID_COUNT");
        i_parser.PrintString("userdata1", "Number of TCEs Requested");
        i_parser.PrintString("userdata2", "Max Number of TCEs that TCE Table can hold");
        break;

    case 0x160D0C:
        i_parser.PrintString("devdesc", "TCE Table not page aligned.");
        i_parser.PrintString("moduleid", "Util::UTIL_TCE_CREATE_TABLE");
        i_parser.PrintString("reasoncode", "Util::UTIL_TCE_ADDR_NOT_ALIGNED");
        i_parser.PrintString("userdata1", "Phyiscal Address of the TCE Table");
        i_parser.PrintString("userdata2", "<unused>");
        break;

    case 0x16020C:
        i_parser.PrintString("devdesc", "TCE Table Could Not Be Block-Mapped");
        i_parser.PrintString("moduleid", "Util::UTIL_TCE_CREATE_TABLE");
        i_parser.PrintString("reasoncode", "Util::UTIL_ERC_BAD_PTR");
        i_parser.PrintString("userdata1", "Physical Address of the TCE Table");
        i_parser.PrintString("userdata2", "Requested Size of the TCE Table");
        break;

    case 0x160D0A:
        i_parser.PrintString("devdesc", "The Physical Address for the TCE entry is not page aligned.");
        i_parser.PrintString("moduleid", "Util::UTIL_TCE_ALLOCATE");
        i_parser.PrintString("reasoncode", "Util::UTIL_TCE_ADDR_NOT_ALIGNED");
        i_parser.PrintString("userdata1", "Address to start TCE");
        i_parser.PrintString("userdata2", "Size of the address space trying to get TCEs for.");
        break;

    case 0x160C0A:
        i_parser.PrintString("devdesc", "The size requested is too large for the TCE table");
        i_parser.PrintString("moduleid", "Util::UTIL_TCE_ALLOCATE");
        i_parser.PrintString("reasoncode", "Util::UTIL_TCE_INVALID_SIZE");
        i_parser.PrintString("userdata1[0:31]", "Number of TCEs Needed");
        i_parser.PrintString("userdata2", "Size of the address space trying to get TCEs");
        break;

    case 0x16120A:
        i_parser.PrintString("devdesc", "The starting address was previously allocated");
        i_parser.PrintString("moduleid", "Util::UTIL_TCE_ALLOCATE");
        i_parser.PrintString("reasoncode", "Util::UTIL_TCE_PREVIOUSLY_ALLOCATED");
        i_parser.PrintString("userdata1", "Starting Address");
        i_parser.PrintString("userdata2", "Starting TCE position in TCE Table");
        break;

    case 0x16100A:
        i_parser.PrintString("devdesc", "Requested size is too large to fit into TCE Table");
        i_parser.PrintString("moduleid", "Util::UTIL_TCE_ALLOCATE");
        i_parser.PrintString("reasoncode", "Util::UTIL_TCE_NOT_ENOUGH_FREE_ENTRIES");
        i_parser.PrintString("userdata1[0:31]", "Number of TCEs Needed");
        i_parser.PrintString("userdata2", "Size of address space TCEs are tying to map to");
        break;

    case 0x160C0B:
        i_parser.PrintString("devdesc", "The size requested is too large based on the startingAddress the space avilable in the table");
        i_parser.PrintString("moduleid", "Util::UTIL_TCE_DEALLOCATE");
        i_parser.PrintString("reasoncode", "Util::UTIL_TCE_INVALID_SIZE");
        i_parser.PrintString("userdata1[0:31]", "starting index");
        i_parser.PrintString("userdata1[32:63]", "number of TCEs needed for this request");
        i_parser.PrintString("userdata2", "Number of Entries Current TCE Table Supports");
        break;

    case 0x16110B:
        i_parser.PrintString("devdesc", "The deallocate went across TCE Allocate space.");
        i_parser.PrintString("moduleid", "Util::UTIL_TCE_DEALLOCATE");
        i_parser.PrintString("reasoncode", "Util::UTIL_TCE_ENTRY_NOT_CONTIGUOUS");
        i_parser.PrintString("userdata1", "Starting address of the TCEs to be deallocated");
        i_parser.PrintString("userdata2", "Size of the address space to be deallocated");
        break;

    case 0x16150D:
        i_parser.PrintString("devdesc", "mm_block_unmap failed for TCE Table");
        i_parser.PrintString("moduleid", "Util::UTIL_TCE_DISABLE_TCES");
        i_parser.PrintString("reasoncode", "Util::UTIL_TCE_BLOCK_UNMAP_FAIL");
        i_parser.PrintString("userdata1", "Starting virtual address of pages to be removed");
        i_parser.PrintString("userdata2", "Return Code from mm_block_unmap");
        break;

    case 0x160E0E:
        i_parser.PrintString("devdesc", "PSI Bridge device Map failed");
        i_parser.PrintString("moduleid", "Util::UTIL_TCE_MAP_PSIHB");
        i_parser.PrintString("reasoncode", "Util::UTIL_TCE_DEV_MAP_FAIL");
        i_parser.PrintString("userdata1", "Address to be mapped PsiBridgeAddr");
        i_parser.PrintString("userdata2", "Target Unit Id");
        break;

    case 0x160F0F:
        i_parser.PrintString("devdesc", "PSI Bridge device Map failed");
        i_parser.PrintString("moduleid", "Util::UTIL_TCE_UNMAP_PSIHB");
        i_parser.PrintString("reasoncode", "Util::UTIL_TCE_DEV_UNMAP_FAIL");
        i_parser.PrintString("userdata1", "Address to be unmapped");
        i_parser.PrintString("userdata2", "Return Code of mmio_dev_unmap");
        break;

    case 0x160201:
        i_parser.PrintString("devdesc", "Bad memory pointer received.");
        i_parser.PrintString("moduleid", "Util::UTIL_MOD_MEM_READ");
        i_parser.PrintString("reasoncode", "Util::UTIL_ERC_BAD_PTR");
        i_parser.PrintString("userdata1[0:31]", "Task ID.");
        i_parser.PrintString("userdata1[31:64]", "End of File (boolean)");
        i_parser.PrintString("userdata2", "Address of memory buffer.");
        break;

    case 0x160301:
        i_parser.PrintString("devdesc", "End of file reached.");
        i_parser.PrintString("moduleid", "Util::UTIL_MOD_MEM_READ");
        i_parser.PrintString("reasoncode", "Util::UTIL_ERC_EOF");
        i_parser.PrintString("userdata1[0:31]", "Task ID.");
        i_parser.PrintString("userdata1[31:64]", "End of File (boolean)");
        i_parser.PrintString("userdata2", "Address of memory buffer.");
        break;

    case 0x160202:
        i_parser.PrintString("devdesc", "Bad memory pointer received.");
        i_parser.PrintString("moduleid", "Util::UTIL_MOD_MEM_WRITE");
        i_parser.PrintString("reasoncode", "Util::UTIL_ERC_BAD_PTR");
        i_parser.PrintString("userdata1[0:31]", "Task ID.");
        i_parser.PrintString("userdata1[31:64]", "End of File (boolean)");
        i_parser.PrintString("userdata2", "Address of memory buffer.");
        break;

    case 0x160302:
        i_parser.PrintString("devdesc", "End of file reached.");
        i_parser.PrintString("moduleid", "Util::UTIL_MOD_MEM_WRITE");
        i_parser.PrintString("reasoncode", "Util::UTIL_ERC_EOF");
        i_parser.PrintString("userdata1[0:31]", "Task ID.");
        i_parser.PrintString("userdata1[31:64]", "End of File (boolean)");
        i_parser.PrintString("userdata2", "Address of memory buffer.");
        break;

    case 0x160406:
        i_parser.PrintString("devdesc", "Unable to load LID via host interface.");
        i_parser.PrintString("moduleid", "Util::UTIL_LIDMGR_RT");
        i_parser.PrintString("reasoncode", "Util::UTIL_LIDMGR_RC_FAIL");
        i_parser.PrintString("userdata1", "Return code from lid_load call.");
        i_parser.PrintString("userdata2", "Lid number");
        break;

    case 0x160A06:
        i_parser.PrintString("devdesc", "Unable to find Lid.");
        i_parser.PrintString("moduleid", "Util::UTIL_LIDMGR_RT");
        i_parser.PrintString("reasoncode", "Util::UTIL_LIDMGR_NOT_FOUND");
        i_parser.PrintString("userdata1", "Lid number");
        break;

    case 0x160906:
        i_parser.PrintString("devdesc", "Unable to unload LID via host interface.");
        i_parser.PrintString("moduleid", "Util::UTIL_LIDMGR_RT");
        i_parser.PrintString("reasoncode", "Util::UTIL_LIDMGR_UNLOAD_RC_FAIL");
        i_parser.PrintString("userdata1", "Return code from lid_unload call.");
        break;

    case 0x161711:
        i_parser.PrintString("devdesc", "Error calling mm_block_unmap for Mcl Mgr");
        i_parser.PrintString("moduleid", "Util::UTIL_MCL_REL_MEM");
        i_parser.PrintString("reasoncode", "Util::UTIL_MM_BLOCK_UNMAP_FAILED");
        i_parser.PrintString("userdata1", "Address being removed");
        i_parser.PrintString("userdata2", "rc from mm_block_unmap");
        break;

    case 0x161610:
        i_parser.PrintString("devdesc", "Error calling mm_block_map for Mcl Mgr");
        i_parser.PrintString("moduleid", "Util::UTIL_MCL_INIT_MEM");
        i_parser.PrintString("reasoncode", "Util::UTIL_MM_BLOCK_MAP_FAILED");
        i_parser.PrintString("userdata1", "Address being allocated");
        i_parser.PrintString("userdata2", "Size of block allocation");
        break;

    case 0x160612:
        i_parser.PrintString("devdesc", "Error processing component for Mcl Mgr");
        i_parser.PrintString("moduleid", "Util::UTIL_MCL_PROCESS_COMP");
        i_parser.PrintString("reasoncode", "Util::UTIL_LIDMGR_INVAL_SIZE");
        i_parser.PrintString("userdata1[0:31]", "Total Size of Component");
        i_parser.PrintString("userdata1[32:63]", "Max size of memory region");
        i_parser.PrintString("userdata2", "Component ID [truncated to 8 bytes]");
        break;

    case 0x161812:
        i_parser.PrintString("devdesc", "Error processing component for Mcl Mgr");
        i_parser.PrintString("moduleid", "Util::UTIL_MCL_PROCESS_COMP");
        i_parser.PrintString("reasoncode", "Util::UTIL_MCL_SIZE_MISMATCH");
        i_parser.PrintString("userdata1[0:31]", "Total Size of Component");
        i_parser.PrintString("userdata1[32:63]", "Size read by FSP");
        i_parser.PrintString("userdata2", "Component ID [truncated to 8 bytes]");
        break;

    case 0x161B14:
        i_parser.PrintString("devdesc", "No matching frequency for PLL bucket");
        i_parser.PrintString("moduleid", "UTIL_MOD_GET_OBUS_PLL_BUCKET");
        i_parser.PrintString("reasoncode", "UTIL_ERC_NO_MATCHING_FREQ");
        i_parser.PrintString("userdata1", "HB Target HUID");
        i_parser.PrintString("userdata2", "Input frequency");
        break;

    case 0x161A14:
        i_parser.PrintString("devdesc", "Unable to find frequency list");
        i_parser.PrintString("moduleid", "UTIL_MOD_GET_OBUS_PLL_BUCKET");
        i_parser.PrintString("reasoncode", "UTIL_ERC_NO_FREQ_LIST");
        i_parser.PrintString("userdata1", "HB Target HUID");
        i_parser.PrintString("userdata1[0:31]", "Chip model");
        i_parser.PrintString("userdata2[32:63]", "Chip EC level");
        break;

    default:
        l_success = false;
        break;
    };
    return l_success;
}

static errl::SrcPlugin g_SrcPlugin(0x1600, SrcDataParse, ERRL_CID_HOSTBOOT);
