/*
 * Automatically generated by Hostboot's ./genErrlParsers.pl
 * Do not modify this file in the FSP tree, it is provided by
 * Hostboot and will be overwritten
 *
 * TimeStamp:   Tue May 15 13:26:15 2018
 * Image Id:    hb0515b_1820.920
 *
 */

#include <errlplugins.H>
#include <errlusrparser.H>
#include <srcisrc.H>

static bool SrcDataParse(ErrlUsrParser & i_parser,
                         const SrciSrc & i_src)
{
    uint32_t l_error = (i_src.reasonCode() << 8) + i_src.moduleId();
    bool l_success = true;

    switch(l_error)
    {
    case 0xC8181:
        i_parser.PrintString("devdesc", "Attempt to create a GARD Record for a target that is not GARDable (not DECONFIG_GARDABLE or not present)");
        i_parser.PrintString("moduleid", "HWAS::MOD_PLAT_DECONFIG_GARD");
        i_parser.PrintString("reasoncode", "HWAS::RC_TARGET_NOT_GARDABLE");
        i_parser.PrintString("userdata1", "HUID of input target // GARD errlog EID");
        i_parser.PrintString("userdata2", "ATTR_DECONFIG_GARDABLE // ATTR_HWAS_STATE.present");
        break;

    case 0xC8281:
        i_parser.PrintString("devdesc", "Attempt to create a GARD Record and the GARD Repository is full");
        i_parser.PrintString("moduleid", "HWAS::MOD_PLAT_DECONFIG_GARD");
        i_parser.PrintString("reasoncode", "HWAS::RC_GARD_REPOSITORY_FULL");
        i_parser.PrintString("userdata1", "HUID of input target // GARD errlog EID");
        break;

    case 0xC8681:
        i_parser.PrintString("devdesc", "Post de-configuration of target failed");
        i_parser.PrintString("moduleid", "HWAS::MOD_PLAT_DECONFIG_GARD");
        i_parser.PrintString("reasoncode", "HWAS::RC_RT_NULL_FIRMWARE_REQUEST_PTR");
        i_parser.PrintString("userdata1", "HUID of target");
        i_parser.PrintString("userdata2", "none");
        break;

    case 0xC8781:
        i_parser.PrintString("devdesc", "Post de-configuration of target failed");
        i_parser.PrintString("moduleid", "HWAS::MOD_PLAT_DECONFIG_GARD");
        i_parser.PrintString("reasoncode", "HWAS::RC_RT_NULL_FIRMWARE_MSG_PTR");
        i_parser.PrintString("userdata1", "HUID of target");
        i_parser.PrintString("userdata2", "none");
        break;

    case 0xC1306:
        i_parser.PrintString("devdesc", "Target is NULL");
        i_parser.PrintString("moduleid", "MOD_RUNTIME_DECONFIG");
        i_parser.PrintString("reasoncode", "RC_NULL_TARGET");
        break;

    case 0xC0306:
        i_parser.PrintString("devdesc", "Target is not a TYPE_CORE userdata1     target huid");
        i_parser.PrintString("moduleid", "MOD_RUNTIME_DECONFIG");
        i_parser.PrintString("reasoncode", "RC_INVALID_TARGET");
        break;

    case 0xC1106:
        i_parser.PrintString("devdesc", "Caller passed invalid deconfigure action");
        i_parser.PrintString("moduleid", "MOD_RUNTIME_DECONFIG");
        i_parser.PrintString("reasoncode", "RC_INVALID_PARAM");
        i_parser.PrintString("userdata1", "HUID of the target");
        i_parser.PrintString("userdata2", "Target type");
        i_parser.PrintString("userdata3", "Target class");
        i_parser.PrintString("userdata4", "Deconfig Action");
        break;

    case 0xC8382:
        i_parser.PrintString("devdesc", "platReadIDEC> Invalid chipid from hardware (all FFs)");
        i_parser.PrintString("moduleid", "HWAS::MOD_PLAT_READIDEC");
        i_parser.PrintString("reasoncode", "HWAS::RC_BAD_CHIPID");
        i_parser.PrintString("userdata1", "Target HUID");
        i_parser.PrintString("userdata2", "<unused>");
        break;

    case 0xC8583:
        i_parser.PrintString("devdesc", "platReadLx> Bad MCA target");
        i_parser.PrintString("moduleid", "HWAS::MOD_PLAT_READLX");
        i_parser.PrintString("reasoncode", "HWAS::RC_BAD_MCA");
        i_parser.PrintString("userdata1", "0");
        i_parser.PrintString("userdata2", "0");
        break;

    case 0xC8483:
        i_parser.PrintString("devdesc", "platReadLx> Invalid Lx keyword");
        i_parser.PrintString("moduleid", "HWAS::MOD_PLAT_READLX");
        i_parser.PrintString("reasoncode", "HWAS::RC_BAD_LX");
        i_parser.PrintString("userdata1", "Target MCA HUID");
        i_parser.PrintString("userdata2", "Value of x for Lx keyword");
        break;

    case 0xC0A04:
        i_parser.PrintString("devdesc", "A gard record was not applied due to a lack of resources.");
        i_parser.PrintString("moduleid", "MOD_DECONFIG_TARGETS_FROM_GARD");
        i_parser.PrintString("reasoncode", "RC_RESOURCE_RECOVERED");
        i_parser.PrintString("userdata1[00:31]", "HUID the resource");
        i_parser.PrintString("userdata2[00:31]", "EID from the gard record.");
        break;

    case 0xC0101:
        i_parser.PrintString("devdesc", "Attempt to deconfigure a target that is not deconfigurable or not present.");
        i_parser.PrintString("moduleid", "HWAS::MOD_DECONFIG_GARD");
        i_parser.PrintString("reasoncode", "HWAS::RC_TARGET_NOT_DECONFIGURABLE");
        i_parser.PrintString("userdata1[00:31]", "HUID of input target");
        i_parser.PrintString("userdata1[32:63]", "GARD errlog EID");
        i_parser.PrintString("userdata2[00:31]", "ATTR_DECONFIG_GARDABLE");
        i_parser.PrintString("userdata2[32:63]", "ATTR_HWAS_STATE.present");
        break;

    case 0xC1206:
        i_parser.PrintString("devdesc", "deconfigureTargetAtRuntime is currently only supported in hostboot runtime, this error indicates the function was called outside of the hostboot runtime context.");
        i_parser.PrintString("moduleid", "MOD_RUNTIME_DECONFIG");
        i_parser.PrintString("reasoncode", "RC_NOT_AT_RUNTIME");
        i_parser.PrintString("userdata1", "HUID of the target");
        i_parser.PrintString("userdata2", "deconfig reason - either error log id, or DeconfigGard::DECONFIGURED_BY_PRD");
        break;

    case 0xC1407:
        i_parser.PrintString("devdesc", "Due to fabric limitations, only 2 OBUSes should be configured, we found too many");
        i_parser.PrintString("moduleid", "MOD_DISABLE_OBUS");
        i_parser.PrintString("reasoncode", "RC_ONLY_TWO_OBUS_SHOULD_BE_CONFIGURED");
        i_parser.PrintString("userdata1", "HUID of proc");
        i_parser.PrintString("userdata2", "number of functional OBUSes");
        break;

    case 0xC0B03:
        i_parser.PrintString("devdesc", "checkCriticalResources found a critical resource to be deconfigured");
        i_parser.PrintString("moduleid", "MOD_CHECK_MIN_HW");
        i_parser.PrintString("reasoncode", "RC_SYSAVAIL_MISSING_CRITICAL_RESOURCE");
        i_parser.PrintString("userdata1[00:31]", "Number of critical resources");
        i_parser.PrintString("userdata1[32:63]", "HUID of first critical resource found");
        i_parser.PrintString("userdata2[00:31]", "HUID of second critical resource found, if present");
        i_parser.PrintString("userdata2[32:63]", "HUID of third critical resource found, if present");
        break;

    case 0xC0803:
        i_parser.PrintString("devdesc", "checkMinimumHardware found no functional nodes on the system");
        i_parser.PrintString("moduleid", "MOD_CHECK_MIN_HW");
        i_parser.PrintString("reasoncode", "RC_SYSAVAIL_NO_NODES_FUNC");
        break;

    case 0xC0703:
        i_parser.PrintString("devdesc", "checkMinimumHardware found no functional master processor on this node");
        i_parser.PrintString("moduleid", "MOD_CHECK_MIN_HW");
        i_parser.PrintString("reasoncode", "RC_SYSAVAIL_NO_PROCS_FUNC");
        i_parser.PrintString("userdata1[00:31]", "HUID of node");
        i_parser.PrintString("userdata2[00:31]", "number of present procs");
        i_parser.PrintString("userdata2[32:63]", "number of present functional non-master procs");
        break;

    case 0xC0503:
        i_parser.PrintString("devdesc", "checkMinimumHardware found no functional processor cores on the master proc");
        i_parser.PrintString("moduleid", "MOD_CHECK_MIN_HW");
        i_parser.PrintString("reasoncode", "RC_SYSAVAIL_NO_CORES_FUNC");
        i_parser.PrintString("userdata1[00:31]", "HUID of node");
        i_parser.PrintString("userdata1[32:63]", "HUID of master proc");
        i_parser.PrintString("userdata2[00:31]", "number of present, non-functional cores");
        break;

    case 0xC0603:
        i_parser.PrintString("devdesc", "checkMinimumHardware found no functional dimm cards.");
        i_parser.PrintString("moduleid", "MOD_CHECK_MIN_HW");
        i_parser.PrintString("reasoncode", "RC_SYSAVAIL_NO_MEMORY_FUNC");
        i_parser.PrintString("userdata1[00:31]", "HUID of node");
        i_parser.PrintString("userdata2[00:31]", "number of present, non-functional dimms");
        break;

    case 0xC0C03:
        i_parser.PrintString("devdesc", "checkMinimumHardware found no functional membufs");
        i_parser.PrintString("moduleid", "MOD_CHECK_MIN_HW");
        i_parser.PrintString("reasoncode", "RC_SYSAVAIL_NO_MCAS_FUNC");
        i_parser.PrintString("userdata1[00:31]", "HUID of node");
        i_parser.PrintString("userdata2[00:31]", "number of present nonfunctional membufs");
        break;

    case 0xC0903:
        i_parser.PrintString("devdesc", "checkMinimumHardware found no functional membufs");
        i_parser.PrintString("moduleid", "MOD_CHECK_MIN_HW");
        i_parser.PrintString("reasoncode", "RC_SYSAVAIL_NO_MEMBUFS_FUNC");
        i_parser.PrintString("userdata1[00:31]", "HUID of node");
        i_parser.PrintString("userdata2[00:31]", "number of present nonfunctional membufs");
        break;

    case 0xC0E03:
        i_parser.PrintString("devdesc", "checkMinimumHardware found no functional NX chiplets");
        i_parser.PrintString("moduleid", "MOD_CHECK_MIN_HW");
        i_parser.PrintString("reasoncode", "RC_SYSAVAIL_NO_NX_FUNC");
        i_parser.PrintString("userdata1[00:31]", "HUID of node");
        i_parser.PrintString("userdata2[00:31]", "number of present nonfunctional NX chiplets");
        break;

    case 0xC0403:
        i_parser.PrintString("devdesc", "Insufficient hardware to continue.");
        i_parser.PrintString("moduleid", "MOD_CHECK_MIN_HW");
        i_parser.PrintString("reasoncode", "RC_SYSAVAIL_INSUFFICIENT_HW");
        break;

    case 0xC0F05:
        i_parser.PrintString("devdesc", "Found a slave processor whose EC level did not match the master");
        i_parser.PrintString("moduleid", "MOD_VALIDATE_EC_LEVELS");
        i_parser.PrintString("reasoncode", "RC_EC_MISMATCH");
        i_parser.PrintString("userdata1[00:31]", "HUID of slave chip");
        i_parser.PrintString("userdata1[32:63]", "EC level of slave chip");
        i_parser.PrintString("userdata2[00:31]", "HUID of master chip");
        i_parser.PrintString("userdata2[32:63]", "EC level of master chip");
        break;

    case 0xC1005:
        i_parser.PrintString("devdesc", "Found one or more slave processor whose EC level did not match the master");
        i_parser.PrintString("moduleid", "MOD_VALIDATE_EC_LEVELS");
        i_parser.PrintString("reasoncode", "RC_FAILED_EC_VALIDATION");
        i_parser.PrintString("userdata1[00:64]", "Number of Procs");
        break;

    case 0xC0302:
        i_parser.PrintString("devdesc", "Invalid target encountered in processing of HW callout");
        i_parser.PrintString("moduleid", "HWAS::MOD_PROCESS_CALLOUT");
        i_parser.PrintString("reasoncode", "HWAS::RC_INVALID_TARGET");
        i_parser.PrintString("userdata1", "callout errlog PLID");
        break;

    default:
        l_success = false;
        break;
    };
    return l_success;
}

static errl::SrcPlugin g_SrcPlugin(0xC00, SrcDataParse, ERRL_CID_HOSTBOOT);
