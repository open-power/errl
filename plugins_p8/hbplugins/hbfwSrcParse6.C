/*
 * Automatically generated by Hostboot's ./genErrlParsers.pl
 * Do not modify this file in the FSP tree, it is provided by
 * Hostboot and will be overwritten
 *
 * TimeStamp:   Thu Apr 12 08:28:51 2018
 * Image Id:    hb0412a_1815.861
 *
 */

#include <errlplugins.H>
#include <errlusrparser.H>
#include <srcisrc.H>

static bool SrcDataParse(ErrlUsrParser & i_parser,
                         const SrciSrc & i_src)
{
    uint32_t l_error = (i_src.reasonCode() << 8) + i_src.moduleId();
    bool l_success = true;

    switch(l_error)
    {
    case 0x60215:
        i_parser.PrintString("devdesc", "PnorDD::eraseFlash> Address not on erase boundary");
        i_parser.PrintString("moduleid", "PNOR::MOD_PNORDD_ERASEFLASH");
        i_parser.PrintString("reasoncode", "PNOR::RC_INVALID_ADDRESS");
        i_parser.PrintString("userdata1", "Flash Address");
        i_parser.PrintString("userdata2", "Nearest Erase Boundary");
        break;

    case 0x61480:
        i_parser.PrintString("devdesc", "SfcAST2400::enableWriteMode> Unable to enable write mode on the PNOR flash");
        i_parser.PrintString("moduleid", "PNOR::MOD_SFCAST2400_ENABLEWRITEMODE");
        i_parser.PrintString("reasoncode", "PNOR::RC_CANNOT_ENABLE_WRITES");
        i_parser.PrintString("userdata1[24:31]", "Output from RDSR");
        i_parser.PrintString("userdata1[32:63]", "NOR chip id");
        i_parser.PrintString("userdata2", "<unused>");
        break;

    case 0x61583:
        i_parser.PrintString("devdesc", "SfcAST2400::pollOpComplete> Timeout during write or erase operation");
        i_parser.PrintString("moduleid", "PNOR::MOD_SFCAST2400_POLLOPCOMPLETE");
        i_parser.PrintString("reasoncode", "PNOR::RC_SFC_TIMEOUT");
        i_parser.PrintString("userdata1[0:31]", "NOR Flash Chip ID");
        i_parser.PrintString("userdata1[32:63]", "Total poll time (ns)");
        i_parser.PrintString("userdata2[56:63]", "Output of RDSR command");
        break;

    case 0x60C0E:
        i_parser.PrintString("devdesc", "PNOR::validateAltMaster> Fail verifying FFS Header on Master Candidate PNOR TOC0");
        i_parser.PrintString("moduleid", "PNOR::MOD_PNORVALID_MAIN");
        i_parser.PrintString("reasoncode", "PNOR::RC_PARTITION_TABLE_INVALID");
        i_parser.PrintString("userdata1", "Master Candidate Processor Target");
        i_parser.PrintString("userdata2", "<unused>");
        break;

    case 0x60C0F:
        i_parser.PrintString("devdesc", "PNOR::validateMagic> Fail verifying FFS Magic Number in Header on Master");
        i_parser.PrintString("moduleid", "PNOR::MOD_PNORVALID_MAGIC");
        i_parser.PrintString("reasoncode", "PNOR::RC_PARTITION_TABLE_INVALID");
        i_parser.PrintString("userdata1", "Magic Number read");
        i_parser.PrintString("userdata2", "<unused>");
        break;

    case 0x61BB0:
        i_parser.PrintString("devdesc", "invalid section passed to getSectionInfo");
        i_parser.PrintString("moduleid", "PNOR::MOD_RTPNOR_GETSECTIONINFO");
        i_parser.PrintString("reasoncode", "PNOR::RC_RTPNOR_INVALID_SECTION");
        i_parser.PrintString("userdata1", "PNOR::SectionId");
        break;

    case 0x61DB0:
        i_parser.PrintString("devdesc", "section size is zero");
        i_parser.PrintString("moduleid", "PNOR::MOD_RTPNOR_GETSECTIONINFO");
        i_parser.PrintString("reasoncode", "PNOR::RC_SECTION_SIZE_IS_ZERO");
        i_parser.PrintString("userdata1", "PNOR::SectionId");
        break;

    case 0x603B1:
        i_parser.PrintString("devdesc", "invalid section passed to flush");
        i_parser.PrintString("moduleid", "PNOR::MOD_RTPNOR_FLUSH");
        i_parser.PrintString("reasoncode", "PNOR::RC_INVALID_SECTION");
        i_parser.PrintString("userdata1", "PNOR::SectionId");
        break;

    case 0x61DB1:
        i_parser.PrintString("devdesc", "section size is zero");
        i_parser.PrintString("moduleid", "PNOR::MOD_RTPNOR_FLUSH");
        i_parser.PrintString("reasoncode", "PNOR::RC_SECTION_SIZE_IS_ZERO");
        i_parser.PrintString("userdata1", "PNOR::SectionId");
        break;

    case 0x616B2:
        i_parser.PrintString("devdesc", "g_hostInterfaces->pnor_read failed");
        i_parser.PrintString("moduleid", "PNOR::MOD_RTPNOR_READFROMDEVICE");
        i_parser.PrintString("reasoncode", "PNOR::RC_PNOR_READ_FAILED");
        i_parser.PrintString("userdata1[00:31]", "rc returned from pnor_read");
        i_parser.PrintString("userdata1[32:63]", "section ID");
        i_parser.PrintString("userdata2[00:31]", "offset within the section");
        i_parser.PrintString("userdata2[32:63]", "size of data read in bytes");
        break;

    case 0x62AB2:
        i_parser.PrintString("devdesc", "Amount of data read from pnor does not match expected size");
        i_parser.PrintString("moduleid", "PNOR::MOD_RTPNOR_READFROMDEVICE");
        i_parser.PrintString("reasoncode", "PNOR::RC_WRONG_SIZE_FROM_READ");
        i_parser.PrintString("userdata1[00:31]", "section ID");
        i_parser.PrintString("userdata1[32:63]", "requested size of read");
        i_parser.PrintString("userdata2[00:31]", "requested start offset into flash");
        i_parser.PrintString("userdata2[32:63]", "actual amount read");
        break;

    case 0x61FB2:
        i_parser.PrintString("devdesc", "g_hostInterfaces->pnor_read not supported");
        i_parser.PrintString("moduleid", "PNOR::MOD_RTPNOR_READFROMDEVICE");
        i_parser.PrintString("reasoncode", "PNOR::RC_PNOR_READ_NOT_SUPPORTED");
        break;

    case 0x61CB2:
        i_parser.PrintString("devdesc", "UNCORRECTABLE ECC");
        i_parser.PrintString("moduleid", "PNOR::MOD_RTPNOR_READFROMDEVICE");
        i_parser.PrintString("reasoncode", "PNOR::RC_UNCORRECTABLE_ECC");
        break;

    case 0x617B2:
        i_parser.PrintString("devdesc", "error writing corrected data back to PNOR");
        i_parser.PrintString("moduleid", "PNOR::MOD_RTPNOR_READFROMDEVICE");
        i_parser.PrintString("reasoncode", "PNOR::RC_PNOR_WRITE_FAILED");
        i_parser.PrintString("userdata1", "rc returned from pnor_write");
        i_parser.PrintString("userdata2", "Expected size of write");
        break;

    case 0x617B3:
        i_parser.PrintString("devdesc", "g_hostInterfaces->pnor_write failed");
        i_parser.PrintString("moduleid", "PNOR::MOD_RTPNOR_WRITETODEVICE");
        i_parser.PrintString("reasoncode", "PNOR::RC_PNOR_WRITE_FAILED");
        i_parser.PrintString("userdata1[00:31]", "rc returned from pnor_write");
        i_parser.PrintString("userdata1[32:63]", "section ID");
        i_parser.PrintString("userdata2[00:31]", "offset within the section");
        i_parser.PrintString("userdata2[32:63]", "size of data written in bytes");
        break;

    case 0x620B3:
        i_parser.PrintString("devdesc", "g_hostInterfaces->pnor_write not supported");
        i_parser.PrintString("moduleid", "PNOR::MOD_RTPNOR_WRITETODEVICE");
        i_parser.PrintString("reasoncode", "PNOR::RC_PNOR_WRITE_NOT_SUPPORTED");
        break;

    case 0x627B4:
        i_parser.PrintString("devdesc", "getSideInfo> Side not supported");
        i_parser.PrintString("moduleid", "PNOR::MOD_RTPNOR_GETSIDEINFO");
        i_parser.PrintString("reasoncode", "PNOR::RC_INVALID_PNOR_SIDE");
        i_parser.PrintString("userdata1", "Requested SIDE");
        i_parser.PrintString("userdata2", "0");
        break;

    case 0x61E0A:
        i_parser.PrintString("devdesc", "mm_remove_pages failed");
        i_parser.PrintString("moduleid", "PNOR::MOD_PNORRP_FLUSH");
        i_parser.PrintString("reasoncode", "PNOR::RC_MM_REMOVE_PAGES_FAILED");
        i_parser.PrintString("userdata1", "section Id");
        i_parser.PrintString("userdata2", "RC");
        break;

    case 0x60909:
        i_parser.PrintString("devdesc", "PNOR startup task returned an error.");
        i_parser.PrintString("moduleid", "PNOR::MOD_PNORRP_DIDSTARTUPFAIL");
        i_parser.PrintString("reasoncode", "PNOR::RC_BAD_STARTUP_RC");
        i_parser.PrintString("userdata1", "return code pnorrp");
        i_parser.PrintString("userdata2", "return code spnorrp");
        break;

    case 0x60405:
        i_parser.PrintString("devdesc", "PnorRP::initDaemon> Error from mm_alloc_block");
        i_parser.PrintString("moduleid", "PNOR::MOD_PNORRP_INITDAEMON");
        i_parser.PrintString("reasoncode", "PNOR::RC_EXTERNAL_ERROR");
        i_parser.PrintString("userdata1", "Requested Address");
        i_parser.PrintString("userdata2", "rc from mm_alloc_block");
        break;

    case 0x6270D:
        i_parser.PrintString("devdesc", "PnorRP::getSideInfo> Side not supported");
        i_parser.PrintString("moduleid", "PNOR::MOD_PNORRP_GETSIDEINFO");
        i_parser.PrintString("reasoncode", "PNOR::RC_INVALID_PNOR_SIDE");
        i_parser.PrintString("userdata1", "Requested SIDE");
        i_parser.PrintString("userdata2", "0");
        break;

    case 0x60503:
        i_parser.PrintString("devdesc", "PnorRP::getSectionInfo> RP not properly initialized");
        i_parser.PrintString("moduleid", "PNOR::MOD_PNORRP_GETSECTIONINFO");
        i_parser.PrintString("reasoncode", "PNOR::RC_STARTUP_FAIL");
        i_parser.PrintString("userdata1", "Requested Section");
        i_parser.PrintString("userdata2", "Startup RC");
        break;

    case 0x60303:
        i_parser.PrintString("devdesc", "PnorRP::getSectionInfo> Invalid Address for read/write");
        i_parser.PrintString("moduleid", "PNOR::MOD_PNORRP_GETSECTIONINFO");
        i_parser.PrintString("reasoncode", "PNOR::RC_INVALID_SECTION");
        i_parser.PrintString("userdata1", "Requested Section");
        i_parser.PrintString("userdata2", "TOC used");
        break;

    case 0x6290E:
        i_parser.PrintString("devdesc", "PnorRP::setSideInfo> No valid TOCs found");
        i_parser.PrintString("moduleid", "PNOR::MOD_PNORRP_SETSIDEINFO");
        i_parser.PrintString("reasoncode", "PNOR::RC_INVALID_TOC");
        i_parser.PrintString("userdata1", "Side Id");
        i_parser.PrintString("userdata2[00:31]", "primary toc");
        i_parser.PrintString("userdata2[32:63]", "backup toc");
        break;

    case 0x60101:
        i_parser.PrintString("devdesc", "PnorRP::waitForMessage> Unrecognized message type");
        i_parser.PrintString("moduleid", "PNOR::MOD_PNORRP_WAITFORMESSAGE");
        i_parser.PrintString("reasoncode", "PNOR::RC_INVALID_MESSAGE_TYPE");
        i_parser.PrintString("userdata1", "Message type");
        i_parser.PrintString("userdata2", "Requested Virtual Address");
        break;

    case 0x60601:
        i_parser.PrintString("devdesc", "PnorRP::waitForMessage> Unrecognized message type");
        i_parser.PrintString("moduleid", "PNOR::MOD_PNORRP_WAITFORMESSAGE");
        i_parser.PrintString("reasoncode", "PNOR::RC_INVALID_ASYNC_MESSAGE");
        i_parser.PrintString("userdata1", "Message type");
        i_parser.PrintString("userdata2", "Requested Virtual Address");
        break;

    case 0x60201:
        i_parser.PrintString("devdesc", "PnorRP::computeDeviceAddr> Virtual Address outside known PNOR range");
        i_parser.PrintString("moduleid", "PNOR::MOD_PNORRP_WAITFORMESSAGE");
        i_parser.PrintString("reasoncode", "PNOR::RC_INVALID_ADDRESS");
        i_parser.PrintString("userdata1", "Virtual Address");
        i_parser.PrintString("userdata2", "Base PNOR Address");
        break;

    case 0x60204:
        i_parser.PrintString("devdesc", "PnorRP::computeSection> Invalid Address");
        i_parser.PrintString("moduleid", "PNOR::MOD_PNORRP_COMPUTESECTION");
        i_parser.PrintString("reasoncode", "PNOR::RC_INVALID_ADDRESS");
        i_parser.PrintString("userdata1", "Requested Virtual Address");
        i_parser.PrintString("userdata2", "<unused>");
        break;

    case 0x6210B:
        i_parser.PrintString("devdesc", "Non ECC protected section is passed to fixECC");
        i_parser.PrintString("moduleid", "PNOR::MOD_PNORRP_FIXECC");
        i_parser.PrintString("reasoncode", "PNOR::RC_NON_ECC_PROTECTED_SECTION");
        i_parser.PrintString("userdata1", "Section ID");
        i_parser.PrintString("userdata2", "0");
        break;

    case 0x618C0:
        i_parser.PrintString("devdesc", "Both TOCs are corruputed");
        i_parser.PrintString("moduleid", "PNOR::MOD_PNORCOMMON_PARSETOC");
        i_parser.PrintString("reasoncode", "PNOR::RC_CORRUPTED_TOCS");
        break;

    case 0x619C0:
        i_parser.PrintString("devdesc", "TOC 0 doesn't have a good header");
        i_parser.PrintString("moduleid", "PNOR::MOD_PNORCOMMON_PARSETOC");
        i_parser.PrintString("reasoncode", "PNOR::RC_BAD_TOC_HEADER");
        break;

    case 0x60CC0:
        i_parser.PrintString("devdesc", "Both TOCs are corrupted");
        i_parser.PrintString("moduleid", "PNOR::MOD_PNORCOMMON_PARSETOC");
        i_parser.PrintString("reasoncode", "PNOR::RC_PARTITION_TABLE_INVALID");
        break;

    case 0x61AC0:
        i_parser.PrintString("devdesc", "Invalid partition table");
        i_parser.PrintString("moduleid", "PNOR::MOD_PNORCOMMON_PARSETOC");
        i_parser.PrintString("reasoncode", "PNOR::RC_SECTION_SIZE_IS_BIG");
        break;

    case 0x62206:
        i_parser.PrintString("devdesc", "Could not set permissions of the given PNOR section to WRITABLE");
        i_parser.PrintString("moduleid", "PNOR::MOD_PNORRP_READTOC");
        i_parser.PrintString("reasoncode", "PNOR::RC_WRITABLE_PERM_FAIL");
        i_parser.PrintString("userdata1", "PNOR section id");
        i_parser.PrintString("userdata2", "PNOR section vaddr");
        break;

    case 0x62306:
        i_parser.PrintString("devdesc", "Could not set permissions of the given PNOR section to WRITABLE/WRITE_TRACKED");
        i_parser.PrintString("moduleid", "PNOR::MOD_PNORRP_READTOC");
        i_parser.PrintString("reasoncode", "PNOR::RC_WRITE_TRACKED_PERM_FAIL");
        i_parser.PrintString("userdata1", "PNOR section id");
        i_parser.PrintString("userdata2", "PNOR section vaddr");
        break;

    case 0x60261:
        i_parser.PrintString("devdesc", "SfcFake::readFlash> Requested access exceeded the bounds of the allocated PNOR space");
        i_parser.PrintString("moduleid", "PNOR::MOD_SFCFAKE_READFLASH");
        i_parser.PrintString("reasoncode", "PNOR::RC_INVALID_ADDRESS");
        i_parser.PrintString("userdata1[0:31]", "PNOR Address");
        i_parser.PrintString("userdata1[32:63]", "Bytes to read");
        i_parser.PrintString("userdata2[0:31]", "<unused>");
        i_parser.PrintString("userdata2[32:63]", "Size of allocated PNOR space");
        break;

    case 0x60262:
        i_parser.PrintString("devdesc", "SfcFake::writeFlash> Requested access exceeded the bounds of the allocated PNOR space");
        i_parser.PrintString("moduleid", "PNOR::MOD_SFCFAKE_WRITEFLASH");
        i_parser.PrintString("reasoncode", "PNOR::RC_INVALID_ADDRESS");
        i_parser.PrintString("userdata1[0:31]", "PNOR Address");
        i_parser.PrintString("userdata1[32:63]", "Bytes to write");
        i_parser.PrintString("userdata2[0:31]", "<unused>");
        i_parser.PrintString("userdata2[32:63]", "Size of allocated PNOR space");
        break;

    case 0x60263:
        i_parser.PrintString("devdesc", "SfcFake::writeFlash> Requested access exceeded the bounds of the allocated PNOR space");
        i_parser.PrintString("moduleid", "PNOR::MOD_SFCFAKE_ERASEFLASH");
        i_parser.PrintString("reasoncode", "PNOR::RC_INVALID_ADDRESS");
        i_parser.PrintString("userdata1[0:31]", "PNOR Address");
        i_parser.PrintString("userdata1[32:63]", "<unused>");
        i_parser.PrintString("userdata2[0:31]", "Bytes in erase block");
        i_parser.PrintString("userdata2[32:63]", "Size of allocated PNOR space");
        break;

    case 0x60764:
        i_parser.PrintString("devdesc", "SfcFake::sendSpiCmd> Function is not supported");
        i_parser.PrintString("moduleid", "PNOR::MOD_SFCFAKE_SENDSPICMD");
        i_parser.PrintString("reasoncode", "PNOR::RC_UNSUPPORTED_OPERATION");
        i_parser.PrintString("userdata1[0:31]", "Op Code");
        i_parser.PrintString("userdata1[32:63]", "Address");
        i_parser.PrintString("userdata2", "<unused>");
        break;

    case 0x61543:
        i_parser.PrintString("devdesc", "SfcIBM::pollOpComplete> Error or timeout from SFC Status Register");
        i_parser.PrintString("moduleid", "PNOR::MOD_SFCIBM_POLLOPCOMPLETE");
        i_parser.PrintString("reasoncode", "PNOR::RC_SFC_TIMEOUT");
        i_parser.PrintString("userdata1[0:31]", "NOR Flash Chip ID");
        i_parser.PrintString("userdata1[32:63]", "Total poll time (ns)");
        i_parser.PrintString("userdata2[0:31]", "SFC Status Register");
        break;

    case 0x60245:
        i_parser.PrintString("devdesc", "PnorDD::eraseFlash> Address not on erase boundary");
        i_parser.PrintString("moduleid", "PNOR::MOD_SFCIBM_ERASEFLASH");
        i_parser.PrintString("reasoncode", "PNOR::RC_INVALID_ADDRESS");
        i_parser.PrintString("userdata1", "Flash address being erased");
        i_parser.PrintString("userdata2", "Nearest Erase Boundary");
        break;

    case 0x61046:
        i_parser.PrintString("devdesc", "SfcIBM::checkForErrors> Error(s) found in SFC and/or LPC Slave Status Registers");
        i_parser.PrintString("moduleid", "PNOR::MOD_SFCIBM_CHECKFORERRORS");
        i_parser.PrintString("reasoncode", "PNOR::RC_ERROR_IN_STATUS_REG");
        i_parser.PrintString("userdata1[0:31]", "SFC Status Register");
        i_parser.PrintString("userdata1[32:63]", "LPC Slave Status Register");
        i_parser.PrintString("userdata2", "Reset Level");
        break;

    case 0x60747:
        i_parser.PrintString("devdesc", "SfcIBM::hwReset> Unsupported Reset Level requested");
        i_parser.PrintString("moduleid", "PNOR::MOD_SFCIBM_HWRESET");
        i_parser.PrintString("reasoncode", "PNOR::RC_UNSUPPORTED_OPERATION");
        i_parser.PrintString("userdata1", "Unsupported Reset Level Parameter");
        i_parser.PrintString("userdata2", "<unused>");
        break;

    case 0x604D2:
        i_parser.PrintString("devdesc", "SPnorRP::initDaemon> Error from mm_alloc_block");
        i_parser.PrintString("moduleid", "PNOR::MOD_SPNORRP_ALLOCATE_BLOCK");
        i_parser.PrintString("reasoncode", "PNOR::RC_EXTERNAL_ERROR");
        i_parser.PrintString("userdata1", "Requested Address");
        i_parser.PrintString("userdata2", "rc from mm_alloc_block");
        break;

    case 0x604D5:
        i_parser.PrintString("devdesc", "Could not set permissions of the given PNOR section");
        i_parser.PrintString("moduleid", "PNOR::MOD_SPNORRP_SET_PERMISSION");
        i_parser.PrintString("reasoncode", "PNOR::RC_EXTERNAL_ERROR");
        i_parser.PrintString("userdata1", "Requested Address");
        i_parser.PrintString("userdata2", "rc from mm_set_permission");
        break;

    case 0x601D3:
        i_parser.PrintString("devdesc", "PnorRP::waitForMessage> Unrecognized message type");
        i_parser.PrintString("moduleid", "PNOR::MOD_SPNORRP_WAITFORMESSAGE");
        i_parser.PrintString("reasoncode", "PNOR::RC_INVALID_MESSAGE_TYPE");
        i_parser.PrintString("userdata1", "Message type");
        i_parser.PrintString("userdata2", "Requested Virtual Address");
        break;

    case 0x60BA0:
        i_parser.PrintString("devdesc", "micronFlagStatus> Error or timeout from Micron Flag Status Register");
        i_parser.PrintString("moduleid", "PNOR::MOD_NORMICRON_MICRONFLAGSTATUS");
        i_parser.PrintString("reasoncode", "PNOR::RC_MICRON_INCOMPLETE");
        i_parser.PrintString("userdata1[0:31]", "Micron Flag status register");
        i_parser.PrintString("userdata2", "NOR Flash Chip ID");
        break;

    default:
        l_success = false;
        break;
    };
    return l_success;
}

static errl::SrcPlugin g_SrcPlugin(0x600, SrcDataParse, ERRL_CID_HOSTBOOT);
