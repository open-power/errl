
#ifndef TARG_ATTRIBUTEENUMS_H
#define TARG_ATTRIBUTEENUMS_H

/**
 *  @file attributeenums.H
 *
 *  @brief Defined enums for platform attributes
 *
 *  This header file contains enumerations for supported platform attributes
 *  (as opposed to HWPF attributes).  This file is automatically
 *  generated and should not be altered.
 */

//******************************************************************************
// Includes
//******************************************************************************

#include <stdint.h>
#include <stdlib.h>

//******************************************************************************
// Enumerations
//******************************************************************************

namespace TARGETING
{

/**
 *  @brief Platform attribute IDs
 *
 *  Enumeration defining every possible platform attribute that can be
 *  associated with a target. This file is autogenerated and should not be
 *  altered.
 */
enum ATTRIBUTE_ID
{
    ATTR_NA                                                        = 0,
    ATTR_FREQ_PROC_REFCLOCK_KHZ                                    = 0x1b7a6ae,
    ATTR_FREQ_MEM_REFCLOCK                                         = 0x29e287c,
    ATTR_MAX_ALLOWED_DIMM_FREQ                                     = 0x01e31e8,
    ATTR_MEMVPD_POS                                                = 0x88381f0,
    ATTR_REQUIRED_SYNCH_MODE                                       = 0x83fe364,
    ATTR_MSS_VPD_CKE_MAP                                           = 0x893594e,
    ATTR_MSS_VPD_DQ_MAP                                            = 0xe85ca14,
    ATTR_MSS_FREQ_OVERRIDE                                         = 0x1812aa2,
    ATTR_MSS_FREQ                                                  = 0xe88d183,
    ATTR_MSS_FREQ_BIAS_PERCENTAGE                                  = 0xb42bb51,
    ATTR_EFF_DIMM_SPARE                                            = 0xc624c4f,
    ATTR_EFF_DRAM_WR_VREF                                          = 0x6945cc9,
    ATTR_EFF_DRAM_WR_VREF_SCHMOO                                   = 0xec9685a,
    ATTR_EFF_DRAM_WRDDR4_VREF_SCHMOO                               = 0x467b4af,
    ATTR_EFF_DIMM_SIZE                                             = 0xc1e40a4,
    ATTR_EFF_DRAM_CL                                               = 0x97a894d,
    ATTR_EFF_DRAM_AL                                               = 0x988b61c,
    ATTR_EFF_DRAM_CWL                                              = 0xe66c2c2,
    ATTR_EFF_DRAM_RBT                                              = 0x2dd5bf0,
    ATTR_EFF_DRAM_TM                                               = 0x1295a71,
    ATTR_EFF_DRAM_DLL_RESET                                        = 0x8a96823,
    ATTR_EFF_DRAM_DLL_PPD                                          = 0xe7ac6ac,
    ATTR_EFF_DRAM_DLL_ENABLE                                       = 0x2ef3cf5,
    ATTR_EFF_DRAM_WR_LVL_ENABLE                                    = 0x4f7511d,
    ATTR_EFF_DRAM_OUTPUT_BUFFER                                    = 0x616737c,
    ATTR_EFF_DRAM_PASR                                             = 0x7692ee2,
    ATTR_EFF_DRAM_ASR                                              = 0xa8ace8e,
    ATTR_EFF_DRAM_SRT                                              = 0x12af03d,
    ATTR_EFF_MPR_LOC                                               = 0x9fb1838,
    ATTR_EFF_MPR_MODE                                              = 0x6cc620b,
    ATTR_EFF_DIMM_DDR4_RC00                                        = 0x0dbf64a,
    ATTR_EFF_DIMM_DDR4_RC01                                        = 0xbb8efa0,
    ATTR_EFF_DIMM_DDR4_RC02                                        = 0xb472f05,
    ATTR_EFF_DIMM_DDR4_RC03                                        = 0x3bdf1ae,
    ATTR_EFF_DIMM_DDR4_RC04                                        = 0x03fc440,
    ATTR_EFF_DIMM_DDR4_RC05                                        = 0x193adc4,
    ATTR_EFF_DIMM_DDR4_RC06_07                                     = 0x7910db8,
    ATTR_EFF_DIMM_DDR4_RC08                                        = 0x56acd0c,
    ATTR_EFF_DIMM_DDR4_RC09                                        = 0xb2c0de0,
    ATTR_EFF_DIMM_DDR4_RC0A                                        = 0x464ca55,
    ATTR_EFF_DIMM_DDR4_RC0B                                        = 0x7b5be1e,
    ATTR_EFF_DIMM_DDR4_RC0C                                        = 0xb57d29f,
    ATTR_EFF_DIMM_DDR4_RC0D                                        = 0xa07ef50,
    ATTR_EFF_DIMM_DDR4_RC0E                                        = 0x39d1412,
    ATTR_EFF_DIMM_DDR4_RC0F                                        = 0xd15b7ce,
    ATTR_EFF_DIMM_DDR4_RC_1x                                       = 0xba52471,
    ATTR_EFF_DIMM_DDR4_RC_2x                                       = 0x11a491d,
    ATTR_EFF_DIMM_DDR4_RC_3x                                       = 0x63718cd,
    ATTR_EFF_DIMM_DDR4_RC_4x                                       = 0xb024826,
    ATTR_EFF_DIMM_DDR4_RC_5x                                       = 0x2a65deb,
    ATTR_EFF_DIMM_DDR4_RC_6x                                       = 0x316a223,
    ATTR_EFF_DIMM_DDR4_RC_7x                                       = 0xe15f4fa,
    ATTR_EFF_DIMM_DDR4_RC_8x                                       = 0x7838fe1,
    ATTR_EFF_DIMM_DDR4_RC_9x                                       = 0x5b489c1,
    ATTR_EFF_DIMM_DDR4_RC_Ax                                       = 0xadb037b,
    ATTR_EFF_DIMM_DDR4_RC_Bx                                       = 0x4e0fd63,
    ATTR_EFF_DIMM_RCD_MIRROR_MODE                                  = 0x883151c,
    ATTR_EFF_SCHMOO_MODE                                           = 0x049733a,
    ATTR_EFF_SCHMOO_ADDR_MODE                                      = 0x48f34e1,
    ATTR_EFF_SCHMOO_TEST_VALID                                     = 0x1c93902,
    ATTR_EFF_SCHMOO_PARAM_VALID                                    = 0x8115303,
    ATTR_EFF_SCHMOO_WR_EYE_MIN_MARGIN                              = 0xff97f93,
    ATTR_EFF_SCHMOO_RD_EYE_MIN_MARGIN                              = 0x1cfb0ee,
    ATTR_EFF_SCHMOO_DQS_CLK_MIN_MARGIN                             = 0x76ec3b2,
    ATTR_EFF_SCHMOO_RD_GATE_MIN_MARGIN                             = 0x05e2bac,
    ATTR_EFF_SCHMOO_ADDR_CMD_MIN_MARGIN                            = 0x4d7ff4b,
    ATTR_EFF_MEMCAL_INTERVAL                                       = 0xf7a4d1e,
    ATTR_EFF_ZQCAL_INTERVAL                                        = 0x629a976,
    ATTR_EFF_IBM_TYPE                                              = 0x82e6cdd,
    ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM                             = 0x0e715c8,
    ATTR_EFF_DIMM_RANKS_CONFIGED                                   = 0x092ecab,
    ATTR_EFF_PRIM_DIE_COUNT                                        = 0xe44453d,
    ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_PORT                     = 0x8469517,
    ATTR_MSS_MEM_PORT_POS_OF_FAIL_THROTTLE                         = 0x079546e,
    ATTR_MSS_MEM_M_DRAM_CLOCKS                                     = 0xde9b2c0,
    ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT                     = 0x0a9317e,
    ATTR_MSS_MEM_WATT_TARGET                                       = 0x2e31113,
    ATTR_MSS_TOTAL_PWR_SLOPE                                       = 0xa389d3d,
    ATTR_MSS_TOTAL_PWR_INTERCEPT                                   = 0x03b0320,
    ATTR_MSS_DIMM_MAXBANDWIDTH_GBS                                 = 0xd03076a,
    ATTR_MSS_DIMM_MAXBANDWIDTH_MRS                                 = 0xf6f5210,
    ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_GBS                         = 0x57d7489,
    ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_MRS                         = 0xa5ac06a,
    ATTR_MSS_DIMM_MAXPOWER                                         = 0x9f616e0,
    ATTR_MSS_DATABUS_UTIL                                          = 0xa334b21,
    ATTR_MSS_PORT_MAXPOWER                                         = 0xbddd69f,
    ATTR_MSS_DIMM_THERMAL_LIMIT                                    = 0x5afde5c,
    ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT             = 0xf34c5f2,
    ATTR_MSS_RUNTIME_MEM_M_DRAM_CLOCKS                             = 0xe428629,
    ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT             = 0x30c5225,
    ATTR_MSS_EFF_DIMM_FUNCTIONAL_VECTOR                            = 0x578c150,
    ATTR_EFF_DRAM_LPASR                                            = 0xa6f4fe9,
    ATTR_EFF_MPR_PAGE                                              = 0x4a8236c,
    ATTR_EFF_GEARDOWN_MODE                                         = 0xdf0a068,
    ATTR_EFF_PER_DRAM_ACCESS                                       = 0xf217fea,
    ATTR_EFF_TEMP_READOUT                                          = 0x857908e,
    ATTR_EFF_CRC_WR_LATENCY                                        = 0x09f03dd,
    ATTR_EFF_MPR_RD_FORMAT                                         = 0x49c4f61,
    ATTR_EFF_MAX_POWERDOWN_MODE                                    = 0x7c5012d,
    ATTR_EFF_INTERNAL_VREF_MONITOR                                 = 0xeee1ede,
    ATTR_EFF_CS_CMD_LATENCY                                        = 0xf41a79e,
    ATTR_EFF_SELF_REF_ABORT                                        = 0x33b24bf,
    ATTR_EFF_RD_PREAMBLE_TRAIN                                     = 0x6440e8c,
    ATTR_EFF_RD_PREAMBLE                                           = 0x9285080,
    ATTR_EFF_WR_PREAMBLE                                           = 0x5402adf,
    ATTR_EFF_CA_PARITY_LATENCY                                     = 0xe1c6e23,
    ATTR_EFF_CRC_ERROR_CLEAR                                       = 0x88424ac,
    ATTR_EFF_CA_PARITY_ERROR_STATUS                                = 0x39f6ac3,
    ATTR_EFF_ODT_INPUT_BUFF                                        = 0x552f10f,
    ATTR_EFF_CA_PARITY                                             = 0xc49c5d6,
    ATTR_EFF_DATA_MASK                                             = 0x7881e32,
    ATTR_EFF_WRITE_DBI                                             = 0x8d4bb23,
    ATTR_EFF_READ_DBI                                              = 0x0035c53,
    ATTR_EFF_VREF_DQ_TRAIN_VALUE                                   = 0x88a9505,
    ATTR_EFF_VREF_DQ_TRAIN_RANGE                                   = 0x7d9ebb7,
    ATTR_EFF_VREF_DQ_TRAIN_ENABLE                                  = 0x9aa76c2,
    ATTR_EFF_WRITE_CRC                                             = 0xd9af284,
    ATTR_MSS_CAL_STEP_ENABLE                                       = 0x832191c,
    ATTR_MSS_CUSTOM_TRAINING_ADV_PATTERNS                          = 0x72e879b,
    ATTR_MSS_CUSTOM_TRAINING_ADV_BACKUP_PATTERNS                   = 0x91172b5,
    ATTR_MSS_VREF_CAL_ENABLE                                       = 0x6ed96de,
    ATTR_MSS_RDVREF_CAL_ENABLE                                     = 0x7ce66ef,
    ATTR_MSS_CAL_ABORT_ON_ERROR                                    = 0xff291f4,
    ATTR_MSS_SLEW_RATE_DATA                                        = 0x71c3bfc,
    ATTR_MSS_SLEW_RATE_ADR                                         = 0x4ad3c3b,
    ATTR_SCHMOO_MULTIPLE_SETUP_CALL                                = 0x12f9f97,
    ATTR_EFF_BUFFER_LATENCY                                        = 0x4d42dc7,
    ATTR_EFF_LRDIMM_WORD_X                                         = 0xd77577c,
    ATTR_LRDIMM_MR12_REG                                           = 0xa9aecb6,
    ATTR_LRDIMM_ADDITIONAL_CNTL_WORDS                              = 0x3eae089,
    ATTR_LRDIMM_RANK_MULT_MODE                                     = 0x5472ed9,
    ATTR_MSS_EFF_VPD_VERSION                                       = 0x0b098c5,
    ATTR_MSS_VOLT_OVERRIDE                                         = 0x9b6221c,
    ATTR_MSS_VDDR_OVERIDE_SPD                                      = 0xbb01f4d,
    ATTR_MSS_VMEM_REGULATOR_MAX_DIMM_COUNT                         = 0xa6ef3db,
    ATTR_MSS_VREF_DAC_NIBBLE                                       = 0xdbfbe2d,
    ATTR_MSS_VCCD_OVERRIDE                                         = 0x11d5578,
    ATTR_EFF_DRAM_MAC                                              = 0xcc1d237,
    ATTR_EFF_DRAM_MODULE_BUS_WIDTH                                 = 0x3d7baaf,
    ATTR_EFF_DRAM_RTT_NOM                                          = 0xe2d72d1,
    ATTR_EFF_DRAM_RTT_WR                                           = 0xdfdac0f,
    ATTR_EFF_DRAM_RTT_PARK                                         = 0x10d0cba,
    ATTR_EFF_DIMM_DDR4_BC00                                        = 0x9f09ef3,
    ATTR_EFF_DIMM_DDR4_BC01                                        = 0x025d61b,
    ATTR_EFF_DIMM_DDR4_BC02                                        = 0xc9e6a86,
    ATTR_EFF_DIMM_DDR4_BC03                                        = 0xec45ccd,
    ATTR_EFF_DIMM_DDR4_BC04                                        = 0x16647d1,
    ATTR_EFF_DIMM_DDR4_BC05                                        = 0xab55622,
    ATTR_EFF_DIMM_DDR4_BC06                                        = 0x367b0cf,
    ATTR_EFF_DIMM_DDR4_BC07                                        = 0xe4b2093,
    ATTR_EFF_DIMM_DDR4_BC08                                        = 0xc932360,
    ATTR_EFF_DIMM_DDR4_BC09                                        = 0x965f70d,
    ATTR_EFF_DIMM_DDR4_BC0A                                        = 0xa8aa61f,
    ATTR_EFF_DIMM_DDR4_BC0B                                        = 0x9baa851,
    ATTR_EFF_DIMM_DDR4_BC0C                                        = 0x9bca452,
    ATTR_EFF_DIMM_DDR4_BC0D                                        = 0x39f9d81,
    ATTR_EFF_DIMM_DDR4_BC0E                                        = 0x30657d3,
    ATTR_EFF_DIMM_DDR4_BC0F                                        = 0xce75758,
    ATTR_EFF_DIMM_DDR4_F0BC1x                                      = 0xf716883,
    ATTR_EFF_DIMM_DDR4_F30BC2x                                     = 0xa8a5557,
    ATTR_EFF_DIMM_DDR4_F30BC3x                                     = 0x898d1da,
    ATTR_EFF_DIMM_DDR4_F30BC4x                                     = 0xdc9830a,
    ATTR_EFF_DIMM_DDR4_F30BC5x                                     = 0xa6c1e85,
    ATTR_EFF_DIMM_DDR4_F0BC6x                                      = 0x44ac68a,
    ATTR_EFF_DIMM_DDR4_F70BC7x                                     = 0xd21a679,
    ATTR_EFF_DIMM_DDR4_F30BC8x                                     = 0x632b0fc,
    ATTR_EFF_DIMM_DDR4_F30BC9x                                     = 0x2bed23e,
    ATTR_EFF_DIMM_DDR4_F30BCAx                                     = 0x1c8e5ad,
    ATTR_EFF_DIMM_DDR4_F30BCBx                                     = 0x6eb57f8,
    ATTR_EFF_DIMM_DDR4_F0BCCx                                      = 0x1c74b50,
    ATTR_EFF_DIMM_DDR4_F0BCDx                                      = 0x50d9c31,
    ATTR_EFF_DIMM_DDR4_F0BCEx                                      = 0x7451b69,
    ATTR_EFF_DIMM_DDR4_F0BCFx                                      = 0xf51eeab,
    ATTR_EFF_DIMM_DDR4_F1BCCx                                      = 0x348d207,
    ATTR_EFF_DIMM_DDR4_F1BCDx                                      = 0xa4b2ccd,
    ATTR_EFF_DIMM_DDR4_F1BCEx                                      = 0xe80ba73,
    ATTR_EFF_DIMM_DDR4_F1BCFx                                      = 0x106a5a8,
    ATTR_EFF_DIMM_DDR4_F4BC0x                                      = 0x97ef6f1,
    ATTR_EFF_DIMM_DDR4_F4BC1x                                      = 0xae05d47,
    ATTR_EFF_DIMM_DDR4_F4BC2x                                      = 0xeb183bf,
    ATTR_EFF_DIMM_DDR4_F4BC3x                                      = 0x17024a5,
    ATTR_EFF_DIMM_DDR4_F4BC4x                                      = 0xcb0149a,
    ATTR_EFF_DIMM_DDR4_F4BC5x                                      = 0x3ebe386,
    ATTR_EFF_DIMM_DDR4_F4BC6x                                      = 0x093748e,
    ATTR_EFF_DIMM_DDR4_F5BC0x                                      = 0x6dd9b32,
    ATTR_EFF_DIMM_DDR4_F5BC1x                                      = 0x970c888,
    ATTR_EFF_DIMM_DDR4_F5BC2x                                      = 0x518af90,
    ATTR_EFF_DIMM_DDR4_F5BC3x                                      = 0x86de6f2,
    ATTR_EFF_DIMM_DDR4_F5BC5x                                      = 0xc4c6956,
    ATTR_EFF_DIMM_DDR4_F5BC6x                                      = 0xce86ef2,
    ATTR_EFF_DIMM_DDR4_F6BC0x                                      = 0x59e99e9,
    ATTR_EFF_DIMM_DDR4_F6BC1x                                      = 0xf2c440f,
    ATTR_EFF_DIMM_DDR4_F6BC2x                                      = 0x565b92c,
    ATTR_EFF_DIMM_DDR4_F6BC3x                                      = 0x56096a3,
    ATTR_EFF_DIMM_DDR4_F6BC4x                                      = 0xb9ed8a3,
    ATTR_EFF_DIMM_DDR4_F6BC5x                                      = 0xd675fd7,
    ATTR_EFF_DIMM_DDR4_F74BC8x                                     = 0xa69c5b6,
    ATTR_EFF_DIMM_DDR4_F74BC9x                                     = 0xc5e8a7d,
    ATTR_EFF_DIMM_DDR4_F74BCAx                                     = 0xc60f5d1,
    ATTR_EFF_DIMM_DDR4_F74BCBx                                     = 0x6658888,
    ATTR_EFF_DIMM_DDR4_F74BCCx                                     = 0x391d99a,
    ATTR_EFF_DIMM_DDR4_F74BCDx                                     = 0x7fa2b10,
    ATTR_EFF_DIMM_DDR4_F74BCEx                                     = 0xada1877,
    ATTR_EFF_DIMM_DDR4_F74BCFx                                     = 0xd09004f,
    ATTR_EFF_DRAM_RON                                              = 0x4ac394b,
    ATTR_EFF_DRAM_TDQS                                             = 0x92d72b7,
    ATTR_EFF_DRAM_TREFI                                            = 0x20fbdcf,
    ATTR_EFF_DRAM_TRTP                                             = 0x9791cea,
    ATTR_EFF_DRAM_TRFC_DLR                                         = 0xdb87b55,
    ATTR_EFF_DRAM_TFAW_DLR                                         = 0x94577f3,
    ATTR_EFF_DRAM_TRRD_DLR                                         = 0x4081691,
    ATTR_EFF_DRAM_TXS                                              = 0xf26c1ee,
    ATTR_MSS_IGNORE_PLUG_RULES                                     = 0x469b49b,
    ATTR_MSS_MVPD_FWMS                                             = 0x3167876,
    ATTR_MSS_REORDER_QUEUE_SETTING                                 = 0x8da66d4,
    ATTR_EFF_RANK_GROUP_OVERRIDE                                   = 0x18d405f,
    ATTR_MSS_RTT_NOM_OVERRIDE_DISABLE                              = 0xd34bb04,
    ATTR_MSS_VPD_MR_0_VERSION_LAYOUT                               = 0x2eb771c,
    ATTR_MSS_VPD_MR_1_VERSION_DATA                                 = 0x0a3c06d,
    ATTR_MSS_VPD_MR_2_SIGNATURE_HASH                               = 0x63a654c,
    ATTR_MSS_VPD_MR_DPHY_GPO                                       = 0xaf8883d,
    ATTR_MSS_VPD_MR_DPHY_RLO                                       = 0xe421f44,
    ATTR_MSS_VPD_MR_DPHY_WLO                                       = 0x3388aef,
    ATTR_MSS_VPD_MR_MC_2N_MODE_AUTOSET                             = 0xfa51a3e,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A00                          = 0xa8235cc,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A01                          = 0xa1b24d4,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A02                          = 0xfd009d5,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A03                          = 0xbb69a29,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A04                          = 0x9f54ba4,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A05                          = 0x3a84164,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A06                          = 0x462ffde,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A07                          = 0xcfde8a8,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A08                          = 0x5725019,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A09                          = 0x4f951bc,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A10                          = 0xbdb5559,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A11                          = 0x2d88c22,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A12                          = 0x2520084,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A13                          = 0xa58bbd8,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A17                          = 0x4770499,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA0                          = 0xc0fc67a,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA1                          = 0x3ab26b4,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG0                          = 0x43438a4,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG1                          = 0x5804b81,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C0                           = 0xaffb9fe,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C1                           = 0x3c77248,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C2                           = 0xa1cea11,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ACTN                          = 0xfe7bdde,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_CASN_A15                 = 0x975821d,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_RASN_A16                 = 0x70b6294,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_WEN_A14                  = 0x7a97b24,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_PAR                           = 0xbc28284,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE0                      = 0xb6aa7a5,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE1                      = 0xab62254,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN0                      = 0xb52a50d,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN1                      = 0xf7b498d,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT0                      = 0x9134bd8,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT1                      = 0xec381e5,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE0                      = 0xf3b0140,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE1                      = 0x0642dce,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN0                      = 0x2fde2e8,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN1                      = 0xc7021c1,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT0                      = 0x1762315,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT1                      = 0x8225533,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKN                           = 0x8b740a2,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKP                           = 0x1020074,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKN                           = 0xa2af804,
    ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKP                           = 0xc369bc5,
    ATTR_MSS_VPD_MR_TSYS_ADR                                       = 0x8b952fa,
    ATTR_MSS_VPD_MR_TSYS_DATA                                      = 0xba5c0ae,
    ATTR_MSS_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT        = 0x5fd9713,
    ATTR_MSS_MRW_THERMAL_MEMORY_POWER_LIMIT                        = 0xbe06c50,
    ATTR_MSS_MRW_PWR_INTERCEPT                                     = 0xc0f9335,
    ATTR_MSS_MRW_PWR_SLOPE                                         = 0xb3e8ad9,
    ATTR_MSS_MRW_REFRESH_RATE_REQUEST                              = 0xbd13798,
    ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT                   = 0xd4bbddc,
    ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_IDLE              = 0x07bf802,
    ATTR_MSS_MRW_MEM_M_DRAM_CLOCKS                                 = 0x0fb9e1f,
    ATTR_MSS_MRW_MAX_DRAM_DATABUS_UTIL                             = 0x61d3421,
    ATTR_MSS_MRW_MCS_PREFETCH_RETRY_THRESHOLD                      = 0xeab9168,
    ATTR_MSS_MRW_POWER_CONTROL_REQUESTED                           = 0x6d05234,
    ATTR_MSS_MRW_IDLE_POWER_CONTROL_REQUESTED                      = 0x7f51090,
    ATTR_MSS_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE    = 0xe5e91b7,
    ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR3       = 0x1949903,
    ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR4       = 0x414abdc,
    ATTR_MSS_MRW_MAX_NUMBER_DIMMS_POSSIBLE_PER_VMEM_REGULATOR      = 0x3e06dcd,
    ATTR_MSS_MRW_AVDD_OFFSET_DISABLE                               = 0x34871b7,
    ATTR_MSS_MRW_VDD_OFFSET_DISABLE                                = 0x113992c,
    ATTR_MSS_MRW_VCS_OFFSET_DISABLE                                = 0xa110647,
    ATTR_MSS_MRW_VPP_OFFSET_DISABLE                                = 0xb455190,
    ATTR_MSS_MRW_VDDR_OFFSET_DISABLE                               = 0xca2733d,
    ATTR_MSS_MRW_FINE_REFRESH_MODE                                 = 0x87bdfb9,
    ATTR_MSS_MRW_TEMP_REFRESH_RANGE                                = 0x99f7795,
    ATTR_MSS_MRW_RESET_DELAY_BEFORE_CAL                            = 0x4f60a5e,
    ATTR_MSS_MRW_PREFETCH_ENABLE                                   = 0x70c6446,
    ATTR_MSS_MRW_CLEANER_ENABLE                                    = 0xfa55dea,
    ATTR_MSS_MRW_PERIODIC_MEMCAL_MODE_OPTIONS                      = 0x9c3a3d6,
    ATTR_MSS_MRW_PERIODIC_ZQCAL_MODE_OPTIONS                       = 0x1fddb6b,
    ATTR_MSS_MRW_DRAM_2N_MODE                                      = 0x2997eae,
    ATTR_MSS_MRW_SUPPORTED_FREQ                                    = 0x23d66fa,
    ATTR_MSS_MRW_UNSUPPORTED_RANK_CONFIG                           = 0xc1c206e,
    ATTR_MSS_MRW_DRAM_WRITE_CRC                                    = 0x7b7fc78,
    ATTR_MSS_MRW_TEMP_REFRESH_MODE                                 = 0x4c3dbf1,
    ATTR_MSS_VPD_MT_0_VERSION_LAYOUT                               = 0x047ef58,
    ATTR_MSS_VPD_MT_1_VERSION_DATA                                 = 0x65e73dc,
    ATTR_MSS_VPD_MT_2_SIGNATURE_HASH                               = 0x783ce08,
    ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CA                                = 0x3b9d83b,
    ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CKE                               = 0x5e2695c,
    ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CS                                = 0x4d481e1,
    ATTR_MSS_VPD_MT_DIMM_RCD_IBT_ODT                               = 0xe2df6e2,
    ATTR_MSS_VPD_MT_DRAM_DRV_IMP_DQ_DQS                            = 0x7c84715,
    ATTR_MSS_VPD_MT_DRAM_RTT_NOM                                   = 0x0f8b173,
    ATTR_MSS_VPD_MT_DRAM_RTT_PARK                                  = 0x19ad3b5,
    ATTR_MSS_VPD_MT_DRAM_RTT_WR                                    = 0xc8013d9,
    ATTR_MSS_VPD_MT_MC_BIAS_TRIM                                   = 0x18dd068,
    ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_RD_UP                            = 0x83aea0f,
    ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_DOWN                          = 0xfb7a7e9,
    ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_UP                            = 0x0dbcd50,
    ATTR_MSS_VPD_MT_MC_DQ_CTLE_CAP                                 = 0xfaa8c76,
    ATTR_MSS_VPD_MT_MC_DQ_CTLE_RES                                 = 0x3b94bc2,
    ATTR_MSS_VPD_MT_MC_DRV_IMP_CLK                                 = 0x3ed588d,
    ATTR_MSS_VPD_MT_MC_DRV_IMP_CMD_ADDR                            = 0x263bb20,
    ATTR_MSS_VPD_MT_MC_DRV_IMP_CNTL                                = 0x40553a7,
    ATTR_MSS_VPD_MT_MC_DRV_IMP_CSCID                               = 0x9147263,
    ATTR_MSS_VPD_MT_MC_DRV_IMP_DQ_DQS                              = 0x9e57914,
    ATTR_MSS_VPD_MT_MC_RCV_IMP_DQ_DQS                              = 0xa3884a4,
    ATTR_MSS_VPD_MT_ODT_RD                                         = 0x22ad0be,
    ATTR_MSS_VPD_MT_ODT_WR                                         = 0xabb67d1,
    ATTR_MSS_VPD_MT_PREAMBLE                                       = 0x5c3e6d5,
    ATTR_MSS_VPD_MT_VREF_DRAM_WR                                   = 0x2de5814,
    ATTR_MSS_VPD_MT_VREF_MC_RD                                     = 0xb3185b9,
    ATTR_MSS_VPD_MT_WINDAGE_RD_CTR                                 = 0xec9b003,
    ATTR_VPD_OVERRIDE_MT                                           = 0xf0c49e4,
    ATTR_VPD_OVERRIDE_MT_ENABLE                                    = 0xa344932,
    ATTR_VPD_OVERRIDE_MR                                           = 0xf58569d,
    ATTR_VPD_OVERRIDE_MR_ENABLE                                    = 0x6a276dd,
    ATTR_VPD_OVERRIDE_DQ                                           = 0x7a98e7d,
    ATTR_VPD_OVERRIDE_DQ_ENABLE                                    = 0xf9808c0,
    ATTR_VPD_OVERRIDE_CK                                           = 0x332e75d,
    ATTR_VPD_OVERRIDE_CK_ENABLE                                    = 0xfaad3a9,
    ATTR_VPD_OVERRIDE_MW                                           = 0xe54fb9c,
    ATTR_VPD_OVERRIDE_MW_ENABLE                                    = 0x0a779ef,
    ATTR_SPD_OVERRIDE                                              = 0x23b609f,
    ATTR_SPD_OVERRIDE_ENABLE                                       = 0x8a00d0f,
    ATTR_EFF_DRAM_GEN                                              = 0x0d33633,
    ATTR_EFF_DIMM_TYPE                                             = 0xe35b4c7,
    ATTR_EFF_HYBRID_MEMORY_TYPE                                    = 0xa71dd22,
    ATTR_EFF_HYBRID                                                = 0x43cb904,
    ATTR_EFF_DRAM_DENSITY                                          = 0x07a9643,
    ATTR_EFF_DRAM_BANK_BITS                                        = 0x06d133f,
    ATTR_EFF_DRAM_BANK_GROUP_BITS                                  = 0x667433c,
    ATTR_EFF_DRAM_COLUMN_BITS                                      = 0x2f2f11c,
    ATTR_EFF_DRAM_ROW_BITS                                         = 0x1c28c5e,
    ATTR_EFF_PRIM_STACK_TYPE                                       = 0x4934fda,
    ATTR_EFF_DRAM_PPR                                              = 0x96494e2,
    ATTR_EFF_DRAM_SOFT_PPR                                         = 0x5534fbf,
    ATTR_EFF_DRAM_TRCD                                             = 0xc9b93c9,
    ATTR_EFF_DRAM_TRP                                              = 0x8b78d35,
    ATTR_EFF_DRAM_TRAS                                             = 0xa982f98,
    ATTR_EFF_DRAM_TRC                                              = 0x7461177,
    ATTR_EFF_DRAM_TRFC                                             = 0x878bcaf,
    ATTR_EFF_DRAM_TFAW                                             = 0xaf91cc7,
    ATTR_EFF_DRAM_TRRD_S                                           = 0xd6045da,
    ATTR_EFF_DRAM_TRRD_L                                           = 0x5ab71e7,
    ATTR_EFF_DRAM_TCCD_L                                           = 0x732fad3,
    ATTR_EFF_DRAM_TWR                                              = 0x05193dd,
    ATTR_EFF_DRAM_TWTR_S                                           = 0x440bec8,
    ATTR_EFF_DRAM_TWTR_L                                           = 0x8cd1455,
    ATTR_EFF_DRAM_TMAW                                             = 0x8196e7d,
    ATTR_EFF_DRAM_WIDTH                                            = 0xbcc0968,
    ATTR_EFF_DRAM_RANK_MIX                                         = 0x55fe8eb,
    ATTR_EFF_NUM_RANKS_PER_DIMM                                    = 0x88ba0c5,
    ATTR_EFF_REGISTER_TYPE                                         = 0x38313b7,
    ATTR_EFF_DRAM_MFG_ID                                           = 0x4bbfd53,
    ATTR_EFF_RCD_MFG_ID                                            = 0x43a0d7e,
    ATTR_EFF_REGISTER_REV                                          = 0x6cb15ee,
    ATTR_DO_MSS_WR_VREF                                            = 0x9bb2997,
    ATTR_SKIP_HW_VREF_CAL                                          = 0xd8add56,
    ATTR_SKIP_RD_VREF_VREFSENSE_OVERRIDE                           = 0x4068890,
    ATTR_DO_MSS_VREF_DAC                                           = 0x052d264,
    ATTR_DO_MSS_TRAINING_BAD_BITS                                  = 0xc45c859,
    ATTR_MSS_RUN_DCD_CALIBRATION                                   = 0x775e116,
    ATTR_FREQ_PB_MHZ                                               = 0x69e5db1,
    ATTR_FREQ_MCA_MHZ                                              = 0xdb3ed5f,
    ATTR_FREQ_O_MHZ                                                = 0x59a4fc1,
    ATTR_FREQ_A_MHZ                                                = 0x01204e8,
    ATTR_FREQ_X_MHZ                                                = 0x38a35a1,
    ATTR_PM_SAFE_FREQUENCY_MHZ                                     = 0xd804c85,
    ATTR_PM_SAFE_VOLTAGE_MV                                        = 0xeb57649,
    ATTR_FREQ_PCIE_MHZ                                             = 0x82f58e6,
    ATTR_DD1_SLOW_PCI_REF_CLOCK                                    = 0xf4ac0bc,
    ATTR_PROC_FABRIC_ASYNC_SAFE_MODE                               = 0xd952274,
    ATTR_PROC_FABRIC_A_BUS_WIDTH                                   = 0x64056db,
    ATTR_PROC_FABRIC_X_BUS_WIDTH                                   = 0x23eb4b4,
    ATTR_PROC_FABRIC_CORE_FLOOR_RATIO                              = 0x7f5639e,
    ATTR_PROC_FABRIC_CORE_CEILING_RATIO                            = 0xca11470,
    ATTR_PROC_FABRIC_PUMP_MODE                                     = 0xc1c2678,
    ATTR_PROC_FABRIC_CCSM_MODE                                     = 0xcd4c887,
    ATTR_OPTICS_CONFIG_MODE                                        = 0xc0f898a,
    ATTR_PROC_FABRIC_SMP_OPTICS_MODE                               = 0x367b1e8,
    ATTR_PROC_FABRIC_OPTICS_CONFIG_MODE                            = 0x7d5f905,
    ATTR_PROC_FABRIC_CAPI_MODE                                     = 0x13fc0a6,
    ATTR_PROC_FABRIC_SYSTEM_ID                                     = 0xf7c35e8,
    ATTR_PROC_EFF_FABRIC_GROUP_ID                                  = 0xbb5d3e9,
    ATTR_PROC_EFF_FABRIC_CHIP_ID                                   = 0xb91f5de,
    ATTR_PROC_FABRIC_SYSTEM_MASTER_CHIP                            = 0xe831572,
    ATTR_PROC_FABRIC_GROUP_MASTER_CHIP                             = 0xa2c9bd2,
    ATTR_PROC_FABRIC_X_ATTACHED_CHIP_CNFG                          = 0x0d40743,
    ATTR_PROC_FABRIC_A_ATTACHED_CHIP_CNFG                          = 0x9db3e24,
    ATTR_PROC_FABRIC_X_ATTACHED_CHIP_ID                            = 0xa96afb3,
    ATTR_PROC_FABRIC_X_ATTACHED_LINK_ID                            = 0x56be955,
    ATTR_PROC_FABRIC_A_ATTACHED_CHIP_ID                            = 0x5f943d0,
    ATTR_PROC_FABRIC_A_ATTACHED_LINK_ID                            = 0x36e454b,
    ATTR_PROC_FABRIC_X_AGGREGATE                                   = 0xeada36c,
    ATTR_PROC_FABRIC_X_ADDR_DIS                                    = 0x1f2c617,
    ATTR_PROC_FABRIC_X_LINK_DELAY                                  = 0xd60cf0a,
    ATTR_PROC_FABRIC_A_AGGREGATE                                   = 0x23ad20f,
    ATTR_PROC_FABRIC_A_ADDR_DIS                                    = 0xa9a7c39,
    ATTR_PROC_FABRIC_A_LINK_DELAY                                  = 0xc0bb633,
    ATTR_PROC_EPS_GB_PERCENTAGE                                    = 0x29081fa,
    ATTR_PROC_EPS_TABLE_TYPE                                       = 0x23c87d8,
    ATTR_PROC_EPS_READ_CYCLES_T0                                   = 0x21049e0,
    ATTR_PROC_EPS_READ_CYCLES_T1                                   = 0x4bf64b9,
    ATTR_PROC_EPS_READ_CYCLES_T2                                   = 0xa78e807,
    ATTR_PROC_EPS_WRITE_CYCLES_T1                                  = 0x948370e,
    ATTR_PROC_EPS_WRITE_CYCLES_T2                                  = 0xf104f67,
    ATTR_DMI_REFCLOCK_SWIZZLE                                      = 0xbff8521,
    ATTR_PROC_XSCOM_BAR_BASE_ADDR_OFFSET                           = 0x3fe9f90,
    ATTR_PROC_LPC_BAR_BASE_ADDR_OFFSET                             = 0x57ab3c7,
    ATTR_MEM_MIRROR_PLACEMENT_POLICY                               = 0x1c0d755,
    ATTR_PROC_MEM_BASES                                            = 0x3849826,
    ATTR_PROC_MEM_SIZES                                            = 0x61d7f4f,
    ATTR_PROC_MIRROR_BASES                                         = 0xb9ee432,
    ATTR_PROC_MIRROR_SIZES                                         = 0x18128bb,
    ATTR_MSS_INTERLEAVE_ENABLE                                     = 0x54fd267,
    ATTR_MSS_INTERLEAVE_GRANULARITY                                = 0x41ed7c4,
    ATTR_MSS_MEM_MC_IN_GROUP                                       = 0xc666c00,
    ATTR_MSS_MCS_GROUP_32                                          = 0xb1f7c2d,
    ATTR_MSS_MEM_IPL_COMPLETE                                      = 0x647f6d0,
    ATTR_MRW_HW_MIRRORING_ENABLE                                   = 0xb7dddfb,
    ATTR_PROC_NHTM_BAR_BASE_ADDR                                   = 0xb65b981,
    ATTR_PROC_NHTM_BAR_SIZE                                        = 0xc4941e4,
    ATTR_PROC_CHTM_BAR_BASE_ADDR                                   = 0xf42d558,
    ATTR_PROC_CHTM_BAR_SIZES                                       = 0x4479a4c,
    ATTR_PROC_OCC_SANDBOX_BASE_ADDR                                = 0x14625e7,
    ATTR_PROC_OCC_SANDBOX_SIZE                                     = 0x9f3cbef,
    ATTR_PROC_MEM_BASES_ACK                                        = 0x89b8414,
    ATTR_PROC_MEM_SIZES_ACK                                        = 0xc3e64a1,
    ATTR_PROC_MIRROR_BASES_ACK                                     = 0xb28a4f5,
    ATTR_PROC_MIRROR_SIZES_ACK                                     = 0x4d787f5,
    ATTR_HTM_QUEUES                                                = 0x0ea4707,
    ATTR_DMI_INBAND_BAR_ENABLE                                     = 0xc856eaf,
    ATTR_DMI_INBAND_BAR_BASE_ADDR_OFFSET                           = 0x8921b4b,
    ATTR_EI_BUS_TX_MSBSWAP                                         = 0xa046f56,
    ATTR_NHTM_TRACE_TYPE                                           = 0x85fcda1,
    ATTR_CHTM_TRACE_TYPE                                           = 0xa1e433c,
    ATTR_HTMSC_TTYPEFILT_PAT                                       = 0xcde0848,
    ATTR_HTMSC_TSIZEFILT_PAT                                       = 0xefc5783,
    ATTR_HTMSC_TTYPEFILT_MASK                                      = 0xf91795a,
    ATTR_HTMSC_TSIZEFILT_MASK                                      = 0x172d7c5,
    ATTR_HTMSC_TTYPEFILT_INVERT                                    = 0x8b5ae6e,
    ATTR_HTMSC_CRESPFILT_INVERT                                    = 0xce3e5e5,
    ATTR_HTMSC_FILT_PAT                                            = 0xed6586e,
    ATTR_HTMSC_FILT_CRESP_PAT                                      = 0xea5d545,
    ATTR_HTMSC_FILT_MASK                                           = 0x19b3931,
    ATTR_HTMSC_FILT_CRESP_MASK                                     = 0xe356be6,
    ATTR_NHTM_HTMSC_MODE_CONTENT_SEL                               = 0x117c575,
    ATTR_NHTM_HTMSC_MODE_CAPTURE_GENERATED_WRITES                  = 0xd9db997,
    ATTR_NHTM_HTMSC_MODE_CAPTURE_ENABLE_FILTER_ALL                 = 0x3e20511,
    ATTR_NHTM_HTMSC_MODE_CAPTURE_PRECISE_CRESP_MODE                = 0xa844a05,
    ATTR_NHTM_HTMSC_MODE_CAPTURE_LIMIT_MEM_ALLOCATION              = 0xfb2fe64,
    ATTR_NHTM_HTMSC_MODE_CAPTURE_PMISC_ONLY_CMD                    = 0x653f119,
    ATTR_NHTM_HTMSC_MODE_SYNC_STAMP_FORCE                          = 0x3ad5ca0,
    ATTR_NHTM_HTMSC_MODE_WRITETOIO                                 = 0xdb283e0,
    ATTR_CHTM_HTMSC_MODE_CONTENT_SEL                               = 0x092d705,
    ATTR_CHTM_HTMSC_MODE_CAPTURE                                   = 0x0e2fb21,
    ATTR_CHTM_HTMSC_MODE_CORE_INSTR_STALL                          = 0x6e2352a,
    ATTR_HTMSC_MODE_WRAP                                           = 0x5390d2b,
    ATTR_HTMSC_MODE_DIS_TSTAMP                                     = 0x90059b3,
    ATTR_HTMSC_MODE_SINGLE_TSTAMP                                  = 0x3d84c2e,
    ATTR_HTMSC_MODE_MARKERS_ONLY                                   = 0x5fa7892,
    ATTR_HTMSC_MODE_DIS_FORCE_GROUP_SCOPE                          = 0xe3950d2,
    ATTR_HTMSC_MODE_VGTARGET                                       = 0x46a1caf,
    ATTR_HTMSC_MEM_SCOPE                                           = 0xfdbc8b2,
    ATTR_HTMSC_MEM_PRIORITY                                        = 0x51dd309,
    ATTR_NHTM_CTRL_TRIG                                            = 0x65c995d,
    ATTR_NHTM_CTRL_MARK                                            = 0xb9cc761,
    ATTR_CHTM_CTRL_TRIG                                            = 0x16a3e9f,
    ATTR_CHTM_CTRL_MARK                                            = 0x970ff46,
    ATTR_HTMSC_CTRL_DBG0_STOP                                      = 0x5464e01,
    ATTR_HTMSC_CTRL_DBG1_STOP                                      = 0x5add085,
    ATTR_HTMSC_CTRL_RUN_STOP                                       = 0xc352d05,
    ATTR_HTMSC_CTRL_OTHER_DBG0_STOP                                = 0xecc42ef,
    ATTR_HTMSC_CTRL_XSTOP_STOP                                     = 0x472b4fc,
    ATTR_HTMSC_CTRL_CHIP0_STOP                                     = 0xdf6bde0,
    ATTR_HTMSC_CTRL_CHIP1_STOP                                     = 0x4a70af5,
    ATTR_HTMSC_IMA_PDBAR_SPLIT_CORE_MODE                           = 0x65e924e,
    ATTR_HTMSC_IMA_PDBAR_SCOPE                                     = 0xe2556ce,
    ATTR_HTMSC_IMA_PDBAR_ADDR                                      = 0x833d2c7,
    ATTR_IO_DMI_PROC_DCCAL_FLAGS                                   = 0xfa58f19,
    ATTR_IO_DMI_PROC_DEBUG                                         = 0xa0a75df,
    ATTR_IO_DMI_PROC_TX_MARGIN_RATIO                               = 0x3df4226,
    ATTR_IO_DMI_PROC_TX_FFE_PRECURSOR                              = 0x78fc2b8,
    ATTR_IO_OBUS_DCCAL_FLAGS                                       = 0xaa3902b,
    ATTR_IO_O_DEBUG                                                = 0x9ef1783,
    ATTR_IO_O_MFG_CHK                                              = 0x5c4a180,
    ATTR_IO_O_MFG_MIN_EYE_WIDTH                                    = 0xd9db2d5,
    ATTR_IO_OBUS_TX_MARGIN_RATIO                                   = 0xd54b4ac,
    ATTR_IO_OBUS_TX_FFE_PRECURSOR                                  = 0xd0b5036,
    ATTR_IO_OBUS_TX_FFE_POSTCURSOR                                 = 0x1952ef4,
    ATTR_IO_XBUS_DCCAL_FLAGS                                       = 0x4505c05,
    ATTR_IO_X_DEBUG                                                = 0x4eddd74,
    ATTR_IO_X_MFG_CHK                                              = 0x213ac30,
    ATTR_IO_X_MFG_MIN_EYE_WIDTH                                    = 0xbbf242e,
    ATTR_IO_XBUS_MASTER_MODE                                       = 0xc22cf13,
    ATTR_IO_XBUS_TX_MARGIN_RATIO                                   = 0x9ef94c7,
    ATTR_IO_XBUS_TX_FFE_PRECURSOR                                  = 0x5c4b5de,
    ATTR_PROC_PCIE_IOP_SWAP                                        = 0x85f1c7e,
    ATTR_PROC_PCIE_BAR_ENABLE                                      = 0xc03d18e,
    ATTR_PROC_PCIE_MMIO_BAR0_BASE_ADDR_OFFSET                      = 0x998757c,
    ATTR_PROC_PCIE_MMIO_BAR1_BASE_ADDR_OFFSET                      = 0x637e6da,
    ATTR_PROC_PCIE_REGISTER_BAR_BASE_ADDR_OFFSET                   = 0xb6b4231,
    ATTR_PROC_PCIE_BAR_SIZE                                        = 0x6a37320,
    ATTR_PROC_PCIE_PCS_RX_CDR_GAIN                                 = 0xce4b99b,
    ATTR_PROC_PCIE_PCS_RX_PK_INIT                                  = 0x0110aab,
    ATTR_PROC_PCIE_PCS_RX_INIT_GAIN                                = 0xaf99076,
    ATTR_PROC_PCIE_PCS_RX_SIGDET_LVL                               = 0xa3814e1,
    ATTR_PROC_PCIE_PCS_RX_ROT_CDR_LOOKAHEAD                        = 0x575b03e,
    ATTR_PROC_PCIE_PCS_RX_ROT_CDR_SSC                              = 0x407787b,
    ATTR_PROC_PCIE_PCS_RX_ROT_EXTEL                                = 0x1766b6d,
    ATTR_PROC_PCIE_PCS_RX_ROT_RST_FW                               = 0x21687c0,
    ATTR_PROC_PCIE_PCS_PCLCK_CNTL_PLLA                             = 0x3003319,
    ATTR_PROC_PCIE_PCS_PCLCK_CNTL_PLLB                             = 0x7072e41,
    ATTR_PROC_PCIE_PCS_TX_DCLCK_ROT                                = 0xc55cf38,
    ATTR_PROC_PCIE_PCS_TX_PCIE_RECV_DETECT_CNTL_REG1               = 0x16a9135,
    ATTR_PROC_PCIE_PCS_TX_PCIE_RECV_DETECT_CNTL_REG2               = 0x55f6f2d,
    ATTR_PROC_PCIE_PCS_TX_POWER_SEQ_ENABLE                         = 0xdd9ccb4,
    ATTR_PROC_PCIE_PCS_RX_VGA_CNTL_REG1                            = 0xe6d858e,
    ATTR_PROC_PCIE_PCS_RX_VGA_CNTL_REG2                            = 0x28f1c68,
    ATTR_PROC_PCIE_PCS_RX_DFE_FDDC                                 = 0xb88574f,
    ATTR_PROC_PCIE_PCS_M_CNTL                                      = 0x8f0d7db,
    ATTR_PROC_FSP_BAR_ENABLE                                       = 0x8f1af9c,
    ATTR_PROC_FSP_BAR_BASE_ADDR_OFFSET                             = 0xe3352f1,
    ATTR_PROC_FSP_BAR_SIZE                                         = 0xf8dd85b,
    ATTR_PROC_FSP_MMIO_MASK_SIZE                                   = 0xbcf856d,
    ATTR_PROC_NPU_PHY0_BAR_ENABLE                                  = 0x4f90d56,
    ATTR_PROC_NPU_PHY0_BAR_BASE_ADDR_OFFSET                        = 0xb5b073a,
    ATTR_PROC_NPU_PHY1_BAR_ENABLE                                  = 0x7d06d25,
    ATTR_PROC_NPU_PHY1_BAR_BASE_ADDR_OFFSET                        = 0x6c1b996,
    ATTR_PROC_NPU_MMIO_BAR_BASE_ADDR_OFFSET                        = 0xc008a8d,
    ATTR_PROC_NPU_MMIO_BAR_ENABLE                                  = 0x35c6687,
    ATTR_PROC_PSI_BRIDGE_BAR_ENABLE                                = 0x8883a11,
    ATTR_PROC_PSI_BRIDGE_BAR_BASE_ADDR_OFFSET                      = 0x206be4b,
    ATTR_PROC_NX_RNG_BAR_ENABLE                                    = 0x928d6c3,
    ATTR_PROC_NX_RNG_BAR_BASE_ADDR_OFFSET                          = 0x037feec,
    ATTR_PROC_NX_RNG_FAILED_INT_ENABLE                             = 0x6234fc5,
    ATTR_PROC_NX_RNG_FAILED_INT_ADDR                               = 0xeb5a690,
    ATTR_PROC_INT_CQ_PC_BAR_ENABLE                                 = 0x80d024f,
    ATTR_PROC_INT_CQ_PC_BAR_BASE_ADDR_OFFSET                       = 0xa625af4,
    ATTR_PROC_INT_CQ_PC_BAR_BASE_ADDR_OFFSET_MASK                  = 0x28090cf,
    ATTR_PROC_INT_CQ_VC_BAR_ENABLE                                 = 0x859416a,
    ATTR_PROC_INT_CQ_VC_BAR_BASE_ADDR_OFFSET                       = 0xc821788,
    ATTR_PROC_INT_CQ_VC_BAR_BASE_ADDR_OFFSET_MASK                  = 0x7f84e84,
    ATTR_PROC_INT_CQ_TM1_BAR_ENABLE                                = 0x51cd229,
    ATTR_PROC_INT_CQ_TM1_BAR_BASE_ADDR_OFFSET                      = 0x6560cc9,
    ATTR_PROC_INT_CQ_TM1_BAR_PAGE_SIZE                             = 0xa5f7c09,
    ATTR_PROC_INT_CQ_IC_BAR_ENABLE                                 = 0xf4a1165,
    ATTR_PROC_INT_CQ_IC_BAR_BASE_ADDR_OFFSET                       = 0x32fb31e,
    ATTR_PROC_INT_CQ_IC_BAR_PAGE_SIZE                              = 0x903c07c,
    ATTR_SBE_IMAGE_MINIMUM_VALID_ECS                               = 0xba8abbe,
    ATTR_CLOCK_PLL_MUX                                             = 0xb441dca,
    ATTR_CLOCK_PLL_MUX0                                            = 0x8faffe3,
    ATTR_I2C_BUS_DIV_REF                                           = 0x2a89ed8,
    ATTR_EQ_GARD                                                   = 0xb6c105c,
    ATTR_EC_GARD                                                   = 0x837f7ab,
    ATTR_SBE_RUNTIME_MODE                                          = 0xbeb4dd6,
    ATTR_IS_SP_MODE                                                = 0x738ed86,
    ATTR_SBE_FFDC_ENABLE                                           = 0x1cae277,
    ATTR_SBE_INTERNAL_FFDC_ENABLE                                  = 0x575a0f0,
    ATTR_NEST_PLL_BUCKET                                           = 0x02190b7,
    ATTR_BOOT_FREQ_MULT                                            = 0xeedb5b0,
    ATTR_RISK_LEVEL                                                = 0xb3adef2,
    ATTR_DISABLE_HBBL_VECTORS                                      = 0xb1c3653,
    ATTR_BACKUP_SEEPROM_SELECT                                     = 0xb812834,
    ATTR_BOOT_FLAGS                                                = 0xc774921,
    ATTR_BOOT_FREQ_MHZ                                             = 0x61f8882,
    ATTR_BRANCH_PIBMEM_ADDR                                        = 0x9ebe9f0,
    ATTR_CHIP_REGIONS_TO_ENABLE                                    = 0x208eb9c,
    ATTR_DEVICE_ID                                                 = 0x42549c8,
    ATTR_ECID                                                      = 0x522a158,
    ATTR_I2C_BUS_DIV_NEST                                          = 0xe0c4403,
    ATTR_LEN_OF_SEEPROM_DATA                                       = 0x229196b,
    ATTR_MB_BIT_RATE_DIVISOR_PLL                                   = 0xafa97ce,
    ATTR_MB_BIT_RATE_DIVISOR_REFCLK                                = 0x3d44494,
    ATTR_MC_SYNC_MODE                                              = 0x241918a,
    ATTR_PROC_PB_BNDY_DMIPLL_DATA                                  = 0x5d60af0,
    ATTR_PROC_PB_BNDY_DMIPLL_FOR_DCCAL_DATA                        = 0x9f08be2,
    ATTR_PROC_PERV_BNDY_PLL_DATA                                   = 0x22aa222,
    ATTR_PROC_SBE_MASTER_CHIP                                      = 0x4c42b9b,
    ATTR_SBE_SEEPROM_I2C_DEVICE_ADDRESS                            = 0x5ac150b,
    ATTR_SBE_SEEPROM_I2C_PORT                                      = 0xd1e416f,
    ATTR_START_PIBMEM_ADDR                                         = 0x1592396,
    ATTR_START_SEEPROM_ADDR                                        = 0x72ee257,
    ATTR_WAIT_N0                                                   = 0x0f17b39,
    ATTR_WAIT_N1                                                   = 0x2d07ffa,
    ATTR_WAIT_N2                                                   = 0x8d46776,
    ATTR_WAIT_N3                                                   = 0x3fab398,
    ATTR_SYS_FORCE_ALL_CORES                                       = 0x05a0ca5,
    ATTR_MASTER_CORE                                               = 0xcd97b51,
    ATTR_MASTER_EX                                                 = 0xfe2e509,
    ATTR_SECURITY_ENABLE                                           = 0x92913ca,
    ATTR_PFET_OFF_CONTROLS                                         = 0x29d4df6,
    ATTR_OBUS_RATIO_VALUE                                          = 0x242427b,
    ATTR_PIBMEM_REPAIR0                                            = 0x4bb165d,
    ATTR_PIBMEM_REPAIR1                                            = 0xa7ff329,
    ATTR_PIBMEM_REPAIR2                                            = 0x7090c2b,
    ATTR_SENSEADJ_STEP                                             = 0x8b4b0fb,
    ATTR_CP_FILTER_BYPASS                                          = 0x1ac5893,
    ATTR_SS_FILTER_BYPASS                                          = 0x32c3c25,
    ATTR_IO_FILTER_BYPASS                                          = 0x273690d,
    ATTR_DPLL_BYPASS                                               = 0x54157b3,
    ATTR_NEST_MEM_X_O_PCI_BYPASS                                   = 0x1204a39,
    ATTR_TARGET_HAS_POWER                                          = 0x2e506e2,
    ATTR_TARGET_HAS_CLOCK                                          = 0xf83aee8,
    ATTR_TARGET_IS_SCOMMABLE                                       = 0x7014d18,
    ATTR_SBE_SYS_CONFIG                                            = 0xf64aeb7,
    ATTR_CP_REFCLOCK_RCVR_TERM                                     = 0x5cd9484,
    ATTR_IO_REFCLOCK_RCVR_TERM                                     = 0x1c900fa,
    ATTR_SECTOR_BUFFER_STRENGTH                                    = 0x9761e43,
    ATTR_PULSE_MODE_ENABLE                                         = 0xfe66f82,
    ATTR_PULSE_MODE_VALUE                                          = 0x55b725e,
    ATTR_NDL_MESHCTRL_SETUP                                        = 0x8ad2e2a,
    ATTR_START_CBS_FIFO_RESET_SKIP                                 = 0x9aa43bc,
    ATTR_SYSTEM_CORECACHE_SKEWADJ_DISABLE                          = 0x655aa2b,
    ATTR_SYSTEM_CORECACHE_DCADJ_DISABLE                            = 0xe8e795c,
    ATTR_PROC_DPLL_DIVIDER                                         = 0xde419d0,
    ATTR_STOPGPE_BOOT_COPIER_IVPR_OFFSET                           = 0xb8bcc7a,
    ATTR_PSTATEGPE_BOOT_COPIER_IVPR_OFFSET                         = 0x303045d,
    ATTR_PM_SPWUP_IGNORE_XSTOP_FLAG                                = 0x4c1219d,
    ATTR_OCC_LFIR                                                  = 0x1cae7cd,
    ATTR_PBA_LFIR                                                  = 0x28f2315,
    ATTR_PM_FIRINIT_DONE_ONCE_FLAG                                 = 0x4851132,
    ATTR_QUAD_PPM_ERRMASK                                          = 0x639b7ee,
    ATTR_CORE_PPM_ERRMASK                                          = 0x478edab,
    ATTR_CME_LOCAL_FIRMASK                                         = 0xb877675,
    ATTR_L2_HASCLOCKS                                              = 0xea7105b,
    ATTR_L3_HASCLOCKS                                              = 0xe977d9f,
    ATTR_C0_EXEC_HASCLOCKS                                         = 0x46cca69,
    ATTR_C1_EXEC_HASCLOCKS                                         = 0xcadc29f,
    ATTR_C0_PC_HASCLOCKS                                           = 0xb639c30,
    ATTR_C1_PC_HASCLOCKS                                           = 0xae1e6c4,
    ATTR_L2_HASPOWER                                               = 0xdece9f6,
    ATTR_L3_HASPOWER                                               = 0x5437d12,
    ATTR_C0_HASPOWER                                               = 0x2010712,
    ATTR_C1_HASPOWER                                               = 0x5a8ea4b,
    ATTR_PM_SPIPSS_FRAME_SIZE                                      = 0xb69562d,
    ATTR_PM_SPIPSS_IN_DELAY                                        = 0xae84e31,
    ATTR_PM_SPIPSS_CLOCK_POLARITY                                  = 0x0241bf2,
    ATTR_PM_SPIPSS_CLOCK_PHASE                                     = 0x82b807e,
    ATTR_PM_SPIPSS_CLOCK_DIVIDER                                   = 0x16824ac,
    ATTR_PM_SPIPSS_INTER_FRAME_DELAY_SETTING                       = 0x3e336e0,
    ATTR_PSTATES_ENABLED                                           = 0xa3a4736,
    ATTR_RESCLK_ENABLED                                            = 0xaa9080d,
    ATTR_VDM_ENABLED                                               = 0xd2ee0c7,
    ATTR_IVRM_ENABLED                                              = 0x49b21cc,
    ATTR_WOF_ENABLED                                               = 0xca00099,
    ATTR_CORE_INSIDE_SPECIAL_WAKEUP                                = 0xae5b915,
    ATTR_EX_INSIDE_SPECIAL_WAKEUP                                  = 0x2bf8757,
    ATTR_EQ_INSIDE_SPECIAL_WAKEUP                                  = 0xcb7b544,
    ATTR_EXTERNAL_VRM_STEPSIZE                                     = 0x1a091ba,
    ATTR_EXTERNAL_VRM_STEPDELAY                                    = 0x19ff8c3,
    ATTR_EXTERNAL_VRM_TRANSITION_START_NS                          = 0xc8ab5a1,
    ATTR_EXTERNAL_VRM_TRANSITION_RATE_INC_UV_PER_US                = 0x9dfa8e3,
    ATTR_EXTERNAL_VRM_TRANSITION_RATE_DEC_UV_PER_US                = 0x055981e,
    ATTR_EXTERNAL_VRM_TRANSITION_STABILIZATION_TIME_NS             = 0x920e9b8,
    ATTR_AVSBUS_FREQUENCY                                          = 0xcc07b62,
    ATTR_VDD_AVSBUS_BUSNUM                                         = 0x520c023,
    ATTR_VDN_AVSBUS_BUSNUM                                         = 0xa6d99fc,
    ATTR_VCS_AVSBUS_BUSNUM                                         = 0xef21476,
    ATTR_VDD_AVSBUS_RAIL                                           = 0xc86629f,
    ATTR_VDN_AVSBUS_RAIL                                           = 0x3f58687,
    ATTR_VCS_AVSBUS_RAIL                                           = 0xceb4953,
    ATTR_VCS_I2C_BUSNUM                                            = 0xa813c97,
    ATTR_VCS_I2C_RAIL                                              = 0xe20b119,
    ATTR_VDD_BOOT_VOLTAGE                                          = 0xbecf4b6,
    ATTR_VDN_BOOT_VOLTAGE                                          = 0xa2fea8f,
    ATTR_VCS_BOOT_VOLTAGE                                          = 0xa68e8ba,
    ATTR_SPIPSS_FREQUENCY                                          = 0x9493ec3,
    ATTR_PM_APSS_CHIP_SELECT                                       = 0x191dc94,
    ATTR_PROC_R_LOADLINE_VDD_UOHM                                  = 0x14713d4,
    ATTR_PROC_R_DISTLOSS_VDD_UOHM                                  = 0x656ab25,
    ATTR_PROC_VRM_VOFFSET_VDD_UV                                   = 0x603a62c,
    ATTR_PROC_R_LOADLINE_VDN_UOHM                                  = 0x4958571,
    ATTR_PROC_R_DISTLOSS_VDN_UOHM                                  = 0x4698c59,
    ATTR_PROC_VRM_VOFFSET_VDN_UV                                   = 0x664e3f1,
    ATTR_PROC_R_LOADLINE_VCS_UOHM                                  = 0x99e5b32,
    ATTR_PROC_R_DISTLOSS_VCS_UOHM                                  = 0x30ca0ae,
    ATTR_PROC_VRM_VOFFSET_VCS_UV                                   = 0x75abdf6,
    ATTR_FREQ_BIAS_ULTRATURBO                                      = 0x0271124,
    ATTR_FREQ_BIAS_TURBO                                           = 0xd6ece64,
    ATTR_FREQ_BIAS_NOMINAL                                         = 0x1013c3d,
    ATTR_FREQ_BIAS_POWERSAVE                                       = 0xf99ae48,
    ATTR_VOLTAGE_EXT_VDD_BIAS_ULTRATURBO                           = 0x70b05ab,
    ATTR_VOLTAGE_EXT_VDD_BIAS_TURBO                                = 0xd378c29,
    ATTR_VOLTAGE_EXT_VDD_BIAS_NOMINAL                              = 0x5cae63f,
    ATTR_VOLTAGE_EXT_VDD_BIAS_POWERSAVE                            = 0x5fd22bd,
    ATTR_VOLTAGE_EXT_VCS_BIAS                                      = 0x0242ba7,
    ATTR_VOLTAGE_EXT_VDN_BIAS                                      = 0x9fc8b45,
    ATTR_VOLTAGE_INT_VDD_BIAS_ULTRATURBO                           = 0x256bf9a,
    ATTR_VOLTAGE_INT_VDD_BIAS_TURBO                                = 0x5126c79,
    ATTR_VOLTAGE_INT_VDD_BIAS_NOMINAL                              = 0x63f5997,
    ATTR_VOLTAGE_INT_VDD_BIAS_POWERSAVE                            = 0x8ae9503,
    ATTR_STOP4_DISABLE                                             = 0xfc7ecc4,
    ATTR_STOP8_DISABLE                                             = 0x431a931,
    ATTR_STOP11_DISABLE                                            = 0xa9d1ad8,
    ATTR_SYSTEM_CORE_PERIODIC_QUIESCE_DISABLE                      = 0xcbb524c,
    ATTR_SYSTEM_WOF_DISABLE                                        = 0xd7e2c04,
    ATTR_SYSTEM_IVRM_DISABLE                                       = 0x2996256,
    ATTR_WOF_ENABLE_FRATIO                                         = 0xa7a6601,
    ATTR_WOF_ENABLE_VRATIO                                         = 0x58a7917,
    ATTR_WOF_VRATIO_SELECT                                         = 0x93b8597,
    ATTR_PBAX_GROUPID                                              = 0x955e6b7,
    ATTR_PBAX_CHIPID                                               = 0x7f199a1,
    ATTR_PBAX_BRDCST_ID_VECTOR                                     = 0x15c7694,
    ATTR_POUNDV_BUCKET_NUM_OVERRIDE                                = 0x59b35d5,
    ATTR_POUNDV_BUCKET_NUM                                         = 0x8d7f254,
    ATTR_DUMP_STOP_INFO_SUPPRESS_ERROR_TRACE                       = 0xc96a9e2,
    ATTR_DUMP_STOP_INFO_ENABLE_ERRORLOG                            = 0x4221eb9,
    ATTR_VDM_DROOP_SMALL_OVERRIDE                                  = 0xabe3829,
    ATTR_VDM_DROOP_LARGE_OVERRIDE                                  = 0xde3c776,
    ATTR_VDM_DROOP_EXTREME_OVERRIDE                                = 0xf8d7cd7,
    ATTR_VDM_OVERVOLT_OVERRIDE                                     = 0x71de8bc,
    ATTR_VDM_SMALL_FREQ_DROP_N_S_OVERRIDE                          = 0x2cc9be4,
    ATTR_VDM_LARGE_FREQ_DROP_N_L_OVERRIDE                          = 0x73feb55,
    ATTR_VDM_FREQ_RETURN_L_S_OVERRIDE                              = 0x69c7dbd,
    ATTR_VDM_FREQ_RETURN_S_N_OVERRIDE                              = 0x37aeba2,
    ATTR_VDM_EXTREME_THOTTLE_ENABLE                                = 0x10b1123,
    ATTR_VDM_FMAX_OVERRIDE_KHZ                                     = 0x43d0fa1,
    ATTR_VDM_FMIN_OVERRIDE_KHZ                                     = 0x648c404,
    ATTR_VDM_VID_COMPARE_OVERRIDE_MV                               = 0x5ce2ab7,
    ATTR_VDM_VID_COMPARE_BIAS_0P5PCT                               = 0xf4be9f1,
    ATTR_DPLL_VDM_RESPONSE                                         = 0x5ac3ecd,
    ATTR_IVRM_DEADZONE_MV                                          = 0x4053318,
    ATTR_IVRM_STRENGTH_LOOKUP                                      = 0x55cd48a,
    ATTR_IVRM_VIN_MULTIPLIER                                       = 0x6aba034,
    ATTR_IVRM_VIN_MAX_MV                                           = 0x05d0481,
    ATTR_IVRM_STEP_DELAY_NS                                        = 0x1fe5640,
    ATTR_IVRM_STABILIZATION_DELAY_NS                               = 0x38c4618,
    ATTR_TDP_RDP_CURRENT_FACTOR                                    = 0xfb6b288,
    ATTR_SYSTEM_RESCLK_DISABLE                                     = 0x1bc94b8,
    ATTR_SYSTEM_RESCLK_STEP_DELAY                                  = 0x8bdeb02,
    ATTR_SYSTEM_RESCLK_FREQ_REGIONS                                = 0x452a420,
    ATTR_SYSTEM_RESCLK_FREQ_REGION_INDEX                           = 0xcdf52b9,
    ATTR_SYSTEM_RESCLK_VALUE                                       = 0x168939c,
    ATTR_SYSTEM_RESCLK_L3_VALUE                                    = 0x41ffdbd,
    ATTR_SYSTEM_RESCLK_L3_VOLTAGE_THRESHOLD_MV                     = 0xff4e39a,
    ATTR_SYSTEM_RING_DBG_MODE                                      = 0x4028d5e,
    ATTR_PERF_24x7_INVOCATION_TIME_MS                              = 0xe226c94,
    ATTR_CME_INSTRUCTION_TRACE_ENABLE                              = 0xbe90420,
    ATTR_CME_CHTM_TRACE_ENABLE                                     = 0x2bfa1f9,
    ATTR_CME_CHTM_TRACE_MEMORY_CONFIG                              = 0xa030cff,
    ATTR_PGPE_HCODE_FUNCTION_ENABLE                                = 0xbb90f0a,
    ATTR_POUND_W_STATIC_DATA_ENABLE                                = 0xa24c56a,
    ATTR_AUX_FUNC_INVOCATION_TIME_MS                               = 0x467a7c6,
    ATTR_SYS_VFRT_STATIC_DATA_ENABLE                               = 0xa41ce38,
    ATTR_NEST_LEAKAGE_PERCENT                                      = 0x787d424,
    ATTR_SYSTEM_PSTATES_MODE                                       = 0x8a7db83,
    ATTR_CORE_THROTTLE_ASSERT_COUNT                                = 0x211648c,
    ATTR_CORE_THROTTLE_DEASSERT_COUNT                              = 0x6167a77,
    ATTR_MINI_EC                                                   = 0xb630402,
    ATTR_FAPI_POS                                                  = 0x80817dc,
    ATTR_SCRATCH_UINT8_1                                           = 0xc7bc372,
    ATTR_SCRATCH_UINT8_2                                           = 0xe93419a,
    ATTR_SCRATCH_UINT16_1                                          = 0x656ee0f,
    ATTR_SCRATCH_UINT16_2                                          = 0xcb3bded,
    ATTR_SCRATCH_UINT32_1                                          = 0x782c053,
    ATTR_SCRATCH_UINT32_2                                          = 0x002156b,
    ATTR_SCRATCH_UINT64_1                                          = 0xeee9926,
    ATTR_SCRATCH_UINT64_2                                          = 0x18a17a2,
    ATTR_SCRATCH_UINT8_ARRAY_1                                     = 0xae204e8,
    ATTR_SCRATCH_UINT8_ARRAY_2                                     = 0xdaba3f6,
    ATTR_SCRATCH_UINT16_ARRAY_1                                    = 0xe9713da,
    ATTR_SCRATCH_UINT16_ARRAY_2                                    = 0xc0571d2,
    ATTR_SCRATCH_UINT32_ARRAY_1                                    = 0xe572010,
    ATTR_SCRATCH_UINT32_ARRAY_2                                    = 0xf014872,
    ATTR_SCRATCH_UINT64_ARRAY_1                                    = 0x4403d2c,
    ATTR_SCRATCH_UINT64_ARRAY_2                                    = 0x24d2ff8,
    ATTR_SCRATCH_INT8_1                                            = 0xdf566d7,
    ATTR_SCRATCH_INT8_2                                            = 0x5d3127f,
    ATTR_SCRATCH_INT16_1                                           = 0xe9d2ef4,
    ATTR_SCRATCH_INT16_2                                           = 0xd1894f0,
    ATTR_SCRATCH_INT32_1                                           = 0x738e066,
    ATTR_SCRATCH_INT32_2                                           = 0x14868e6,
    ATTR_SCRATCH_INT64_1                                           = 0xad61d85,
    ATTR_SCRATCH_INT64_2                                           = 0x10e4b80,
    ATTR_SCRATCH_INT8_ARRAY_1                                      = 0x03f242e,
    ATTR_SCRATCH_INT8_ARRAY_2                                      = 0x4082afe,
    ATTR_SCRATCH_INT16_ARRAY_1                                     = 0x04c90e8,
    ATTR_SCRATCH_INT16_ARRAY_2                                     = 0x04dc667,
    ATTR_SCRATCH_INT32_ARRAY_1                                     = 0xf5c9611,
    ATTR_SCRATCH_INT32_ARRAY_2                                     = 0x408451a,
    ATTR_SCRATCH_INT64_ARRAY_1                                     = 0x66c62f7,
    ATTR_SCRATCH_INT64_ARRAY_2                                     = 0x0e62699,
    ATTR_IS_SIMULATION                                             = 0x4367508,
    ATTR_EXECUTION_PLATFORM                                        = 0x6134e50,
    ATTR_MNFG_FLAGS                                                = 0xb7d5f9c,
    ATTR_RECONFIGURE_LOOP                                          = 0x1b589a0,
    ATTR_CEN_DMI_REFCLOCK_RCVR_TERM                                = 0xfe9c5fd,
    ATTR_CEN_DDR_REFCLOCK_RCVR_TERM                                = 0xf55ca02,
    ATTR_CEN_DQ_TO_DIMM_CONN_DQ                                    = 0xcd7817c,
    ATTR_CEN_MBA_PORT                                              = 0xacbf06c,
    ATTR_CEN_MBA_DIMM                                              = 0x9553606,
    ATTR_CEN_BAD_DQ_BITMAP                                         = 0x216289b,
    ATTR_CEN_VPD_DIMM_SPARE                                        = 0x18142b3,
    ATTR_CEN_MBVPD_VERSION                                         = 0x26d1fab,
    ATTR_CEN_SPD_DRAM_DEVICE_TYPE                                  = 0xa8fffa4,
    ATTR_CEN_SPD_MODULE_TYPE                                       = 0xe591acd,
    ATTR_CEN_SPD_CUSTOM                                            = 0x7acc3c5,
    ATTR_CEN_SPD_SDRAM_DENSITY                                     = 0xe5b71e7,
    ATTR_CEN_SPD_SDRAM_BANKS                                       = 0xc85ecac,
    ATTR_CEN_SPD_SDRAM_ROWS                                        = 0x8d19976,
    ATTR_CEN_SPD_SDRAM_COLUMNS                                     = 0xaac68e8,
    ATTR_CEN_SPD_MODULE_NOMINAL_VOLTAGE                            = 0xf88a542,
    ATTR_CEN_SPD_NUM_RANKS                                         = 0x345a5a9,
    ATTR_CEN_SPD_DRAM_WIDTH                                        = 0x9e0e3fb,
    ATTR_CEN_SPD_MODULE_MEMORY_BUS_WIDTH                           = 0x6b8f21b,
    ATTR_CEN_SPD_TCKMIN                                            = 0x40b4fb8,
    ATTR_CEN_SPD_CAS_LATENCIES_SUPPORTED                           = 0x545bab9,
    ATTR_CEN_SPD_TAAMIN                                            = 0x6154008,
    ATTR_CEN_SPD_TRCDMIN                                           = 0x8918edd,
    ATTR_CEN_SPD_TRPMIN                                            = 0xde661b3,
    ATTR_CEN_SPD_TRASMIN                                           = 0xf80eeef,
    ATTR_CEN_SPD_TRCMIN                                            = 0xe36cd64,
    ATTR_CEN_SPD_TFAWMIN                                           = 0x0f2eeae,
    ATTR_CEN_SPD_SDRAM_OPTIONAL_FEATURES                           = 0x7f09287,
    ATTR_CEN_SPD_SDRAM_THERMAL_AND_REFRESH_OPTIONS                 = 0x397bf41,
    ATTR_CEN_SPD_MODULE_THERMAL_SENSOR                             = 0x38a46eb,
    ATTR_CEN_SPD_SDRAM_DEVICE_TYPE                                 = 0xc135f64,
    ATTR_CEN_SPD_SDRAM_DEVICE_TYPE_SIGNAL_LOADING                  = 0x134cb00,
    ATTR_CEN_SPD_SDRAM_DIE_COUNT                                   = 0x71d9ecd,
    ATTR_CEN_SPD_FINE_OFFSET_TCKMIN                                = 0xdfdcdb8,
    ATTR_CEN_SPD_FINE_OFFSET_TAAMIN                                = 0xde4db5d,
    ATTR_CEN_SPD_FINE_OFFSET_TRCDMIN                               = 0xa9786b6,
    ATTR_CEN_SPD_FINE_OFFSET_TRPMIN                                = 0x5df69d0,
    ATTR_CEN_SPD_FINE_OFFSET_TRCMIN                                = 0x710fe72,
    ATTR_CEN_SPD_BAD_DQ_DATA                                       = 0xe05b53a,
    ATTR_CEN_VPD_DIMM_RCD_OUTPUT_TIMING                            = 0xce55c8d,
    ATTR_CEN_SPD_FTB_DIVIDEND                                      = 0x0e06d84,
    ATTR_CEN_SPD_FTB_DIVISOR                                       = 0x67a0fa7,
    ATTR_CEN_SPD_MTB_DIVIDEND                                      = 0x2f0ef6b,
    ATTR_CEN_SPD_MTB_DIVISOR                                       = 0xfb11c56,
    ATTR_CEN_SPD_TWRMIN                                            = 0x4de5e69,
    ATTR_CEN_SPD_TRRDMIN                                           = 0x89947bc,
    ATTR_CEN_SPD_TRFCMIN                                           = 0x3933ade,
    ATTR_CEN_SPD_TWTRMIN                                           = 0xd55dd72,
    ATTR_CEN_SPD_TRTPMIN                                           = 0xd931ae0,
    ATTR_CEN_SPD_TIMEBASE_MTB_DDR4                                 = 0xcecb997,
    ATTR_CEN_SPD_TIMEBASE_FTB_DDR4                                 = 0x1c61d7c,
    ATTR_CEN_SPD_TCKMAX_DDR4                                       = 0x8143520,
    ATTR_CEN_SPD_TRFC1MIN_DDR4                                     = 0xd407fc6,
    ATTR_CEN_SPD_TRFC2MIN_DDR4                                     = 0x42e428e,
    ATTR_CEN_SPD_TRFC4MIN_DDR4                                     = 0xd5d66e1,
    ATTR_CEN_SPD_TRRDSMIN_DDR4                                     = 0xd61ff24,
    ATTR_CEN_SPD_TRRDLMIN_DDR4                                     = 0xafbcc5a,
    ATTR_CEN_SPD_TCCDLMIN_DDR4                                     = 0x67c6c0e,
    ATTR_CEN_VPD_VERSION                                           = 0x8d5946f,
    ATTR_CEN_SPD_ADDR_MAP_REG_TO_DRAM                              = 0xfa89609,
    ATTR_CEN_VPD_DRAM_ADDRESS_MIRRORING                            = 0xaca3a8b,
    ATTR_CEN_VPD_ODT_RD                                            = 0xaaeb67f,
    ATTR_CEN_VPD_ODT_WR                                            = 0xca2b2f1,
    ATTR_CEN_VPD_DRAM_RON                                          = 0x2de5a47,
    ATTR_CEN_VPD_DRAM_RTT_NOM                                      = 0xc3b2e55,
    ATTR_CEN_VPD_DRAM_RTT_WR                                       = 0x8e6c8d4,
    ATTR_CEN_VPD_DRAM_RTT_PARK                                     = 0xe041c2f,
    ATTR_CEN_VPD_DRAM_WR_VREF                                      = 0xe495898,
    ATTR_CEN_VPD_DRAM_WRDDR4_VREF                                  = 0xf35621a,
    ATTR_CEN_VPD_DRV_IMP_DQ_DQS                                    = 0x0254da0,
    ATTR_CEN_VPD_DRV_IMP_ADDR                                      = 0xc020ff0,
    ATTR_CEN_VPD_DRV_IMP_CNTL                                      = 0x7a7dca7,
    ATTR_CEN_VPD_DRV_IMP_CLK                                       = 0xd3cde02,
    ATTR_CEN_VPD_DRV_IMP_SPCKE                                     = 0x4551005,
    ATTR_CEN_VPD_RCV_IMP_DQ_DQS                                    = 0x4eb44d8,
    ATTR_CEN_VPD_SLEW_RATE_DQ_DQS                                  = 0xa386017,
    ATTR_CEN_VPD_SLEW_RATE_ADDR                                    = 0xac82c43,
    ATTR_CEN_VPD_SLEW_RATE_CLK                                     = 0x14249fd,
    ATTR_CEN_VPD_SLEW_RATE_SPCKE                                   = 0x1cef95c,
    ATTR_CEN_VPD_SLEW_RATE_CNTL                                    = 0x2873294,
    ATTR_CEN_VPD_RD_VREF                                           = 0xc4e7cd3,
    ATTR_CEN_VPD_PHASE_ROT_M0_CLK_P0                               = 0x1012494,
    ATTR_CEN_VPD_PHASE_ROT_M0_CLK_P1                               = 0x0e71a20,
    ATTR_CEN_VPD_PHASE_ROT_M1_CLK_P0                               = 0xbd32990,
    ATTR_CEN_VPD_PHASE_ROT_M1_CLK_P1                               = 0x34aa01b,
    ATTR_CEN_VPD_PHASE_ROT_M_CMD_A0                                = 0xe811930,
    ATTR_CEN_VPD_PHASE_ROT_M_CMD_A1                                = 0x30368d4,
    ATTR_CEN_VPD_PHASE_ROT_M_CMD_A2                                = 0x5ab4dae,
    ATTR_CEN_VPD_PHASE_ROT_M_CMD_A3                                = 0x6d95d35,
    ATTR_CEN_VPD_PHASE_ROT_M_CMD_A4                                = 0x1f73113,
    ATTR_CEN_VPD_PHASE_ROT_M_CMD_A5                                = 0xc273899,
    ATTR_CEN_VPD_PHASE_ROT_M_CMD_A6                                = 0x9174f51,
    ATTR_CEN_VPD_PHASE_ROT_M_CMD_A7                                = 0x26ae14a,
    ATTR_CEN_VPD_PHASE_ROT_M_CMD_A8                                = 0x2e20760,
    ATTR_CEN_VPD_PHASE_ROT_M_CMD_A9                                = 0xd5269dd,
    ATTR_CEN_VPD_PHASE_ROT_M_CMD_A10                               = 0xf1b559b,
    ATTR_CEN_VPD_PHASE_ROT_M_CMD_A11                               = 0x28f37bd,
    ATTR_CEN_VPD_PHASE_ROT_M_CMD_A12                               = 0xcd1f106,
    ATTR_CEN_VPD_PHASE_ROT_M_CMD_A13                               = 0x4900f59,
    ATTR_CEN_VPD_PHASE_ROT_M_CMD_A14                               = 0x5a17d9e,
    ATTR_CEN_VPD_PHASE_ROT_M_CMD_A15                               = 0xeba38bd,
    ATTR_CEN_VPD_PHASE_ROT_M_CMD_BA0                               = 0x71c3132,
    ATTR_CEN_VPD_PHASE_ROT_M_CMD_BA1                               = 0x7e4deef,
    ATTR_CEN_VPD_PHASE_ROT_M_CMD_BA2                               = 0x4fb1a4e,
    ATTR_CEN_VPD_PHASE_ROT_M_CMD_CASN                              = 0x2656d03,
    ATTR_CEN_VPD_PHASE_ROT_M_CMD_RASN                              = 0xa2540b5,
    ATTR_CEN_VPD_PHASE_ROT_M_CMD_WEN                               = 0xca2db25,
    ATTR_CEN_VPD_PHASE_ROT_M_PAR                                   = 0xa9b8404,
    ATTR_CEN_VPD_PHASE_ROT_M_ACTN                                  = 0x913a253,
    ATTR_CEN_VPD_PHASE_ROT_M0_CNTL_CKE0                            = 0x65fa6ba,
    ATTR_CEN_VPD_PHASE_ROT_M0_CNTL_CKE1                            = 0xb3da723,
    ATTR_CEN_VPD_PHASE_ROT_M0_CNTL_CKE2                            = 0xe493166,
    ATTR_CEN_VPD_PHASE_ROT_M0_CNTL_CKE3                            = 0x6bbfc0c,
    ATTR_CEN_VPD_PHASE_ROT_M0_CNTL_CSN0                            = 0x2ecc434,
    ATTR_CEN_VPD_PHASE_ROT_M0_CNTL_CSN1                            = 0x64ea8d9,
    ATTR_CEN_VPD_PHASE_ROT_M0_CNTL_CSN2                            = 0x27a3b1a,
    ATTR_CEN_VPD_PHASE_ROT_M0_CNTL_CSN3                            = 0xd71506d,
    ATTR_CEN_VPD_PHASE_ROT_M0_CNTL_ODT0                            = 0x6419870,
    ATTR_CEN_VPD_PHASE_ROT_M0_CNTL_ODT1                            = 0xd76d47e,
    ATTR_CEN_VPD_PHASE_ROT_M1_CNTL_CKE0                            = 0x0f4e1f6,
    ATTR_CEN_VPD_PHASE_ROT_M1_CNTL_CKE1                            = 0x189e001,
    ATTR_CEN_VPD_PHASE_ROT_M1_CNTL_CKE2                            = 0xa2310ab,
    ATTR_CEN_VPD_PHASE_ROT_M1_CNTL_CKE3                            = 0x667c752,
    ATTR_CEN_VPD_PHASE_ROT_M1_CNTL_CSN0                            = 0x0e10cd1,
    ATTR_CEN_VPD_PHASE_ROT_M1_CNTL_CSN1                            = 0x0834e3a,
    ATTR_CEN_VPD_PHASE_ROT_M1_CNTL_CSN2                            = 0x22cc436,
    ATTR_CEN_VPD_PHASE_ROT_M1_CNTL_CSN3                            = 0x07b064a,
    ATTR_CEN_VPD_PHASE_ROT_M1_CNTL_ODT0                            = 0x464951f,
    ATTR_CEN_VPD_PHASE_ROT_M1_CNTL_ODT1                            = 0xa37304b,
    ATTR_CEN_VPD_PERIODIC_MEMCAL_MODE_OPTIONS                      = 0xcb3f9fc,
    ATTR_CEN_VPD_CKE_PRI_MAP                                       = 0x16c700b,
    ATTR_CEN_VPD_CKE_PWR_MAP                                       = 0x111cca3,
    ATTR_CEN_VPD_GPO                                               = 0xfa0ff17,
    ATTR_CEN_VPD_RLO                                               = 0x12d57c3,
    ATTR_CEN_VPD_WLO                                               = 0xf334614,
    ATTR_CEN_VPD_TSYS_ADR                                          = 0xcfcbb18,
    ATTR_CEN_VPD_TSYS_DP18                                         = 0x58c733b,
    ATTR_CEN_VPD_CDIMM_SENSOR_MAP_PRIMARY                          = 0x9377123,
    ATTR_CEN_VPD_CDIMM_SENSOR_MAP_SECONDARY                        = 0xe2373c9,
    ATTR_CEN_VPD_DRAM_2N_MODE_ENABLED                              = 0x6514c37,
    ATTR_CEN_CDIMM_VPD_MASTER_POWER_SLOPE                          = 0xc4874b5,
    ATTR_CEN_CDIMM_VPD_MASTER_POWER_INTERCEPT                      = 0xb9ca3d3,
    ATTR_CEN_CDIMM_VPD_SUPPLIER_POWER_SLOPE                        = 0x6d78d61,
    ATTR_CEN_CDIMM_VPD_SUPPLIER_POWER_INTERCEPT                    = 0x3747013,
    ATTR_CEN_VPD_MT_VERSION_BYTE                                   = 0x3f5b0af,
    ATTR_CEN_VPD_MR_VERSION_BYTE                                   = 0xf611c76,
    ATTR_CEN_VPD_MR_DATA_CONTROL_BYTE                              = 0x682fc65,
    ATTR_CEN_VPD_MT_DATA_CONTROL_BYTE                              = 0xcd98e05,
    ATTR_CEN_VPD_POWER_CONTROL_CAPABLE                             = 0x880e55b,
    ATTR_CEN_VPD_DIMM_RCD_IBT                                      = 0xe366bd3,
    ATTR_CEN_VPD_RD_CTR_WINDAGE_OFFSET                             = 0xa91e9eb,
    ATTR_CEN_ISDIMM_MBVPD_INDEX                                    = 0x9299ae3,
    ATTR_CEN_CDIMM_VPD_MASTER_TOTAL_POWER_SLOPE                    = 0x6935337,
    ATTR_CEN_CDIMM_VPD_MASTER_TOTAL_POWER_INTERCEPT                = 0x58fb4c8,
    ATTR_CEN_CDIMM_VPD_SUPPLIER_TOTAL_POWER_SLOPE                  = 0x91ecb4c,
    ATTR_CEN_CDIMM_VPD_SUPPLIER_TOTAL_POWER_INTERCEPT              = 0x1787137,
    ATTR_CEN_EFF_DRAM_ADDRESS_MIRRORING                            = 0x327f621,
    ATTR_CEN_MSS_VOLT                                              = 0x9915a1b,
    ATTR_CEN_MSS_VOLT_VPP                                          = 0xbeb0b3f,
    ATTR_CEN_MSS_FREQ_OVERRIDE                                     = 0x744b48b,
    ATTR_CEN_MSS_FREQ                                              = 0xe0cee5c,
    ATTR_CEN_MSS_VREF_CAL_CNTL                                     = 0x5002ebb,
    ATTR_CEN_EFF_DIMM_RANKS_CONFIGED                               = 0x19c1aa8,
    ATTR_CEN_EFF_NUM_RANKS_PER_DIMM                                = 0x981e348,
    ATTR_CEN_EFF_DIMM_TYPE                                         = 0x8b0548d,
    ATTR_CEN_EFF_CUSTOM_DIMM                                       = 0x06af8a9,
    ATTR_CEN_EFF_DRAM_WIDTH                                        = 0xe43e89a,
    ATTR_CEN_EFF_DRAM_GEN                                          = 0xd95adc1,
    ATTR_CEN_EFF_PRIMARY_RANK_GROUP0                               = 0x3a71a35,
    ATTR_CEN_EFF_PRIMARY_RANK_GROUP1                               = 0xd4c69ad,
    ATTR_CEN_EFF_PRIMARY_RANK_GROUP2                               = 0xe342420,
    ATTR_CEN_EFF_PRIMARY_RANK_GROUP3                               = 0x3439ff1,
    ATTR_CEN_EFF_SECONDARY_RANK_GROUP0                             = 0xef6070d,
    ATTR_CEN_EFF_SECONDARY_RANK_GROUP1                             = 0x7f09352,
    ATTR_CEN_EFF_SECONDARY_RANK_GROUP2                             = 0x2bd2766,
    ATTR_CEN_EFF_SECONDARY_RANK_GROUP3                             = 0x1d3b834,
    ATTR_CEN_EFF_TERTIARY_RANK_GROUP0                              = 0x30d084e,
    ATTR_CEN_EFF_TERTIARY_RANK_GROUP1                              = 0xba1f2ab,
    ATTR_CEN_EFF_TERTIARY_RANK_GROUP2                              = 0xf36c168,
    ATTR_CEN_EFF_TERTIARY_RANK_GROUP3                              = 0xc16e92e,
    ATTR_CEN_EFF_QUATERNARY_RANK_GROUP0                            = 0xd710fa6,
    ATTR_CEN_EFF_QUATERNARY_RANK_GROUP1                            = 0x8deea09,
    ATTR_CEN_EFF_QUATERNARY_RANK_GROUP2                            = 0x90db64a,
    ATTR_CEN_EFF_QUATERNARY_RANK_GROUP3                            = 0xd003a67,
    ATTR_CEN_EFF_DRAM_WR_VREF                                      = 0xafa101d,
    ATTR_CEN_EFF_DRAM_WR_VREF_SCHMOO                               = 0x7d23783,
    ATTR_CEN_EFF_CEN_DRV_IMP_DQ_DQS                                = 0x2f4087f,
    ATTR_CEN_EFF_CEN_DRV_IMP_DQ_DQS_SCHMOO                         = 0x9b039b6,
    ATTR_CEN_EFF_CEN_DRV_IMP_CLK_SCHMOO                            = 0x89f62ee,
    ATTR_CEN_EFF_CEN_DRV_IMP_SPCKE_SCHMOO                          = 0x11e4545,
    ATTR_CEN_EFF_CEN_DRV_IMP_CNTL_SCHMOO                           = 0x48658bb,
    ATTR_CEN_EFF_CEN_RCV_IMP_DQ_DQS                                = 0x53b2992,
    ATTR_CEN_EFF_CEN_RCV_IMP_DQ_DQS_SCHMOO                         = 0x15b523f,
    ATTR_CEN_EFF_CEN_SLEW_RATE_DQ_DQS                              = 0x5548a63,
    ATTR_CEN_EFF_CEN_SLEW_RATE_DQ_DQS_SCHMOO                       = 0x6b79b1a,
    ATTR_CEN_EFF_CEN_SLEW_RATE_CLK_SCHMOO                          = 0x73de7a1,
    ATTR_CEN_EFF_CEN_SLEW_RATE_SPCKE_SCHMOO                        = 0x2f8f25e,
    ATTR_CEN_EFF_CEN_SLEW_RATE_ADDR_SCHMOO                         = 0xa0e66d7,
    ATTR_CEN_EFF_CEN_SLEW_RATE_CNTL_SCHMOO                         = 0xba38f89,
    ATTR_CEN_EFF_RD_VREF                                           = 0x7db9326,
    ATTR_CEN_EFF_CEN_RD_VREF_SCHMOO                                = 0x7085a02,
    ATTR_CEN_EFF_DIMM_SIZE                                         = 0x0e8df6e,
    ATTR_CEN_EFF_DRAM_BANKS                                        = 0x02908ea,
    ATTR_CEN_EFF_DRAM_ROWS                                         = 0x6a90ade,
    ATTR_CEN_EFF_DRAM_COLS                                         = 0x8b20d41,
    ATTR_CEN_EFF_DRAM_DENSITY                                      = 0x9bdcdaa,
    ATTR_CEN_EFF_DRAM_TRCD                                         = 0x1836a37,
    ATTR_CEN_EFF_DRAM_TRRD                                         = 0x9543112,
    ATTR_CEN_EFF_DRAM_TRRD_L                                       = 0xecc5414,
    ATTR_CEN_EFF_DRAM_TRP                                          = 0x6d5a997,
    ATTR_CEN_EFF_DRAM_TRAS                                         = 0xb1db98e,
    ATTR_CEN_EFF_DRAM_TRC                                          = 0x4d6323a,
    ATTR_CEN_EFF_DRAM_TRFI                                         = 0x43ba536,
    ATTR_CEN_EFF_DRAM_TRFC                                         = 0xddf91cd,
    ATTR_CEN_EFF_DRAM_TWTR                                         = 0x1933ca2,
    ATTR_CEN_EFF_DRAM_TWTR_L                                       = 0x095db90,
    ATTR_CEN_EFF_DRAM_TRTP                                         = 0x307f42c,
    ATTR_CEN_EFF_DRAM_TFAW                                         = 0x1d20bdd,
    ATTR_CEN_EFF_DRAM_BL                                           = 0xfbaf45b,
    ATTR_CEN_EFF_DRAM_CL                                           = 0x55adebc,
    ATTR_CEN_EFF_DRAM_AL                                           = 0x4043cb7,
    ATTR_CEN_EFF_DRAM_CWL                                          = 0xa172bee,
    ATTR_CEN_EFF_DRAM_RBT                                          = 0x0addad1,
    ATTR_CEN_EFF_DRAM_TM                                           = 0xf4da2e3,
    ATTR_CEN_EFF_DRAM_DLL_RESET                                    = 0xecd6fdb,
    ATTR_CEN_EFF_DRAM_WR                                           = 0x0dc73e8,
    ATTR_CEN_EFF_DRAM_DLL_PPD                                      = 0xb42f8f9,
    ATTR_CEN_EFF_DRAM_DLL_ENABLE                                   = 0xda13177,
    ATTR_CEN_EFF_DRAM_TDQS                                         = 0x623d3cd,
    ATTR_CEN_EFF_DRAM_WR_LVL_ENABLE                                = 0xe8dda1d,
    ATTR_CEN_EFF_DRAM_OUTPUT_BUFFER                                = 0xea7a80c,
    ATTR_CEN_EFF_DRAM_PASR                                         = 0x84447d8,
    ATTR_CEN_EFF_DRAM_ASR                                          = 0x67b1316,
    ATTR_CEN_EFF_DRAM_SRT                                          = 0xbfc2d98,
    ATTR_CEN_EFF_MPR_LOC                                           = 0xd6495b1,
    ATTR_CEN_EFF_MPR_MODE                                          = 0xf4eb56b,
    ATTR_CEN_EFF_DIMM_RCD_CNTL_WORD_0_15                           = 0xd887095,
    ATTR_CEN_EFF_DIMM_DDR4_RC00                                    = 0x93e06ad,
    ATTR_CEN_EFF_DIMM_DDR4_RC01                                    = 0x6fa41e1,
    ATTR_CEN_EFF_DIMM_DDR4_RC02                                    = 0xa59e9bf,
    ATTR_CEN_EFF_DIMM_DDR4_RC03                                    = 0xee6811c,
    ATTR_CEN_EFF_DIMM_DDR4_RC04                                    = 0xad67ccf,
    ATTR_CEN_EFF_DIMM_DDR4_RC05                                    = 0x6fc5121,
    ATTR_CEN_EFF_DIMM_DDR4_RC06_07                                 = 0x4aacd37,
    ATTR_CEN_EFF_DIMM_DDR4_RC08                                    = 0xdfc70b4,
    ATTR_CEN_EFF_DIMM_DDR4_RC09                                    = 0xf9972b2,
    ATTR_CEN_EFF_DIMM_DDR4_RC10                                    = 0x1ef4374,
    ATTR_CEN_EFF_DIMM_DDR4_RC11                                    = 0x0a4b71b,
    ATTR_CEN_EFF_DIMM_DDR4_RC12                                    = 0xb105f49,
    ATTR_CEN_EFF_DIMM_DDR4_RC13                                    = 0xec72c7d,
    ATTR_CEN_EFF_DIMM_DDR4_RC14                                    = 0x17d3083,
    ATTR_CEN_EFF_DIMM_DDR4_RC15                                    = 0x191d103,
    ATTR_CEN_EFF_DIMM_DDR4_RC_1x                                   = 0x16b7380,
    ATTR_CEN_EFF_DIMM_DDR4_RC_2x                                   = 0x87bd1cc,
    ATTR_CEN_EFF_DIMM_DDR4_RC_3x                                   = 0x43ebe7d,
    ATTR_CEN_EFF_DIMM_DDR4_RC_4x                                   = 0x54f20c2,
    ATTR_CEN_EFF_DIMM_DDR4_RC_5x                                   = 0x254d9fb,
    ATTR_CEN_EFF_DIMM_DDR4_RC_6x                                   = 0xd82d9b6,
    ATTR_CEN_EFF_DIMM_DDR4_RC_7x                                   = 0x08f7b4d,
    ATTR_CEN_EFF_DIMM_DDR4_RC_8x                                   = 0x82c649b,
    ATTR_CEN_EFF_DIMM_DDR4_RC_9x                                   = 0x3cce036,
    ATTR_CEN_EFF_DIMM_DDR4_RC_Ax                                   = 0xde47cfc,
    ATTR_CEN_EFF_DIMM_DDR4_RC_Bx                                   = 0x22a780c,
    ATTR_CEN_EFF_SCHMOO_MODE                                       = 0x6b50c45,
    ATTR_CEN_EFF_SCHMOO_ADDR_MODE                                  = 0x869f899,
    ATTR_CEN_EFF_SCHMOO_TEST_VALID                                 = 0xedff315,
    ATTR_CEN_EFF_SCHMOO_PARAM_VALID                                = 0x1120167,
    ATTR_CEN_EFF_SCHMOO_WR_EYE_MIN_MARGIN                          = 0xff192b3,
    ATTR_CEN_EFF_SCHMOO_RD_EYE_MIN_MARGIN                          = 0x3142251,
    ATTR_CEN_EFF_SCHMOO_DQS_CLK_MIN_MARGIN                         = 0x1f2bcd4,
    ATTR_CEN_EFF_SCHMOO_RD_GATE_MIN_MARGIN                         = 0x52f31f0,
    ATTR_CEN_EFF_SCHMOO_ADDR_CMD_MIN_MARGIN                        = 0xc98a82d,
    ATTR_CEN_EFF_MEMCAL_INTERVAL                                   = 0x50a84d7,
    ATTR_CEN_EFF_ZQCAL_INTERVAL                                    = 0x7686210,
    ATTR_CEN_EFF_IBM_TYPE                                          = 0x795a863,
    ATTR_CEN_EFF_NUM_DROPS_PER_PORT                                = 0x54d689f,
    ATTR_CEN_EFF_STACK_TYPE                                        = 0xec3e951,
    ATTR_CEN_EFF_NUM_MASTER_RANKS_PER_DIMM                         = 0x6b62dba,
    ATTR_CEN_EFF_NUM_PACKAGES_PER_RANK                             = 0xc65a405,
    ATTR_CEN_EFF_NUM_DIES_PER_PACKAGE                              = 0x1674bb9,
    ATTR_CEN_MSS_MEM_THROTTLE_NUMERATOR_PER_MBA                    = 0xe8d6009,
    ATTR_CEN_MSS_MEM_THROTTLE_DENOMINATOR                          = 0x28b0dbe,
    ATTR_CEN_MSS_MEM_THROTTLE_NUMERATOR_PER_CHIP                   = 0x0e92733,
    ATTR_CEN_MSS_MEM_WATT_TARGET                                   = 0x82bc6a4,
    ATTR_CEN_MSS_POWER_SLOPE                                       = 0x3fa1340,
    ATTR_CEN_MSS_POWER_SLOPE2                                      = 0x9c9f3a2,
    ATTR_CEN_MSS_POWER_INT                                         = 0xdd513bc,
    ATTR_CEN_MSS_POWER_INT2                                        = 0xdd6a5e0,
    ATTR_CEN_MSS_TOTAL_POWER_SLOPE                                 = 0xcfc2a9a,
    ATTR_CEN_MSS_TOTAL_POWER_SLOPE2                                = 0x6db2eb2,
    ATTR_CEN_MSS_TOTAL_POWER_INT                                   = 0xc7e086f,
    ATTR_CEN_MSS_TOTAL_POWER_INT2                                  = 0x47675e0,
    ATTR_CEN_MSS_CHANNEL_PAIR_MAXPOWER                             = 0xaae5043,
    ATTR_CEN_MSS_RUNTIME_MEM_THROTTLE_NUMERATOR_PER_MBA            = 0x1c958c3,
    ATTR_CEN_MSS_RUNTIME_MEM_THROTTLE_DENOMINATOR                  = 0x2cb84a2,
    ATTR_CEN_MSS_RUNTIME_MEM_THROTTLE_NUMERATOR_PER_CHIP           = 0xb926025,
    ATTR_CEN_MRW_SAFEMODE_MEM_THROTTLE_NUMERATOR_PER_MBA           = 0x370b061,
    ATTR_CEN_MRW_SAFEMODE_MEM_THROTTLE_NUMERATOR_PER_CHIP          = 0x1967c1a,
    ATTR_CEN_MRW_THERMAL_MEMORY_POWER_LIMIT                        = 0xaa72074,
    ATTR_CEN_MSS_DERIVED_MBA_ADDR_INTERLEAVE_BIT                   = 0x958e78e,
    ATTR_CEN_MSS_DERIVED_MBA_CACHELINE_INTERLEAVE_MODE             = 0xaafd4f0,
    ATTR_CEN_MRW_MBA_CACHELINE_INTERLEAVE_MODE_CONTROL             = 0x878d10f,
    ATTR_CEN_MSS_CACHE_ENABLE                                      = 0xb4d4cf8,
    ATTR_CEN_MSS_PREFETCH_ENABLE                                   = 0x2c636b8,
    ATTR_CEN_MSS_CLEANER_ENABLE                                    = 0xfd1b83b,
    ATTR_CEN_MSS_EFF_DIMM_FUNCTIONAL_VECTOR                        = 0x6d48287,
    ATTR_CEN_EFF_DRAM_LPASR                                        = 0x37d1388,
    ATTR_CEN_EFF_MPR_PAGE                                          = 0x41c9ac8,
    ATTR_CEN_EFF_GEARDOWN_MODE                                     = 0xce4e093,
    ATTR_CEN_EFF_PER_DRAM_ACCESS                                   = 0xff781f8,
    ATTR_CEN_EFF_TEMP_READOUT                                      = 0x310c52f,
    ATTR_CEN_EFF_FINE_REFRESH_MODE                                 = 0x3ade6e3,
    ATTR_CEN_EFF_CRC_WR_LATENCY                                    = 0x51c8ac1,
    ATTR_CEN_EFF_MPR_RD_FORMAT                                     = 0x0483f1f,
    ATTR_CEN_EFF_MAX_POWERDOWN_MODE                                = 0x09f4548,
    ATTR_CEN_EFF_TEMP_REF_RANGE                                    = 0xed1f8e8,
    ATTR_CEN_EFF_TEMP_REF_MODE                                     = 0xaf1df7d,
    ATTR_CEN_EFF_INT_VREF_MON                                      = 0x225ce7a,
    ATTR_CEN_EFF_CS_CMD_LATENCY                                    = 0xc468688,
    ATTR_CEN_EFF_SELF_REF_ABORT                                    = 0x748adc1,
    ATTR_CEN_EFF_RD_PREAMBLE_TRAIN                                 = 0xcab8eb5,
    ATTR_CEN_EFF_RD_PREAMBLE                                       = 0x7f96acf,
    ATTR_CEN_EFF_WR_PREAMBLE                                       = 0xc4fc72c,
    ATTR_CEN_EFF_CA_PARITY_LATENCY                                 = 0x59149c4,
    ATTR_CEN_EFF_CRC_ERROR_CLEAR                                   = 0xcaed664,
    ATTR_CEN_EFF_CA_PARITY_ERROR_STATUS                            = 0xd9e41c8,
    ATTR_CEN_EFF_ODT_INPUT_BUFF                                    = 0xd7d60d6,
    ATTR_CEN_EFF_CA_PARITY                                         = 0xd31a650,
    ATTR_CEN_EFF_DATA_MASK                                         = 0xb3ecdd6,
    ATTR_CEN_EFF_WRITE_DBI                                         = 0xc1806ea,
    ATTR_CEN_EFF_READ_DBI                                          = 0xcefaef7,
    ATTR_CEN_EFF_VREF_DQ_TRAIN_VALUE                               = 0xaa26704,
    ATTR_CEN_EFF_VREF_DQ_TRAIN_RANGE                               = 0x5d87502,
    ATTR_CEN_EFF_VREF_DQ_TRAIN_ENABLE                              = 0xccaca56,
    ATTR_CEN_EFF_DRAM_TCCD_L                                       = 0x20a086a,
    ATTR_CEN_TCCD_L                                                = 0x93979a5,
    ATTR_CEN_EFF_WRITE_CRC                                         = 0x0589671,
    ATTR_CEN_MSS_CAL_STEP_ENABLE                                   = 0x604bcac,
    ATTR_CEN_MSS_DRAMINIT_RESET_DISABLE                            = 0xf7d3f14,
    ATTR_CEN_MSS_SLEW_RATE_DATA                                    = 0xfe92797,
    ATTR_CEN_MSS_SLEW_RATE_ADR                                     = 0xe8e23fa,
    ATTR_CEN_ECID                                                  = 0x14e5210,
    ATTR_CEN_MSS_ALLOW_SINGLE_PORT                                 = 0x354ab09,
    ATTR_CEN_MSS_DQS_SWIZZLE_TYPE                                  = 0x4b3f705,
    ATTR_CEN_MSS_PSRO                                              = 0xfe414f7,
    ATTR_CEN_MSS_NWELL_MISPLACEMENT                                = 0x9cc0816,
    ATTR_CEN_MSS_BLUEWATERFALL_BROKEN                              = 0x2d82797,
    ATTR_CEN_MCBIST_PATTERN                                        = 0x0b6c5db,
    ATTR_CEN_MCBIST_TEST_TYPE                                      = 0xf26628b,
    ATTR_CEN_MCBIST_PRINTING_DISABLE                               = 0xa4e60c2,
    ATTR_CEN_MCBIST_DATA_ENABLE                                    = 0x997f7c4,
    ATTR_CEN_MCBIST_USER_RANK                                      = 0x21603c1,
    ATTR_CEN_MCBIST_USER_BANK                                      = 0xdd686eb,
    ATTR_CEN_SCHMOO_MULTIPLE_SETUP_CALL                            = 0x3dd7117,
    ATTR_CEN_LRDIMM_RANK_MULT_MODE                                 = 0xca9f7c7,
    ATTR_CEN_MSS_THROTTLE_CONTROL_RAS_WEIGHT                       = 0x53f11f8,
    ATTR_CEN_MSS_THROTTLE_CONTROL_CAS_WEIGHT                       = 0x515dae1,
    ATTR_CEN_MCBIST_RANDOM_SEED_VALUE                              = 0x7b2175f,
    ATTR_CEN_MCBIST_RANDOM_SEED_TYPE                               = 0xc75eb41,
    ATTR_CEN_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT                   = 0x58d5cbf,
    ATTR_CEN_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_IDLE              = 0xe98a223,
    ATTR_CEN_MRW_MEM_THROTTLE_DENOMINATOR                          = 0x07596fc,
    ATTR_CEN_MSS_INIT_STATE                                        = 0xff27847,
    ATTR_CEN_MRW_MAX_DRAM_DATABUS_UTIL                             = 0x68888b2,
    ATTR_CEN_MSS_EFF_VPD_VERSION                                   = 0x87fe8e8,
    ATTR_CEN_MSS_NEST_CAPABLE_FREQUENCIES                          = 0x87001ce,
    ATTR_CEN_MRW_STRICT_MBA_PLUG_RULE_CHECKING                     = 0x6a19cdb,
    ATTR_CEN_MRW_CDIMM_MASTER_I2C_TEMP_SENSOR_ENABLE               = 0x5ac4af5,
    ATTR_CEN_MRW_CDIMM_SPARE_I2C_TEMP_SENSOR_ENABLE                = 0x42088ff,
    ATTR_CEN_MSS_VOLT_OVERRIDE                                     = 0x686471f,
    ATTR_CEN_MSS_VOLT_COMPLIANT_DIMMS                              = 0x7af7c72,
    ATTR_CEN_MRW_POWER_CONTROL_REQUESTED                           = 0x8f739e7,
    ATTR_CEN_VPD_ISDIMMTOC4DQ                                      = 0x0b7ecec,
    ATTR_CEN_VPD_ISDIMMTOC4DQS                                     = 0xfd81a13,
    ATTR_CEN_MRW_MEM_SENSOR_CACHE_ADDR_MAP                         = 0x9ee4937,
    ATTR_CEN_MSS_VMEM_REGULATOR_MAX_DIMM_COUNT                     = 0x6ab4033,
    ATTR_CEN_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE    = 0xf1bc24b,
    ATTR_CEN_MRW_MAX_NUMBER_DIMMS_POSSIBLE_PER_VMEM_REGULATOR      = 0x913b3e8,
    ATTR_CEN_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM        = 0x93bf1d6,
    ATTR_CEN_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR4   = 0x299e4e4,
    ATTR_CEN_MRW_WR_VREF_CHECK_VREF_STEP_SIZE                      = 0x65f1d3f,
    ATTR_CEN_MCBIST_ADDR_MODES                                     = 0xd50eebc,
    ATTR_CEN_MCBIST_RANK                                           = 0x8ad71d2,
    ATTR_CEN_MCBIST_START_ADDR                                     = 0x5bc2120,
    ATTR_CEN_MCBIST_END_ADDR                                       = 0xe532e44,
    ATTR_CEN_MCBIST_ERROR_CAPTURE                                  = 0x260db1a,
    ATTR_CEN_MCBIST_MAX_TIMEOUT                                    = 0x4993ed6,
    ATTR_CEN_MCBIST_PRINT_PORT                                     = 0x54b87d2,
    ATTR_CEN_MCBIST_STOP_ON_ERROR                                  = 0x7aaa7ea,
    ATTR_CEN_MCBIST_DATA_SEED                                      = 0x239639b,
    ATTR_CEN_MCBIST_ADDR_INTER                                     = 0xf8f5783,
    ATTR_CEN_MCBIST_ADDR_NUM_ROWS                                  = 0x9f281eb,
    ATTR_CEN_MCBIST_ADDR_NUM_COLS                                  = 0xcfd32f3,
    ATTR_CEN_MCBIST_ADDR_RANK                                      = 0x1e81411,
    ATTR_CEN_MCBIST_ADDR_BANK                                      = 0x3de3e81,
    ATTR_CEN_MCBIST_ADDR_SLAVE_RANK_ON                             = 0x7be028c,
    ATTR_CEN_MCBIST_ADDR_STR_MAP                                   = 0x292cb92,
    ATTR_CEN_MCBIST_ADDR_RAND                                      = 0xc32d9ea,
    ATTR_IO_DMI_CEN_TX_MARGIN_RATIO                                = 0x5f1edc8,
    ATTR_IO_DMI_CEN_TX_FFE_POSTCURSOR                              = 0x8fbd559,
    ATTR_CLASS                                                     = 0xc18e8f1,
    ATTR_TYPE                                                      = 0x9484951,
    ATTR_MODEL                                                     = 0x7a03bac,
    ATTR_ENGINE_TYPE                                               = 0xa9d881f,
    ATTR_SYSTEM_IPL_PHASE                                          = 0x6a47337,
    ATTR_DUMMY_RW                                                  = 0x6b5b079,
    ATTR_DUMMY_WO                                                  = 0x18849c5,
    ATTR_DUMMY_RO                                                  = 0x7f95302,
    ATTR_DUMMY_HEAP_ZERO_DEFAULT                                   = 0x9184d62,
    ATTR_PHYS_PATH                                                 = 0xf7abb7c,
    ATTR_AFFINITY_PATH                                             = 0xb5afcd7,
    ATTR_POWER_PATH                                                = 0xd43ef5c,
    ATTR_PRIMARY_CAPABILITIES                                      = 0xd84c572,
    ATTR_CPU_ATTR                                                  = 0xd301294,
    ATTR_SCOM_SWITCHES                                             = 0xbc8d08b,
    ATTR_FSI_MASTER_CHIP                                           = 0x25b0084,
    ATTR_ALTFSI_MASTER_CHIP                                        = 0x9008e43,
    ATTR_FSI_MASTER_TYPE                                           = 0x116670c,
    ATTR_FSI_MASTER_PORT                                           = 0xf4637bc,
    ATTR_ALTFSI_MASTER_PORT                                        = 0x3d7757a,
    ATTR_FSI_SLAVE_CASCADE                                         = 0x21c70fd,
    ATTR_FSI_OPTION_FLAGS                                          = 0x3b6e39f,
    ATTR_HWAS_STATE                                                = 0x16fbd51,
    ATTR_HWAS_STATE_CHANGED_FLAG                                   = 0x1c5c585,
    ATTR_HWAS_STATE_CHANGED_SUBSCRIPTION_MASK                      = 0x4a76d45,
    ATTR_NUMERIC_POD_TYPE_TEST                                     = 0xdbe5186,
    ATTR_DECONFIG_GARDABLE                                         = 0x59253de,
    ATTR_EEPROM_VPD_PRIMARY_INFO                                   = 0xcdbfb30,
    ATTR_EEPROM_VPD_BACKUP_INFO                                    = 0x1fbf757,
    ATTR_EEPROM_SBE_PRIMARY_INFO                                   = 0x9e4aac2,
    ATTR_EEPROM_SBE_BACKUP_INFO                                    = 0xcba1600,
    ATTR_TEMP_SENSOR_I2C_CONFIG                                    = 0xb1fab71,
    ATTR_TPM_INFO                                                  = 0xca6a09a,
    ATTR_HDAT_EC                                                   = 0x9f10191,
    ATTR_CHIP_UNIT                                                 = 0x9615865,
    ATTR_POSITION                                                  = 0x90b4ba7,
    ATTR_FABRIC_GROUP_ID                                           = 0xdb4e40c,
    ATTR_FABRIC_CHIP_ID                                            = 0x34eeb58,
    ATTR_MIN_FREQ_MHZ                                              = 0x6f08f4b,
    ATTR_DPO_MIN_FREQ_PERCENT                                      = 0x6d7bbc9,
    ATTR_HUID                                                      = 0xf9fde6a,
    ATTR_SP_FUNCTIONS                                              = 0xa82e8ff,
    ATTR_HB_SETTINGS                                               = 0x19d1b7e,
    ATTR_CEC_IPL_TYPE                                              = 0x1e1c64d,
    ATTR_TEST_NULL_STRING                                          = 0x6fd2aa7,
    ATTR_TEST_MIN_STRING                                           = 0xd2401e6,
    ATTR_TEST_MAX_STRING                                           = 0x428e6a8,
    ATTR_TEST_NO_DEFAULT_STRING                                    = 0xc5d939e,
    ATTR_FAPI_NAME                                                 = 0x9dc28f2,
    ATTR_VPD_REC_NUM                                               = 0x03a8b72,
    ATTR_PEER_TARGET                                               = 0x6f76a92,
    ATTR_PAYLOAD_BASE                                              = 0x020a135,
    ATTR_PAYLOAD_ENTRY                                             = 0x64b6d86,
    ATTR_PAYLOAD_KIND                                              = 0xa4d2083,
    ATTR_HB_HRMOR_NODAL_BASE                                       = 0x11a66f1,
    ATTR_FABRIC_TO_PHYSICAL_NODE_MAP                               = 0x2d207b6,
    ATTR_XSCOM_BASE_ADDRESS                                        = 0x7803464,
    ATTR_IBSCOM_MCS_BASE_ADDR                                      = 0x1983e2d,
    ATTR_IBSCOM_PROC_BASE_ADDR                                     = 0x06d3ba7,
    ATTR_PAYLOAD_IN_MIRROR_MEM                                     = 0x8c5fb5a,
    ATTR_NPU_MMIO_BAR_BASE_ADDR                                    = 0xff18a73,
    ATTR_NPU_MMIO_BAR_SIZE                                         = 0x77da343,
    ATTR_FSP_BASE_ADDR                                             = 0xfcfe1a6,
    ATTR_FSP_BAR_SIZE                                              = 0xd8dde00,
    ATTR_PSI_BRIDGE_BASE_ADDR                                      = 0x6508321,
    ATTR_INTP_BASE_ADDR                                            = 0xac49a29,
    ATTR_PHB_BASE_ADDRS                                            = 0xb6f0cd7,
    ATTR_PCI_BASE_ADDRS_64                                         = 0x2d4e887,
    ATTR_PCI_BASE_ADDRS_32                                         = 0xb3aa338,
    ATTR_MEM_BASE                                                  = 0x45a548d,
    ATTR_MIRROR_BASE                                               = 0x686bbbc,
    ATTR_RNG_BASE_ADDR                                             = 0xafef4d7,
    ATTR_RNG_BAR_SIZE                                              = 0xe2bf285,
    ATTR_IMT_BASE_ADDR                                             = 0xd83c2a5,
    ATTR_IMT_BAR_SIZE                                              = 0x6c120b2,
    ATTR_NOMINAL_FREQ_MHZ                                          = 0x4e64981,
    ATTR_ULTRA_TURBO_FREQ_MHZ                                      = 0xca2de0a,
    ATTR_AVDD_ID                                                   = 0xc710685,
    ATTR_VDD_ID                                                    = 0x2a9cfd3,
    ATTR_VCS_ID                                                    = 0x780a573,
    ATTR_VPP_ID                                                    = 0xa5ccc9a,
    ATTR_VDDR_ID                                                   = 0x3dbc21a,
    ATTR_NEST_VDDR_ID                                              = 0x6a22222,
    ATTR_NEST_VIO_ID                                               = 0xec8827a,
    ATTR_NEST_VDD_ID                                               = 0x89224bc,
    ATTR_NEST_VDN_ID                                               = 0x61356e1,
    ATTR_NEST_VCS_ID                                               = 0xc498800,
    ATTR_MSS_VDDR_PROGRAM                                          = 0x51289c7,
    ATTR_MSS_VPP_PROGRAM                                           = 0x2280840,
    ATTR_MSS_VCS_PROGRAM                                           = 0xb4f1718,
    ATTR_MSS_AVDD_PROGRAM                                          = 0xefb544c,
    ATTR_MSS_VDD_PROGRAM                                           = 0x17228f8,
    ATTR_MSS_VOLT_VDDR_MILLIVOLTS                                  = 0x3317838,
    ATTR_MSS_VOLT_VPP_MILLIVOLTS                                   = 0x18a11eb,
    ATTR_MSS_VOLT_VCS_MILLIVOLTS                                   = 0xc76fe71,
    ATTR_MSS_VOLT_VDD_MILLIVOLTS                                   = 0xdcbd688,
    ATTR_MSS_VOLT_AVDD_MILLIVOLTS                                  = 0x6f09c49,
    ATTR_MSS_VOLT_VDDR_OFFSET_MILLIVOLTS                           = 0x666457d,
    ATTR_MSS_VOLT_VPP_OFFSET_MILLIVOLTS                            = 0x1166570,
    ATTR_MSS_VOLT_VCS_OFFSET_MILLIVOLTS                            = 0x32d623a,
    ATTR_MSS_VOLT_VDD_OFFSET_MILLIVOLTS                            = 0x9a3b18e,
    ATTR_MSS_VOLT_AVDD_OFFSET_MILLIVOLTS                           = 0x4f0f469,
    ATTR_ENABLED_THREADS                                           = 0xdf90286,
    ATTR_MAX_PROC_CHIPS_PER_NODE                                   = 0x8dc78ef,
    ATTR_MAX_EXS_PER_PROC_CHIP                                     = 0xa59a4fa,
    ATTR_MAX_DIMMS_PER_MBA_PORT                                    = 0x9130cb8,
    ATTR_MAX_MBA_PORTS_PER_MBA                                     = 0xeb1d539,
    ATTR_MAX_MBAS_PER_MEMBUF_CHIP                                  = 0x90ddd8e,
    ATTR_MAX_CHIPLETS_PER_PROC                                     = 0xfa1c9e6,
    ATTR_MAX_MCS_PER_SYSTEM                                        = 0x86e21ac,
    ATTR_TEST_NEGATIVE_FCN                                         = 0x30cbc29,
    ATTR_FRU_ID                                                    = 0x278bc56,
    ATTR_BMC_FRU_ID                                                = 0xe3947ec,
    ATTR_CENTAUR_ECID_FRU_ID                                       = 0x957176b,
    ATTR_PLCK_IPL_ATTR_OVERRIDES_EXIST                             = 0xba4cb42,
    ATTR_IS_INTER_ENCLOSURE_BUS                                    = 0x56ef574,
    ATTR_PEER_PATH                                                 = 0xae3bc8f,
    ATTR_CDM_POLICIES                                              = 0x6f11c24,
    ATTR_FIELD_CORE_OVERRIDE                                       = 0xaff2273,
    ATTR_HOSTSVC_PLID                                              = 0x0aa0ab1,
    ATTR_RUN_MAX_MEM_PATTERNS                                      = 0x778bcbb,
    ATTR_PROC_MASTER_TYPE                                          = 0x68e1db7,
    ATTR_MSS_DATABUS_UTIL_PER_MBA                                  = 0xa2f9494,
    ATTR_EFFECTIVE_EC                                              = 0x8ff8d9c,
    ATTR_MRU_ID                                                    = 0x639dd88,
    ATTR_TOD_ROLE                                                  = 0x019e5ac,
    ATTR_HB_RSV_MEM_SIZE_MB                                        = 0xbf11ec0,
    ATTR_DO_ABUS_DECONFIG                                          = 0x33b0757,
    ATTR_MEM_AVDD_OFFSET_MILLIVOLTS                                = 0x80161a9,
    ATTR_RECONFIG_LOOP_TESTS                                       = 0x4fe6548,
    ATTR_RECONFIG_LOOP_TESTS_ENABLE                                = 0x97d43be,
    ATTR_MEM_VDD_OFFSET_MILLIVOLTS                                 = 0xcc28df8,
    ATTR_MEM_VCS_OFFSET_MILLIVOLTS                                 = 0xb7b1ac5,
    ATTR_MEM_VPP_OFFSET_MILLIVOLTS                                 = 0xd4a475d,
    ATTR_MEM_VDDR_OFFSET_MILLIVOLTS                                = 0xe390ea6,
    ATTR_MSS_CENT_AVDD_SLOPE_ACTIVE                                = 0x0b207b3,
    ATTR_MSS_CENT_AVDD_SLOPE_INACTIVE                              = 0xbaa5d46,
    ATTR_MSS_CENT_AVDD_INTERCEPT                                   = 0xbb0ac42,
    ATTR_MSS_CENT_VDD_SLOPE_ACTIVE                                 = 0x9aef30c,
    ATTR_MSS_CENT_VDD_SLOPE_INACTIVE                               = 0x3e7ad0d,
    ATTR_MSS_CENT_VDD_INTERCEPT                                    = 0xe54617c,
    ATTR_MSS_CENT_VCS_SLOPE_ACTIVE                                 = 0xdfbb097,
    ATTR_MSS_CENT_VCS_SLOPE_INACTIVE                               = 0x0cbd3fd,
    ATTR_MSS_CENT_VCS_INTERCEPT                                    = 0x42b4fae,
    ATTR_MSS_VOLT_VPP_SLOPE                                        = 0x72f49a4,
    ATTR_MSS_VOLT_VPP_INTERCEPT                                    = 0x3aa234f,
    ATTR_MSS_VOLT_VPP_SLOPE_POST_DRAM_INIT                         = 0xe2c64ec,
    ATTR_MSS_VOLT_VPP_INTERCEPT_POST_DRAM_INIT                     = 0xd513657,
    ATTR_MSS_VOLT_DDR3_VDDR_SLOPE                                  = 0x10d2a3d,
    ATTR_MSS_VOLT_DDR3_VDDR_INTERCEPT                              = 0xbdf333e,
    ATTR_MRW_DDR3_VDDR_MAX_LIMIT                                   = 0x6ac0905,
    ATTR_MSS_VOLT_DDR3_VDDR_SLOPE_POST_DRAM_INIT                   = 0x420d32d,
    ATTR_MSS_VOLT_DDR3_VDDR_INTERCEPT_POST_DRAM_INIT               = 0x829fde2,
    ATTR_MRW_DDR3_VDDR_MAX_LIMIT_POST_DRAM_INIT                    = 0xdde9311,
    ATTR_MSS_VOLT_DDR4_VDDR_SLOPE                                  = 0x5d56393,
    ATTR_MSS_VOLT_DDR4_VDDR_INTERCEPT                              = 0x56b3514,
    ATTR_MRW_DDR4_VDDR_MAX_LIMIT                                   = 0x69b9e21,
    ATTR_MSS_VOLT_DDR4_VDDR_SLOPE_POST_DRAM_INIT                   = 0xb11a217,
    ATTR_MSS_VOLT_DDR4_VDDR_INTERCEPT_POST_DRAM_INIT               = 0x6129fe7,
    ATTR_MRW_DDR4_VDDR_MAX_LIMIT_POST_DRAM_INIT                    = 0x7b5c147,
    ATTR_I2C_SWITCHES                                              = 0x442b881,
    ATTR_OCC_MASTER_CAPABLE                                        = 0xe7e15a5,
    ATTR_PROC_PCIE_LANE_MASK                                       = 0x1439e9f,
    ATTR_PEC_PCIE_IOP_REVERSAL                                     = 0x97e0876,
    ATTR_PEC_PCIE_IOP_REVERSAL_NON_BIFURCATED                      = 0xebbaf50,
    ATTR_PEC_PCIE_IOP_SWAP_NON_BIFURCATED                          = 0x70406e6,
    ATTR_PEC_PCIE_LANE_MASK_NON_BIFURCATED                         = 0x65a6fb3,
    ATTR_PEC_PCIE_IOP_REVERSAL_BIFURCATED                          = 0x3322938,
    ATTR_PEC_PCIE_IOP_SWAP_BIFURCATED                              = 0x1d55f3f,
    ATTR_PEC_PCIE_LANE_MASK_BIFURCATED                             = 0xa258a52,
    ATTR_PROC_PCIE_IS_SLOT                                         = 0x69653af,
    ATTR_CDM_DOMAIN                                                = 0xb728b91,
    ATTR_I2C_BUS_SPEED_ARRAY                                       = 0x5c75b22,
    ATTR_ISTEP_PAUSE_ENABLE                                        = 0x5171c01,
    ATTR_ISTEP_PAUSE_CONFIG                                        = 0x2cf6852,
    ATTR_TPM_REQUIRED                                              = 0xe79c887,
    ATTR_MNFG_TH_P8EX_L2_CACHE_CES                                 = 0x4a0eab5,
    ATTR_MNFG_TH_P8EX_L2_DIR_CES                                   = 0xd9a1169,
    ATTR_MNFG_TH_P8EX_L3_CACHE_CES                                 = 0x834d343,
    ATTR_MNFG_TH_P8EX_L3_DIR_CES                                   = 0xeca4ce3,
    ATTR_FIELD_TH_P8EX_L2_LINE_DELETES                             = 0x71a9c51,
    ATTR_FIELD_TH_P8EX_L3_LINE_DELETES                             = 0x81856c6,
    ATTR_FIELD_TH_P8EX_L2_COL_REPAIRS                              = 0xcb7fee2,
    ATTR_FIELD_TH_P8EX_L3_COL_REPAIRS                              = 0x9886c55,
    ATTR_MNFG_TH_P8EX_L2_LINE_DELETES                              = 0x73a79a6,
    ATTR_MNFG_TH_P8EX_L3_LINE_DELETES                              = 0x00f7abf,
    ATTR_MNFG_TH_P8EX_L2_COL_REPAIRS                               = 0x135e94d,
    ATTR_MNFG_TH_P8EX_L3_COL_REPAIRS                               = 0xd801bd0,
    ATTR_MNFG_TH_CEN_MBA_RT_SOFT_CE_TH_ALGO                        = 0x31f5434,
    ATTR_MNFG_TH_CEN_MBA_IPL_SOFT_CE_TH_ALGO                       = 0x9855215,
    ATTR_MNFG_TH_CEN_MBA_RT_RCE_PER_RANK                           = 0x98a4f85,
    ATTR_MNFG_TH_CEN_L4_CACHE_CES                                  = 0x9b3e875,
    ATTR_MNFG_TH_RCD_PARITY_ERRORS                                 = 0xe6e8743,
    ATTR_MNFG_TH_MEMORY_IUES                                       = 0x723f825,
    ATTR_MNFG_TH_MEMORY_IMPES                                      = 0x1049d17,
    ATTR_RCD_PARITY_RECONFIG_LOOPS_ALLOWED                         = 0x3d1a60f,
    ATTR_RCD_PARITY_RECONFIG_LOOP_COUNT                            = 0x5b0d3bc,
    ATTR_RESOURCE_IS_CRITICAL                                      = 0xbfccf0c,
    ATTR_VAS_HYPERVISOR_WINDOW_CONTEXT_ADDR                        = 0xf689398,
    ATTR_VAS_USER_WINDOW_CONTEXT_ADDR                              = 0x2a4d231,
    ATTR_LPC_BUS_ADDR                                              = 0x1ffe3ce,
    ATTR_NVIDIA_NPU_PRIVILEGED_ADDR                                = 0xfb4c268,
    ATTR_NVIDIA_NPU_USER_REG_ADDR                                  = 0x340f35b,
    ATTR_NVIDIA_PHY0_REG_ADDR                                      = 0xaaf89b9,
    ATTR_NVIDIA_PHY1_REG_ADDR                                      = 0x243b111,
    ATTR_XIVE_CONTROLLER_BAR_ADDR                                  = 0x859437f,
    ATTR_XIVE_THREAD_MGMT1_BAR_ADDR                                = 0x5cba1d1,
    ATTR_PSI_HB_ESB_ADDR                                           = 0x4e64812,
    ATTR_NX_RNG_ADDR                                               = 0xa3a5dd7,
    ATTR_FUSED_CORE_OPTION                                         = 0x9f670db,
    ATTR_ICACHE_LINE_SIZE                                          = 0x934de01,
    ATTR_ICACHE_BLOCK_SIZE                                         = 0x2c13580,
    ATTR_ICACHE_SIZE                                               = 0x7d275f0,
    ATTR_ICACHE_ASSOC_SETS                                         = 0xacc8025,
    ATTR_DCACHE_LINE_SIZE                                          = 0x9cb467b,
    ATTR_DCACHE_ASSOC_SETS                                         = 0x0bce06b,
    ATTR_L2_CACHE_LINE_SIZE                                        = 0xfc7c1e8,
    ATTR_L2_CACHE_SIZE                                             = 0x07a2758,
    ATTR_L2_CACHE_ASSOC_SETS                                       = 0x8845c5b,
    ATTR_L3_CACHE_LINE_SIZE                                        = 0xfc574bf,
    ATTR_L3_CACHE_SIZE                                             = 0xdbffc50,
    ATTR_TIME_BASE                                                 = 0x1192453,
    ATTR_TLB_DATA_ENTRIES                                          = 0xfb5ce79,
    ATTR_TLB_DATA_ASSOC_SETS                                       = 0xfca622c,
    ATTR_TLB_INSTR_ENTRIES                                         = 0x436dd94,
    ATTR_TLB_INSTR_ASSOC_SETS                                      = 0x134fdb0,
    ATTR_TLB_RESERVE_SIZE                                          = 0xeb0420c,
    ATTR_DATA_CACHE_SIZE                                           = 0xd75007e,
    ATTR_DATA_CACHE_LINE_SIZE                                      = 0xf4e0097,
    ATTR_THREAD_COUNT                                              = 0x8ce790d,
    ATTR_HDAT_RSV_MEM_NUM_SECTIONS                                 = 0x997e20e,
    ATTR_HDAT_HBRT_NUM_SECTIONS                                    = 0xc6dfefe,
    ATTR_HDAT_HBRT_SECTION_SIZE                                    = 0xd0167e2,
    ATTR_WOF_POWER_LIMIT                                           = 0x4baf80d,
    ATTR_CHIPLET_ID                                                = 0x2e5f49c,
    ATTR_SUPPORTS_DYNAMIC_MEM_VOLT                                 = 0xf70279f,
    ATTR_SYSTEM_FAMILY                                             = 0xc8c49e7,
    ATTR_SYSTEM_TYPE                                               = 0xa40efa1,
    ATTR_TOD_CPU_DATA                                              = 0xfaa68ab,
    ATTR_SUPPORTED_STOP_STATES                                     = 0xbc55176,
    ATTR_PROC_PCIE_LANE_EQUALIZATION_GEN3                          = 0x4b839c0,
    ATTR_PROC_PCIE_LANE_EQUALIZATION_GEN4                          = 0xdab5f58,
    ATTR_ORDINAL_ID                                                = 0xe2df671,
    ATTR_RAW_MTM                                                   = 0x84a4edb,
    ATTR_XIVE_HW_RESET                                             = 0x9fb4db6,
    ATTR_DISABLE_I2C_ENGINE2_PORT0_DIAG_MODE                       = 0xf9e2621,
    ATTR_PNOR_FLASH_WORKAROUNDS                                    = 0x30c07c8,
    ATTR_FREQ_CORE_MAX                                             = 0x9b7245b,
    ATTR_PIB_I2C_NEST_PLL                                          = 0x19a4504,
    ATTR_SYNC_BETWEEN_STEPS                                        = 0x3761a65,
    ATTR_NEST_PLL_FREQ_BUCKETS                                     = 0xad3e4fe,
    ATTR_NEST_PLL_FREQ_LIST                                        = 0x9b7099c,
    ATTR_NEST_PLL_FREQ_I2CDIV_LIST                                 = 0x78c64c6,
    ATTR_MBA_PORT                                                  = 0x5207f78,
    ATTR_MBA_DIMM                                                  = 0x80b9cd7,
    ATTR_ASYNC_NEST_FREQ_MHZ                                       = 0xc794239,
    ATTR_CHIP_ID                                                   = 0x6d3696b,
    ATTR_SBE_IS_STARTED                                            = 0xe926ea8,
    ATTR_MIRROR_BASE_ADDRESS                                       = 0x6a258b6,
    ATTR_PROC_PCIE_PHB_ACTIVE                                      = 0x763e8c5,
    ATTR_PROC_PCIE_NUM_PEC                                         = 0xd837641,
    ATTR_HOMER_PHYS_ADDR                                           = 0xcac816f,
    ATTR_FREQ_CORE_CEILING_MHZ                                     = 0xa3dc291,
    ATTR_PG                                                        = 0x49f38fe,
    ATTR_SECUREBOOT_PROTECT_DECONFIGURED_TPM                       = 0x96f8bd3,
    ATTR_PROC_PCIE_PCS_SYSTEM_CNTL                                 = 0x4d8df8d,
    ATTR_SBE_UPDATE_DISABLE                                        = 0x2b23c7c,
    ATTR_PROC_PCIE_REFCLOCK_ENABLE                                 = 0xe2cfa5e,
    ATTR_PROC_PCIE_IOP_CONFIG                                      = 0xeb604df,
    ATTR_PROC_PCIE_IOVALID_ENABLE                                  = 0x48a8902,
    ATTR_ISTEP_MODE                                                = 0x54d128f,
    ATTR_EC                                                        = 0x3fd6b69,
    ATTR_EFF_DRAM_COLS                                             = 0xed0bb9d,
    ATTR_EFF_DRAM_ROWS                                             = 0x39edd97,
    ATTR_REDUNDANT_CLOCKS                                          = 0x706e27b,
    ATTR_REL_POS                                                   = 0x30c46b3,
    ATTR_FUSED_CORE_MODE_HB                                        = 0xc7d9261,
    ATTR_SOCKET_POWER_NOMINAL                                      = 0xe2ab0d2,
    ATTR_SOCKET_POWER_TURBO                                        = 0x8949e92,
    ATTR_WOF_TABLE_LID_NUMBER                                      = 0xe1b47d7,
    ATTR_PROC_DCM_INSTALLED                                        = 0x2b8d151,
    ATTR_PROC_PCIE_PCS_RX_LOFF_CONTROL                             = 0xa10bfc8,
    ATTR_PROC_PCIE_PCS_RX_PHASE_ROTATOR_CNTL                       = 0xc4fcb9a,
    ATTR_PROC_PCIE_PCS_RX_SIGDET_CNTL                              = 0xf2039e4,
    ATTR_PROC_PCIE_PCS_TX_FIFO_CONFIG_OFFSET                       = 0xb67f259,
    ATTR_HOT_PLUG_POWER_CONTROLLER_INFO                            = 0x837b78a,
    ATTR_PM_UNDERVOLTING_FRQ_MINIMUM                               = 0xea63a7d,
    ATTR_PM_UNDERVOLTING_FREQ_MAXIMUM                              = 0x869f8d9,
    ATTR_PM_WINKLE_ENTRY                                           = 0x4c67b3c,
    ATTR_PM_WINKLE_EXIT                                            = 0x02418ea,
    ATTR_PM_SPIVID_PORT_ENABLE                                     = 0x350d093,
    ATTR_PM_PBAX_NODEID                                            = 0x020df55,
    ATTR_PM_SLEEP_ENTRY                                            = 0x6dbe008,
    ATTR_PM_SLEEP_EXIT                                             = 0x63850ad,
    ATTR_PM_SLEEP_TYPE                                             = 0x82aa9cb,
    ATTR_PM_WINKLE_TYPE                                            = 0xdfcccc7,
    ATTR_MSS_PHY_SEQ_REFRESH                                       = 0x13326ac,
    ATTR_PRD_HWP_PLID                                              = 0x38a7b13,
    ATTR_SLOT_NAME                                                 = 0x5ef37d7,
    ATTR_SLOT_INDEX                                                = 0x51cc341,
    ATTR_PCIE_32BIT_MMIO_SIZE                                      = 0xb312257,
    ATTR_PCIE_64BIT_MMIO_SIZE                                      = 0x9487ddb,
    ATTR_PCIE_32BIT_DMA_SIZE                                       = 0xe242d68,
    ATTR_PCIE_64BIT_DMA_SIZE                                       = 0x7e1fa3b,
    ATTR_HDDW_ORDER                                                = 0x6a00c9c,
    ATTR_MGC_LOAD_SOURCE                                           = 0xce01813,
    ATTR_PCIE_CAPABILITES                                          = 0x7f829da,
    ATTR_VENDOR_ID                                                 = 0x22d9035,
    ATTR_MAX_POWER                                                 = 0x935d008,
    ATTR_OBUS_BRICK_LANE_MASK                                      = 0x2d9433b,
    ATTR_OBUS_SLOT_INDEX                                           = 0xc610fe3,
    ATTR_MFG_TRACE_ENABLE                                          = 0xb257082,
    ATTR_MAX_SBE_SEEPROM_SIZE                                      = 0x97c0210,
    ATTR_STOP5_DISABLE                                             = 0x0ddfd25,
    ATTR_FREQ_PROC_REFCLOCK                                        = 0xaac24d5,
    ATTR_X_EREPAIR_THRESHOLD_FIELD                                 = 0xdc95f16,
    ATTR_A_EREPAIR_THRESHOLD_FIELD                                 = 0x0ca8faf,
    ATTR_DMI_EREPAIR_THRESHOLD_FIELD                               = 0xf3365af,
    ATTR_X_EREPAIR_THRESHOLD_MNFG                                  = 0x5035da1,
    ATTR_A_EREPAIR_THRESHOLD_MNFG                                  = 0x7da144e,
    ATTR_DMI_EREPAIR_THRESHOLD_MNFG                                = 0xfee10ad,
    ATTR_MSS_MBA_ADDR_INTERLEAVE_BIT                               = 0x8ee2d89,
    ATTR_MSS_MBA_CACHELINE_INTERLEAVE_MODE                         = 0x771b18e,
    ATTR_PM_SPIVID_FREQUENCY                                       = 0xb2af6a0,
    ATTR_PM_SAFE_FREQUENCY                                         = 0x74566a6,
    ATTR_PM_RESONANT_CLOCK_FULL_CLOCK_SECTOR_BUFFER_FREQUENCY      = 0x0fcef29,
    ATTR_PM_RESONANT_CLOCK_LOW_BAND_LOWER_FREQUENCY                = 0xe141cc3,
    ATTR_PM_RESONANT_CLOCK_LOW_BAND_UPPER_FREQUENCY                = 0x6636810,
    ATTR_PM_RESONANT_CLOCK_HIGH_BAND_LOWER_FREQUENCY               = 0xe7bf9a7,
    ATTR_PM_RESONANT_CLOCK_HIGH_BAND_UPPER_FREQUENCY               = 0xb3b543a,
    ATTR_MRW_MEM_THROTTLE_DENOMINATOR                              = 0x8218c38,
    ATTR_PM_SYSTEM_IVRM_VPD_MIN_LEVEL                              = 0xc8bfded,
    ATTR_MNFG_DMI_MIN_EYE_WIDTH                                    = 0x72b7486,
    ATTR_MNFG_DMI_MIN_EYE_HEIGHT                                   = 0xccc15e8,
    ATTR_MNFG_ABUS_MIN_EYE_WIDTH                                   = 0x0f9d926,
    ATTR_MNFG_ABUS_MIN_EYE_HEIGHT                                  = 0xeaa3fa0,
    ATTR_MNFG_XBUS_MIN_EYE_WIDTH                                   = 0xcbd7ed0,
    ATTR_BRAZOS_RX_FIFO_OVERRIDE                                   = 0x13f6c19,
    ATTR_MRW_MBA_CACHELINE_INTERLEAVE_MODE_CONTROL                 = 0xf597255,
    ATTR_PROC_PCIE_PCS_RX_VGA_CONTRL_REGISTER3                     = 0xae3040d,
    ATTR_PROC_REFCLOCK_RCVR_TERM                                   = 0x5f9ce72,
    ATTR_PCI_REFCLOCK_RCVR_TERM                                    = 0x64e7e70,
    ATTR_MAX_DMI_PER_PROC                                          = 0xa71e033,
    ATTR_PREVIOUS_SBE_ERROR                                        = 0x2943159,
    ATTR_MC_PLL_BUCKET                                             = 0xb43f2fe,
    ATTR_PM_SPWUP_FSP                                              = 0x00cdcc8,
    ATTR_PM_SPWUP_OCC                                              = 0x37373c5,
    ATTR_PM_SPWUP_PHYP                                             = 0x7890710,
    ATTR_PIB_I2C_REFCLOCK                                          = 0xa8b10e1,
    ATTR_ALL_MCS_IN_INTERLEAVING_GROUP                             = 0x06e992f,
    ATTR_PROC_SELECT_SEEPROM_IMAGE                                 = 0x36ac7a5,
    ATTR_PROC_SELECT_BOOT_SEEPROM_IMAGE                            = 0xdba3bba,
    ATTR_OB0_PLL_BUCKET                                            = 0xb7f6d95,
    ATTR_OB1_PLL_BUCKET                                            = 0x897907e,
    ATTR_OB2_PLL_BUCKET                                            = 0xe7c19db,
    ATTR_OB3_PLL_BUCKET                                            = 0xae8623f,
    ATTR_SYSTEM_VDM_DISABLE                                        = 0x36ea053,
    ATTR_HIDDEN_ERRLOGS_ENABLE                                     = 0x6adbf88,
    ATTR_IS_MPIPL_HB                                               = 0xdc00d2a,
    ATTR_XSCOM_VIRTUAL_ADDR                                        = 0x9b947e9,
    ATTR_FSI_MASTER_MUTEX                                          = 0x24bd83c,
    ATTR_EEPROM_PAGE_ARRAY                                         = 0x0691853,
    ATTR_HB_MUTEX_TEST_LOCK                                        = 0x62c7ef8,
    ATTR_I2C_PAGE_MUTEX_0                                          = 0x1419735,
    ATTR_I2C_PAGE_MUTEX_1                                          = 0xe6e329c,
    ATTR_I2C_PAGE_MUTEX_2                                          = 0x0ec8887,
    ATTR_I2C_PAGE_MUTEX_3                                          = 0x7329dbe,
    ATTR_I2C_ENGINE_MUTEX_0                                        = 0x99841b6,
    ATTR_I2C_ENGINE_MUTEX_1                                        = 0x07646f7,
    ATTR_I2C_ENGINE_MUTEX_2                                        = 0x29009e8,
    ATTR_I2C_ENGINE_MUTEX_3                                        = 0x3aecc94,
    ATTR_FSI_SCOM_MUTEX                                            = 0x1fa93ae,
    ATTR_SCOM_IND_MUTEX                                            = 0x474550f,
    ATTR_SCAN_MUTEX                                                = 0xde81674,
    ATTR_IBSCOM_VIRTUAL_ADDR                                       = 0x8516c9c,
    ATTR_IBSCOM_MUTEX                                              = 0x10dd067,
    ATTR_IBSCOM_ENABLE_OVERRIDE                                    = 0xc88c82f,
    ATTR_HB_EXISTING_IMAGE                                         = 0xad8243a,
    ATTR_HB_TARGET_SCOMABLE                                        = 0x1a96d47,
    ATTR_OCC_COMMON_AREA_PHYS_ADDR                                 = 0xd12d8c8,
    ATTR_HOMER_VIRT_ADDR                                           = 0x1838631,
    ATTR_HOMER_HCODE_LOADED                                        = 0xf888d7a,
    ATTR_SBE_FFDC_ADDR                                             = 0xe5c8589,
    ATTR_SBE_COMM_ADDR                                             = 0x1232b64,
    ATTR_SERIAL_NUMBER                                             = 0xbac5402,
    ATTR_PART_NUMBER                                               = 0x75f1df4,
    ATTR_VPD_SWITCHES                                              = 0x21a3945,
    ATTR_SPCWKUP_COUNT                                             = 0x09d23f6,
    ATTR_MSS_VOLT_VPP_SLOPE_EFF_CONFIG                             = 0x9c89449,
    ATTR_MSS_VOLT_VPP_INTERCEPT_EFF_CONFIG                         = 0xb165eec,
    ATTR_MSS_VOLT_DDR3_VDDR_SLOPE_EFF_CONFIG                       = 0x84b5044,
    ATTR_MSS_VOLT_DDR3_VDDR_INTERCEPT_EFF_CONFIG                   = 0xcc1d4bc,
    ATTR_MRW_DDR3_VDDR_MAX_LIMIT_EFF_CONFIG                        = 0x8830142,
    ATTR_MSS_VOLT_DDR4_VDDR_SLOPE_EFF_CONFIG                       = 0x646bfc6,
    ATTR_MSS_VOLT_DDR4_VDDR_INTERCEPT_EFF_CONFIG                   = 0x4706e9e,
    ATTR_MRW_DDR4_VDDR_MAX_LIMIT_EFF_CONFIG                        = 0xcbf0ce6,
    ATTR_CLEAR_DIMM_SPD_ENABLE                                     = 0x2a8e9d5,
    ATTR_WOF_FREQUENCY_UPLIFT_SELECTED                             = 0xc2f06b5,
    ATTR_HBRT_HYP_ID                                               = 0x891d6d1,
    ATTR_IS_DRTM_MPIPL_HB                                          = 0xf0904ee,
    ATTR_DRTM_PAYLOAD_ADDR_MB_HB                                   = 0xe67411b,
    ATTR_FORCE_PRE_PAYLOAD_DRTM                                    = 0xd794c33,
    ATTR_ATTN_CHK_ALL_PROCS                                        = 0x02fea82,
    ATTR_MASTER_MBOX_SCRATCH                                       = 0x73b59bc,
    ATTR_HB_RSV_MEM_NEXT_SECTION                                   = 0x5a32695,
    ATTR_HB_TPM_INIT_ATTEMPTED                                     = 0xcacfa03,
    ATTR_TPM_ROLE                                                  = 0xb8fa011,
    ATTR_HB_TPM_MUTEX                                              = 0xeaece7d,
    ATTR_HB_TPM_LOG_MGR_PTR                                        = 0x4af8455,
    ATTR_ALLOW_ATTR_OVERRIDES_IN_SECURE_MODE                       = 0xf322cf5,
    ATTR_MEMD_OFFSET                                               = 0x2c95fa5,
    ATTR_PROC_HW_TOPOLOGY                                          = 0xa0bf6f9,
    ATTR_CHIP_VER                                                  = 0xbfe70e7,
    ATTR_HW_VER                                                    = 0xa007572,
    ATTR_SW_VER                                                    = 0x23b10ad,
    ATTR_ROLE                                                      = 0x612f998,
    ATTR_PHYP_SYSTEM_TYPE                                          = 0x02878db,
    ATTR_ASCII_VPD_LX_KEYWORD                                      = 0x1578acf,
    ATTR_ENLARGED_IO_SLOT_COUNT                                    = 0xc63ee6f,
    ATTR_CREATE_DEF_PARTITION                                      = 0x86599be,
    ATTR_IPL_ATTRIBUTES                                            = 0xe7d3a90,
    ATTR_PRESERVE_MDC_PARTITION_VPD                                = 0xce0acef,
    ATTR_HYPERVISOR_IPL_SIDE                                       = 0xa20e490,
    ATTR_OS_IPL_MODE                                               = 0xfca1112,
    ATTR_LMB_SIZE                                                  = 0xc44c3e5,
    ATTR_MAX_HSL_OPTICONNECT_CONNECTIONS                           = 0x51a0c49,
    ATTR_HUGE_PAGE_COUNT                                           = 0x1d3aaf3,
    ATTR_HUGE_PAGE_SIZE                                            = 0x05012fa,
    ATTR_VLAN_SWITCHES                                             = 0x0869a14,
    ATTR_VTPM_ENABLED                                              = 0xed71ad5,
    ATTR_HYPERVISOR_IPL_DESTINATION                                = 0x7fc67fc,
    ATTR_HYP_DISPATCH_WHEEL                                        = 0xeae5133,
    ATTR_SYSTEM_BRAND_NAME                                         = 0xfbc25fd,
    ATTR_SLCA_INDEX                                                = 0x208270e,
    ATTR_SLCA_RID                                                  = 0x8c22154,
    ATTR_OPEN_POWER_PM_MODE                                        = 0x43c995a,
    ATTR_OPEN_POWER_PM_MODE_FREQ_PERCENT                           = 0x0b9576e,
    ATTR_IPS_ENABLE                                                = 0x7c9a836,
    ATTR_IPS_ENTER_TIME_SECONDS                                    = 0x1848b5a,
    ATTR_IPS_ENTER_UTILIZATION_PERCENT                             = 0xfc7152f,
    ATTR_IPS_EXIT_TIME_SECONDS                                     = 0x8442c0a,
    ATTR_IPS_EXIT_UTILIZATION_PERCENT                              = 0x73786d2,
    ATTR_ADC_CHANNEL_FUNC_IDS                                      = 0xba49a18,
    ATTR_ADC_CHANNEL_SENSOR_NUMBERS                                = 0xab26dbf,
    ATTR_ADC_CHANNEL_GNDS                                          = 0x33234bf,
    ATTR_ADC_CHANNEL_GAINS                                         = 0x0fc9882,
    ATTR_ADC_CHANNEL_OFFSETS                                       = 0xc789762,
    ATTR_APSS_GPIO_PORT_MODES                                      = 0x227fe0f,
    ATTR_APSS_GPIO_PORT_PINS                                       = 0x414575c,
    ATTR_GPIO_INFO                                                 = 0x1d74d8f,
    ATTR_HDAT_I2C_ENGINE                                           = 0xc9759f9,
    ATTR_HDAT_I2C_MASTER_PORT                                      = 0xff9735d,
    ATTR_HDAT_I2C_DEVICE_TYPE                                      = 0x7b92047,
    ATTR_HDAT_I2C_ADDR                                             = 0x96086e6,
    ATTR_HDAT_I2C_SLAVE_PORT                                       = 0x7f9e3fe,
    ATTR_HDAT_I2C_BUS_FREQ                                         = 0xf503383,
    ATTR_HDAT_I2C_DEVICE_PURPOSE                                   = 0x89bd966,
    ATTR_HDAT_I2C_DEVICE_LABEL                                     = 0x0c075a9,
    ATTR_HDAT_I2C_ELEMENTS                                         = 0x950f081,
    ATTR_IPMI_INSTANCE                                             = 0x18dd55a,
    ATTR_IPMI_SENSORS                                              = 0x00bf09b,
    ATTR_GPU_SENSORS                                               = 0xa9da15c,
    ATTR_OP_TRACE_LITE                                             = 0xdf0d4d9,
    ATTR_OPEN_POWER_DIMM_THROTTLE_TEMP_DEG_C                       = 0xf807c26,
    ATTR_OPEN_POWER_DIMM_ERROR_TEMP_DEG_C                          = 0x0a5db3f,
    ATTR_OPEN_POWER_MEMCTRL_THROTTLE_TEMP_DEG_C                    = 0xf6c06bc,
    ATTR_OPEN_POWER_PROC_WEIGHT                                    = 0x7f74e9a,
    ATTR_OPEN_POWER_QUAD_WEIGHT                                    = 0x68dc009,
    ATTR_OPEN_POWER_PROC_DVFS_TEMP_DEG_C                           = 0x7bfa790,
    ATTR_OPEN_POWER_MEMCTRL_ERROR_TEMP_DEG_C                       = 0xf3cfe74,
    ATTR_OPEN_POWER_N_BULK_POWER_LIMIT_WATTS                       = 0xfc2cace,
    ATTR_OPEN_POWER_N_MAX_MEM_POWER_WATTS                          = 0x0516ed5,
    ATTR_MISC_SYSTEM_COMPONENTS_MAX_POWER_WATTS                    = 0xe1ec481,
    ATTR_OPEN_POWER_MEMCTRL_READ_TIMEOUT_SEC                       = 0x274740e,
    ATTR_OPEN_POWER_DIMM_READ_TIMEOUT_SEC                          = 0x67b8922,
    ATTR_OPEN_POWER_PROC_ERROR_TEMP_DEG_C                          = 0x2e2c7e3,
    ATTR_OPEN_POWER_MIN_MEM_UTILIZATION_THROTTLING                 = 0xdb523f2,
    ATTR_OPEN_POWER_MIN_MEM_UTILIZATION_POWER_CAP                  = 0x8520d57,
    ATTR_OPEN_POWER_VRM_READ_TIMEOUT_SEC                           = 0x1dd9c8c,
    ATTR_OPEN_POWER_PROC_READ_TIMEOUT_SEC                          = 0xe974923,
    ATTR_OPEN_POWER_REGULATOR_EFFICIENCY_FACTOR                    = 0x78f38ad,
    ATTR_OPEN_POWER_MIN_POWER_CAP_WATTS                            = 0xaa6708b,
    ATTR_OPEN_POWER_SOFT_MIN_PCAP_WATTS                            = 0x50ee64a,
    ATTR_OPEN_POWER_N_PLUS_ONE_BULK_POWER_LIMIT_WATTS              = 0xafb435e,
    ATTR_OPEN_POWER_N_PLUS_ONE_HPC_BULK_POWER_LIMIT_WATTS          = 0x10e7fdc,
    ATTR_OPEN_POWER_N_PLUS_ONE_MAX_MEM_POWER_WATTS                 = 0x6255aa9,
    ATTR_OPEN_POWER_TURBO_MODE_SUPPORTED                           = 0x54a5bff,
    ATTR_OPEN_POWER_GPU_READ_TIMEOUT_SEC                           = 0x8bd632f,
    ATTR_OPEN_POWER_GPU_ERROR_TEMP_DEG_C                           = 0xec9f6e2,
    ATTR_OPEN_POWER_GPU_MEM_READ_TIMEOUT_SEC                       = 0x31f54e9,
    ATTR_OPEN_POWER_GPU_MEM_ERROR_TEMP_DEG_C                       = 0xb081544,
    ATTR_OPAL_MODEL                                                = 0x0294b5a,
    ATTR_IPMI_MAX_BUFFER_SIZE                                      = 0x330c475,
    ATTR_BMC_MANUFACTURER                                          = 0x4724ab2,
    ATTR_BMC_HW_CHIP_TYPE                                          = 0x47f127d,
    ATTR_BMC_SW_TYPE                                               = 0x7cc5a7f,
    ATTR_HTMGT_SAFEMODE                                            = 0x094cab6,
    ATTR_PSTATE_TABLE                                              = 0x05d02a2,
    ATTR_PSTATE_TABLE_MFG                                          = 0xe98cfd9,
    ATTR_OCC_CONTROL_DATA                                          = 0x509d68e,
    ATTR_HTMGT_INTERNAL_FLAGS                                      = 0x35e1cdc,
    ATTR_OT_MIN_N_PER_MBA                                          = 0xf0b99dd,
    ATTR_OT_MEM_POWER                                              = 0x7135301,
    ATTR_N_PLUS_ONE_N_PER_MBA                                      = 0xb6f988e,
    ATTR_N_PLUS_ONE_N_PER_CHIP                                     = 0x7608aec,
    ATTR_N_PLUS_ONE_MEM_POWER                                      = 0x1e51d61,
    ATTR_OVERSUB_N_PER_MBA                                         = 0x473cd82,
    ATTR_OVERSUB_N_PER_CHIP                                        = 0x654dbfc,
    ATTR_OVERSUB_MEM_POWER                                         = 0xcfaaa85,
    ATTR_POWERCAP_N_PER_MBA                                        = 0xdee75dc,
    ATTR_POWERCAP_N_PER_CHIP                                       = 0x7e48fe8,
    ATTR_POWERCAP_MEM_POWER                                        = 0x97e3c37,
    ATTR_CALCULATED_MAX_SYS_POWER_EXCLUDING_GPUS                   = 0xbe4ab2c,
    ATTR_CALCULATED_PROC_MEMORY_POWER_DROP                         = 0xd1862ee,
    ATTR_MRW_SAFEMODE_MEM_THROTTLE_NUMERATOR_PER_CHIP              = 0x5cf8e48,
    ATTR_MSS_UTIL_N_PER_MBA                                        = 0xb2ffe8c,
};

/**
 *  @brief Specify the system policy to enforce synchronous mode between
 *	memory and nest. This drives the value of ATTR_MEM_IN_SYNCH_MODE.
 *	UNDETERMINED : Run synchronously if the dimm and nest freq matches
 *	ALWAYS : Require matching frequencies and deconfigure memory that
 *	does not match the nest NEVER : Do not run synchronously, even if
 *	the frequencies match
 */
enum REQUIRED_SYNCH_MODE
{
    REQUIRED_SYNCH_MODE_UNDETERMINED                               = 0x00000000,
    REQUIRED_SYNCH_MODE_ALWAYS                                     = 0x00000001,
    REQUIRED_SYNCH_MODE_NEVER                                      = 0x00000002,
};

/**
 *  @brief FOR LAB USE ONLY: Frequency override of this memory channel in
 *	MT/s comprising of up to three DIMMs. Set by config file or an
 *	attribute writing program. Consumed by mss_freq. The default of
 *	AUTO means mss_freq will find the best frequencies given the DIMMs
 *	plugged in and other rules. Otherwise, this is the system
 *	frequency.
 */
enum MSS_FREQ_OVERRIDE
{
    MSS_FREQ_OVERRIDE_AUTO                                         = 0x00000000,
};

/**
 *  @brief Frequency of this memory channel in MT/s (Mega Transfers per
 *	second), comprising of three DIMMs. Computed in mss_freq creator:
 *	mss_freq consumer: mss_eff_cnfg, others firmware notes: none
 */
enum MSS_FREQ
{
    MSS_FREQ_MT1866                                                = 0x0000074A,
    MSS_FREQ_MT2133                                                = 0x00000855,
    MSS_FREQ_MT2400                                                = 0x00000960,
    MSS_FREQ_MT2666                                                = 0x00000A6A,
};

/**
 *  @brief Spare DRAM availability. Used in various locations and is
 *	computed in mss_eff_cnfg. creator: mss_eff_cnfg consumer: various
 *	firmware notes: load from spd OBSOLETE: Use ATTR_VPD_DIMM_SPARE
 */
enum EFF_DIMM_SPARE
{
    EFF_DIMM_SPARE_NO_SPARE                                        = 0x00000000,
    EFF_DIMM_SPARE_LOW_NIBBLE                                      = 0x00000001,
    EFF_DIMM_SPARE_HIGH_NIBBLE                                     = 0x00000002,
    EFF_DIMM_SPARE_FULL_BYTE                                       = 0x00000003,
};

/**
 *  @brief DRAM Write Vref. Used in various locations and comes from the MT
 *	keyword of the VPD or is computed in mss_eff_cnfg_termination.
 *	creator: VPD(MT) or mss_eff_cnfg_termination consumer: various.C
 *	and initfile firmware notes: none This is the nominal value This is
 *	for DDR3
 */
enum EFF_DRAM_WR_VREF
{
    EFF_DRAM_WR_VREF_VDD420                                        = 0x000001A4,
    EFF_DRAM_WR_VREF_VDD425                                        = 0x000001A9,
    EFF_DRAM_WR_VREF_VDD430                                        = 0x000001AE,
    EFF_DRAM_WR_VREF_VDD435                                        = 0x000001B3,
    EFF_DRAM_WR_VREF_VDD440                                        = 0x000001B8,
    EFF_DRAM_WR_VREF_VDD445                                        = 0x000001BD,
    EFF_DRAM_WR_VREF_VDD450                                        = 0x000001C2,
    EFF_DRAM_WR_VREF_VDD455                                        = 0x000001C7,
    EFF_DRAM_WR_VREF_VDD460                                        = 0x000001CC,
    EFF_DRAM_WR_VREF_VDD465                                        = 0x000001D1,
    EFF_DRAM_WR_VREF_VDD470                                        = 0x000001D6,
    EFF_DRAM_WR_VREF_VDD475                                        = 0x000001DB,
    EFF_DRAM_WR_VREF_VDD480                                        = 0x000001E0,
    EFF_DRAM_WR_VREF_VDD485                                        = 0x000001E5,
    EFF_DRAM_WR_VREF_VDD490                                        = 0x000001EA,
    EFF_DRAM_WR_VREF_VDD495                                        = 0x000001EF,
    EFF_DRAM_WR_VREF_VDD500                                        = 0x000001F4,
    EFF_DRAM_WR_VREF_VDD505                                        = 0x000001F9,
    EFF_DRAM_WR_VREF_VDD510                                        = 0x000001FE,
    EFF_DRAM_WR_VREF_VDD515                                        = 0x00000203,
    EFF_DRAM_WR_VREF_VDD520                                        = 0x00000208,
    EFF_DRAM_WR_VREF_VDD525                                        = 0x0000020D,
    EFF_DRAM_WR_VREF_VDD530                                        = 0x00000212,
    EFF_DRAM_WR_VREF_VDD535                                        = 0x00000217,
    EFF_DRAM_WR_VREF_VDD540                                        = 0x0000021C,
    EFF_DRAM_WR_VREF_VDD545                                        = 0x00000221,
    EFF_DRAM_WR_VREF_VDD550                                        = 0x00000226,
    EFF_DRAM_WR_VREF_VDD555                                        = 0x0000022B,
    EFF_DRAM_WR_VREF_VDD560                                        = 0x00000230,
    EFF_DRAM_WR_VREF_VDD565                                        = 0x00000235,
    EFF_DRAM_WR_VREF_VDD570                                        = 0x0000023A,
    EFF_DRAM_WR_VREF_VDD575                                        = 0x0000023F,
};

/**
 *  @brief DIMM Size, in GB Used in various locations and is computed in
 *	mss_eff_cnfg.
 */
enum EFF_DIMM_SIZE
{
    EFF_DIMM_SIZE_4GB                                              = 0x00000004,
    EFF_DIMM_SIZE_8GB                                              = 0x00000008,
    EFF_DIMM_SIZE_16GB                                             = 0x00000010,
    EFF_DIMM_SIZE_32GB                                             = 0x00000020,
    EFF_DIMM_SIZE_64GB                                             = 0x00000040,
    EFF_DIMM_SIZE_128GB                                            = 0x00000080,
    EFF_DIMM_SIZE_256GB                                            = 0x00000100,
    EFF_DIMM_SIZE_512GB                                            = 0x00000200,
};

/**
 *  @brief Additive Latency. Used in various locations and is computed in
 *	mss_eff_cnfg_timing. Each memory channel will have a value.
 *	creator: mss_eff_cnfg_timing consumer: various firmware notes: none
 */
enum EFF_DRAM_AL
{
    EFF_DRAM_AL_DISABLE                                            = 0x00000000,
    EFF_DRAM_AL_CL_MINUS_1                                         = 0x00000001,
    EFF_DRAM_AL_CL_MINUS_2                                         = 0x00000002,
};

/**
 *  @brief Read Burst Type. Used in various locations and is computed in
 *	mss_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum EFF_DRAM_RBT
{
    EFF_DRAM_RBT_SEQUENTIAL                                        = 0x00000000,
    EFF_DRAM_RBT_INTERLEAVE                                        = 0x00000001,
};

/**
 *  @brief Test Mode. Used in various locations and is computed in
 *	mss_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum EFF_DRAM_TM
{
    EFF_DRAM_TM_NORMAL                                             = 0x00000000,
    EFF_DRAM_TM_TEST                                               = 0x00000001,
};

/**
 *  @brief DLL Reset. Used in various locations and is computed in
 *	mss_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum EFF_DRAM_DLL_RESET
{
    EFF_DRAM_DLL_RESET_NO                                          = 0x00000000,
    EFF_DRAM_DLL_RESET_YES                                         = 0x00000001,
};

/**
 *  @brief DLL Precharge PD. Used in various locations and is computed in
 *	mss_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum EFF_DRAM_DLL_PPD
{
    EFF_DRAM_DLL_PPD_SLOWEXIT                                      = 0x00000000,
    EFF_DRAM_DLL_PPD_FASTEXIT                                      = 0x00000001,
};

/**
 *  @brief DLL Enable. Used in various locations and is computed in
 *	mss_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum EFF_DRAM_DLL_ENABLE
{
    EFF_DRAM_DLL_ENABLE_YES                                        = 0x00000001,
    EFF_DRAM_DLL_ENABLE_NO                                         = 0x00000000,
};

/**
 *  @brief Write Level Enable. Used in various locations and is computed in
 *	mss_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum EFF_DRAM_WR_LVL_ENABLE
{
    EFF_DRAM_WR_LVL_ENABLE_DISABLE                                 = 0x00000000,
    EFF_DRAM_WR_LVL_ENABLE_ENABLE                                  = 0x00000001,
};

/**
 *  @brief DRAM Qoff. Enables or disables DRAM output. Used in various
 *	locations and is computed in mss_eff_cnfg. Each memory channel will
 *	have a value. creator: mss_eff_cnfg consumer: various firmware
 *	notes: none
 */
enum EFF_DRAM_OUTPUT_BUFFER
{
    EFF_DRAM_OUTPUT_BUFFER_ENABLE                                  = 0x00000000,
    EFF_DRAM_OUTPUT_BUFFER_DISABLE                                 = 0x00000001,
};

/**
 *  @brief Partial Array Self-Refresh. Used in various locations and is
 *	computed in mss_eff_cnfg. Each memory channel will have a value.
 *	creator: mss_eff_cnfg consumer: various firmware notes: none
 */
enum EFF_DRAM_PASR
{
    EFF_DRAM_PASR_FULL                                             = 0x00000000,
    EFF_DRAM_PASR_FIRST_HALF                                       = 0x00000001,
    EFF_DRAM_PASR_FIRST_QUARTER                                    = 0x00000002,
    EFF_DRAM_PASR_FIRST_EIGHTH                                     = 0x00000003,
    EFF_DRAM_PASR_LAST_THREE_FOURTH                                = 0x00000004,
    EFF_DRAM_PASR_LAST_HALF                                        = 0x00000005,
    EFF_DRAM_PASR_LAST_QUARTER                                     = 0x00000006,
    EFF_DRAM_PASR_LAST_EIGHTH                                      = 0x00000007,
};

/**
 *  @brief Auto Self-Refresh. Used in various locations and is computed in
 *	mss_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum EFF_DRAM_ASR
{
    EFF_DRAM_ASR_SRT                                               = 0x00000000,
    EFF_DRAM_ASR_ASR                                               = 0x00000001,
};

/**
 *  @brief Self-Refresh Temperature Range. Used in various locations and is
 *	computed in mss_eff_cnfg. Each memory channel will have a value.
 *	creator: mss_eff_cnfg consumer: various firmware notes: none
 */
enum EFF_DRAM_SRT
{
    EFF_DRAM_SRT_NORMAL                                            = 0x00000000,
    EFF_DRAM_SRT_EXTEND                                            = 0x00000001,
};

/**
 *  @brief Multi Purpose Register Mode. Used in various locations and is
 *	computed in mss_eff_cnfg. Each memory channel will have a value.
 *	creator: mss_eff_cnfg consumer: various firmware notes: none
 */
enum EFF_MPR_MODE
{
    EFF_MPR_MODE_DISABLE                                           = 0x00000000,
    EFF_MPR_MODE_ENABLE                                            = 0x00000001,
};

/**
 *  @brief RCD Mirroring. Used in mss_dram_init and is computed in
 *	mss_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: mss_dram_init firmware notes: none
 */
enum EFF_DIMM_RCD_MIRROR_MODE
{
    EFF_DIMM_RCD_MIRROR_MODE_OFF                                   = 0x00000000,
    EFF_DIMM_RCD_MIRROR_MODE_ON                                    = 0x00000001,
};

/**
 *  @brief Specifies the schmoo mode to use during draminit_train_adv.
 */
enum EFF_SCHMOO_MODE
{
    EFF_SCHMOO_MODE_FAST                                           = 0x00000000,
    EFF_SCHMOO_MODE_ONE_SLOW                                       = 0x00000001,
    EFF_SCHMOO_MODE_QUARTER_SLOW                                   = 0x00000002,
    EFF_SCHMOO_MODE_HALF_SLOW                                      = 0x00000003,
    EFF_SCHMOO_MODE_FULL_SLOW                                      = 0x00000004,
    EFF_SCHMOO_MODE_ONE_CHAR                                       = 0x00000005,
    EFF_SCHMOO_MODE_QUARTER_CHAR                                   = 0x00000006,
    EFF_SCHMOO_MODE_HALF_CHAR                                      = 0x00000007,
    EFF_SCHMOO_MODE_FULL_CHAR                                      = 0x00000008,
};

/**
 *  @brief Specifies the schmoo mode to use during draminit_train_adv
 */
enum EFF_SCHMOO_ADDR_MODE
{
    EFF_SCHMOO_ADDR_MODE_FEW_ADDR                                  = 0x00000000,
    EFF_SCHMOO_ADDR_MODE_QUARTER_ADDR                              = 0x00000001,
    EFF_SCHMOO_ADDR_MODE_HALF_ADDR                                 = 0x00000002,
    EFF_SCHMOO_ADDR_MODE_FULL_ADDR                                 = 0x00000003,
};

/**
 *  @brief Specifies the schmoo test to run during draminit_train_adv. Bit
 *	wise.
 */
enum EFF_SCHMOO_TEST_VALID
{
    EFF_SCHMOO_TEST_VALID_NONE                                     = 0x00000000,
    EFF_SCHMOO_TEST_VALID_MCBIST                                   = 0x00000001,
    EFF_SCHMOO_TEST_VALID_WR_EYE                                   = 0x00000002,
    EFF_SCHMOO_TEST_VALID_RD_EYE                                   = 0x00000004,
    EFF_SCHMOO_TEST_VALID_WR_DQS                                   = 0x00000008,
    EFF_SCHMOO_TEST_VALID_RD_DQS                                   = 0x00000010,
};

/**
 *  @brief Specifies the schmoo parameters to use during
 *	draminit_train_adv. Bit wise.
 */
enum EFF_SCHMOO_PARAM_VALID
{
    EFF_SCHMOO_PARAM_VALID_PARAM_NONE                              = 0x00000000,
    EFF_SCHMOO_PARAM_VALID_DELAY_REG                               = 0x00000001,
    EFF_SCHMOO_PARAM_VALID_DRV_IMP                                 = 0x00000002,
    EFF_SCHMOO_PARAM_VALID_SLEW_RATE                               = 0x00000004,
    EFF_SCHMOO_PARAM_VALID_WR_VREF                                 = 0x00000008,
    EFF_SCHMOO_PARAM_VALID_RD_VREF                                 = 0x00000010,
    EFF_SCHMOO_PARAM_VALID_RCV_IMP                                 = 0x00000020,
};

/**
 *  @brief Specifies the memcal interval in clocks.
 */
enum EFF_MEMCAL_INTERVAL
{
    EFF_MEMCAL_INTERVAL_DISABLE                                    = 0x00000000,
};

/**
 *  @brief Specifies the zqcal interval in clocks.
 */
enum EFF_ZQCAL_INTERVAL
{
    EFF_ZQCAL_INTERVAL_DISABLE                                     = 0x00000000,
};

/**
 *  @brief Specifies the memory topology type. See centaur workbook.
 */
enum EFF_IBM_TYPE
{
    EFF_IBM_TYPE_UNDEFINED                                         = 0x00000000,
    EFF_IBM_TYPE_TYPE_1A                                           = 0x00000001,
    EFF_IBM_TYPE_TYPE_1B                                           = 0x00000002,
    EFF_IBM_TYPE_TYPE_1C                                           = 0x00000003,
    EFF_IBM_TYPE_TYPE_1D                                           = 0x00000004,
    EFF_IBM_TYPE_TYPE_2A                                           = 0x00000005,
    EFF_IBM_TYPE_TYPE_2B                                           = 0x00000006,
    EFF_IBM_TYPE_TYPE_2C                                           = 0x00000007,
    EFF_IBM_TYPE_TYPE_3A                                           = 0x00000008,
    EFF_IBM_TYPE_TYPE_3B                                           = 0x00000009,
    EFF_IBM_TYPE_TYPE_3C                                           = 0x0000000A,
    EFF_IBM_TYPE_TYPE_4A                                           = 0x0000000B,
    EFF_IBM_TYPE_TYPE_4B                                           = 0x0000000C,
    EFF_IBM_TYPE_TYPE_4C                                           = 0x0000000D,
    EFF_IBM_TYPE_TYPE_5A                                           = 0x0000000E,
    EFF_IBM_TYPE_TYPE_5B                                           = 0x0000000F,
    EFF_IBM_TYPE_TYPE_5C                                           = 0x00000010,
    EFF_IBM_TYPE_TYPE_5D                                           = 0x00000011,
    EFF_IBM_TYPE_TYPE_6A                                           = 0x00000012,
    EFF_IBM_TYPE_TYPE_6B                                           = 0x00000013,
    EFF_IBM_TYPE_TYPE_6C                                           = 0x00000014,
    EFF_IBM_TYPE_TYPE_7A                                           = 0x00000015,
    EFF_IBM_TYPE_TYPE_7B                                           = 0x00000016,
    EFF_IBM_TYPE_TYPE_7C                                           = 0x00000017,
    EFF_IBM_TYPE_TYPE_8A                                           = 0x00000018,
    EFF_IBM_TYPE_TYPE_8B                                           = 0x00000019,
    EFF_IBM_TYPE_TYPE_8C                                           = 0x0000001A,
};

/**
 *  @brief Specifies the number of master ranks per DIMM. Represents the
 *	number of physical ranks on a DIMM. From SPD spec JEDEC Standard
 *	No. 21-C: Page 4.1.2.L-4. Byte 12 (Bits 5~3) Number of package
 *	ranks per DIMM. Package ranks per DIMM refers to the collections of
 *	devices on the module sharing common chip select signals.
 */
enum EFF_NUM_MASTER_RANKS_PER_DIMM
{
    EFF_NUM_MASTER_RANKS_PER_DIMM_1R                               = 0x00000001,
    EFF_NUM_MASTER_RANKS_PER_DIMM_2R                               = 0x00000002,
    EFF_NUM_MASTER_RANKS_PER_DIMM_4R                               = 0x00000004,
    EFF_NUM_MASTER_RANKS_PER_DIMM_8R                               = 0x00000008,
};

/**
 *  @brief Low Power Auto Self-Refresh. This is for DDR4 MRS2. Computed in
 *	mss_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum EFF_DRAM_LPASR
{
    EFF_DRAM_LPASR_MANUAL_NORMAL                                   = 0x00000000,
    EFF_DRAM_LPASR_MANUAL_REDUCED                                  = 0x00000001,
    EFF_DRAM_LPASR_MANUAL_EXTENDED                                 = 0x00000002,
    EFF_DRAM_LPASR_ASR                                             = 0x00000003,
};

/**
 *  @brief MPR Page Selection This is for DDR4 MRS3. Computed in
 *	mss_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum EFF_MPR_PAGE
{
    EFF_MPR_PAGE_PG0                                               = 0x00000000,
    EFF_MPR_PAGE_PG1                                               = 0x00000001,
    EFF_MPR_PAGE_PG2                                               = 0x00000002,
    EFF_MPR_PAGE_PG3                                               = 0x00000003,
};

/**
 *  @brief Gear Down Mode. This is for DDR4 MRS3. Computed in mss_eff_cnfg.
 *	Each memory channel will have a value. creator: mss_eff_cnfg
 *	consumer: various firmware notes: none
 */
enum EFF_GEARDOWN_MODE
{
    EFF_GEARDOWN_MODE_HALF                                         = 0x00000000,
    EFF_GEARDOWN_MODE_QUARTER                                      = 0x00000001,
};

/**
 *  @brief Per DRAM accessibility. This is for DDR4 MRS3. Computed in
 *	mss_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum EFF_PER_DRAM_ACCESS
{
    EFF_PER_DRAM_ACCESS_DISABLE                                    = 0x00000000,
    EFF_PER_DRAM_ACCESS_ENABLE                                     = 0x00000001,
};

/**
 *  @brief Temperature sensor readout. This is for DDR4 MRS3. Computed in
 *	mss_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum EFF_TEMP_READOUT
{
    EFF_TEMP_READOUT_DISABLE                                       = 0x00000000,
    EFF_TEMP_READOUT_ENABLE                                        = 0x00000001,
};

/**
 *  @brief write latency for CRC and DM. This is for DDR4 MRS3. Computed in
 *	mss_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum EFF_CRC_WR_LATENCY
{
    EFF_CRC_WR_LATENCY_4NCK                                        = 0x00000004,
    EFF_CRC_WR_LATENCY_5NCK                                        = 0x00000005,
    EFF_CRC_WR_LATENCY_6NCK                                        = 0x00000006,
};

/**
 *  @brief MPR READ FORMAT. This is for DDR4 MRS3. Computed in
 *	mss_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum EFF_MPR_RD_FORMAT
{
    EFF_MPR_RD_FORMAT_SERIAL                                       = 0x00000000,
    EFF_MPR_RD_FORMAT_PARALLEL                                     = 0x00000001,
    EFF_MPR_RD_FORMAT_STAGGERED                                    = 0x00000002,
};

/**
 *  @brief Max Power down mode. This is for DDR4 MRS4. Computed in
 *	mss_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum EFF_MAX_POWERDOWN_MODE
{
    EFF_MAX_POWERDOWN_MODE_DISABLE                                 = 0x00000000,
    EFF_MAX_POWERDOWN_MODE_ENABLE                                  = 0x00000001,
};

/**
 *  @brief Internal Vref Monitor. This is for DDR4 MRS4. Computed in
 *	mss_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum EFF_INTERNAL_VREF_MONITOR
{
    EFF_INTERNAL_VREF_MONITOR_DISABLE                              = 0x00000000,
    EFF_INTERNAL_VREF_MONITOR_ENABLE                               = 0x00000001,
};

/**
 *  @brief CS to CMD/ADDR Latency. This is for DDR4 MRS4. Computed in
 *	mss_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum EFF_CS_CMD_LATENCY
{
    EFF_CS_CMD_LATENCY_DISABLE                                     = 0x00000000,
    EFF_CS_CMD_LATENCY_3CYC                                        = 0x00000003,
    EFF_CS_CMD_LATENCY_4CYC                                        = 0x00000004,
    EFF_CS_CMD_LATENCY_5CYC                                        = 0x00000005,
    EFF_CS_CMD_LATENCY_6CYC                                        = 0x00000006,
    EFF_CS_CMD_LATENCY_8CYC                                        = 0x00000008,
};

/**
 *  @brief Self Refresh Abort. This is for DDR4 MRS4. Computed in
 *	mss_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum EFF_SELF_REF_ABORT
{
    EFF_SELF_REF_ABORT_DISABLE                                     = 0x00000000,
    EFF_SELF_REF_ABORT_ENABLE                                      = 0x00000001,
};

/**
 *  @brief Read Pre amble Training Mode. This is for DDR4 MRS4. Computed in
 *	mss_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum EFF_RD_PREAMBLE_TRAIN
{
    EFF_RD_PREAMBLE_TRAIN_DISABLE                                  = 0x00000000,
    EFF_RD_PREAMBLE_TRAIN_ENABLE                                   = 0x00000001,
};

/**
 *  @brief Read Pre amble. This is for DDR4 MRS4. Computed in mss_eff_cnfg.
 *	Each memory channel will have a value. creator: mss_eff_cnfg
 *	consumer: various firmware notes: none
 */
enum EFF_RD_PREAMBLE
{
    EFF_RD_PREAMBLE_1NCLK                                          = 0x00000000,
    EFF_RD_PREAMBLE_2NCLK                                          = 0x00000001,
};

/**
 *  @brief Write Pre amble. This is for DDR4 MRS4. Computed in
 *	mss_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum EFF_WR_PREAMBLE
{
    EFF_WR_PREAMBLE_1NCLK                                          = 0x00000000,
    EFF_WR_PREAMBLE_2NCLK                                          = 0x00000001,
};

/**
 *  @brief C/A Parity Latency Mode. This is for DDR4 MRS5. Computed in
 *	mss_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum EFF_CA_PARITY_LATENCY
{
    EFF_CA_PARITY_LATENCY_DISABLE                                  = 0x00000000,
    EFF_CA_PARITY_LATENCY_PL4                                      = 0x00000004,
    EFF_CA_PARITY_LATENCY_PL5                                      = 0x00000005,
    EFF_CA_PARITY_LATENCY_PL6                                      = 0x00000006,
    EFF_CA_PARITY_LATENCY_PL8                                      = 0x00000008,
};

/**
 *  @brief CRC Error Clear. This is for DDR4 MRS5. Computed in
 *	mss_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum EFF_CRC_ERROR_CLEAR
{
    EFF_CRC_ERROR_CLEAR_CLEAR                                      = 0x00000000,
    EFF_CRC_ERROR_CLEAR_ERROR                                      = 0x00000001,
};

/**
 *  @brief C/A Parity Error Status. This is for DDR4 MRS5. Computed in
 *	mss_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum EFF_CA_PARITY_ERROR_STATUS
{
    EFF_CA_PARITY_ERROR_STATUS_CLEAR                               = 0x00000000,
    EFF_CA_PARITY_ERROR_STATUS_ERROR                               = 0x00000001,
};

/**
 *  @brief ODT Input Buffer during power down. This is for DDR4 MRS5.
 *	Computed in mss_eff_cnfg. Each memory channel will have a value.
 *	creator: mss_eff_cnfg consumer: various firmware notes: none
 */
enum EFF_ODT_INPUT_BUFF
{
    EFF_ODT_INPUT_BUFF_ACTIVATED                                   = 0x00000000,
    EFF_ODT_INPUT_BUFF_DEACTIVATED                                 = 0x00000001,
};

/**
 *  @brief CA Parity Persistance Error. This is for DDR4 MRS5. Computed in
 *	mss_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum EFF_CA_PARITY
{
    EFF_CA_PARITY_DISABLE                                          = 0x00000000,
    EFF_CA_PARITY_ENABLE                                           = 0x00000001,
};

/**
 *  @brief Data Mask. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each
 *	memory channel will have a value. creator: mss_eff_cnfg consumer:
 *	various firmware notes: none
 */
enum EFF_DATA_MASK
{
    EFF_DATA_MASK_DISABLE                                          = 0x00000000,
    EFF_DATA_MASK_ENABLE                                           = 0x00000001,
};

/**
 *  @brief Write DBI. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each
 *	memory channel will have a value. creator: mss_eff_cnfg consumer:
 *	various firmware notes: none
 */
enum EFF_WRITE_DBI
{
    EFF_WRITE_DBI_DISABLE                                          = 0x00000000,
    EFF_WRITE_DBI_ENABLE                                           = 0x00000001,
};

/**
 *  @brief Read DBI. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each
 *	memory channel will have a value. creator: mss_eff_cnfg consumer:
 *	various firmware notes: none
 */
enum EFF_READ_DBI
{
    EFF_READ_DBI_DISABLE                                           = 0x00000000,
    EFF_READ_DBI_ENABLE                                            = 0x00000001,
};

/**
 *  @brief vrefdq_train range. This is for DDR4 MRS6. Computed in
 *	mss_eff_cnfg. Each memory channel will have a value. Creator:
 *	mss_eff_cnfg Consumer:various Firmware notes: none
 */
enum EFF_VREF_DQ_TRAIN_RANGE
{
    EFF_VREF_DQ_TRAIN_RANGE_RANGE1                                 = 0x00000000,
    EFF_VREF_DQ_TRAIN_RANGE_RANGE2                                 = 0x00000001,
};

/**
 *  @brief vrefdq_train enable. This is for DDR4 MRS6. Computed in
 *	mss_eff_cnfg. Each memory channel will have a value. Creator:
 *	mss_eff_cnfg Consumer:various Firmware notes: none
 */
enum EFF_VREF_DQ_TRAIN_ENABLE
{
    EFF_VREF_DQ_TRAIN_ENABLE_DISABLE                               = 0x00000000,
    EFF_VREF_DQ_TRAIN_ENABLE_ENABLE                                = 0x00000001,
};

/**
 *  @brief Write CRC control for DDR4 in MRS2. Set in mss_eff_cnfg. Each
 *	memory channel will have a value. Creator: mss_eff_cnfg
 *	Consumer:various Firmware notes: none
 */
enum EFF_WRITE_CRC
{
    EFF_WRITE_CRC_DISABLE                                          = 0x00000000,
    EFF_WRITE_CRC_ENABLE                                           = 0x00000001,
};

/**
 *  @brief Special training pattern used in draminit_training_advance. Used
 *	for custom pattern write There can be two patterns used here. This
 *	attribute is before swizzling for endianness of the registers. CODE
 *	WILL SWIZZLE FOR THE SYSTEM The first 0-15 bits are for PATTERN0,
 *	bits 16-32 are for PATTERN1. If this attribute is set to 0, using
 *	the default values of: 0x13EC for PATTERN0 0x02FD for PATTERN1 Set
 *	to default in eff_config
 */
enum MSS_CUSTOM_TRAINING_ADV_PATTERNS
{
    MSS_CUSTOM_TRAINING_ADV_PATTERNS_DEFAULT_PATTERN0              = 0x0000EA0C,
    MSS_CUSTOM_TRAINING_ADV_PATTERNS_DEFAULT_PATTERN1              = 0x0000A6C9,
};

/**
 *  @brief Special training backup pattern Used for custom_pattern_write in
 *	draminit_training_advance. If the main patterns fail, the code will
 *	try running this pattern Used for read centering There can be two
 *	patterns used here. This attribute is before swizzling for
 *	endianness of the registers. CODE WILL SWIZZLE FOR THE SYSTEM The
 *	first 0-15 bits are for PATTERN0, bits 16-32 are for PATTERN1. If
 *	this attribute is set to 0, using the default values of: 0xEA0C for
 *	PATTERN0 0xA6C9 for PATTERN1 Set to default in eff_config
 */
enum MSS_CUSTOM_TRAINING_ADV_BACKUP_PATTERNS
{
    MSS_CUSTOM_TRAINING_ADV_BACKUP_PATTERNS_DEFAULT_PATTERN0       = 0x000013EC,
    MSS_CUSTOM_TRAINING_ADV_BACKUP_PATTERNS_DEFAULT_PATTERN1       = 0x000002FD,
};

/**
 *  @brief Whether or not to abort on the first DDR PHY calibration error.
 *	Firmware should always have this set to NO. YES can be used in the
 *	lab for troubleshooting, screening, etc.
 */
enum MSS_CAL_ABORT_ON_ERROR
{
    MSS_CAL_ABORT_ON_ERROR_NO                                      = 0x00000000,
    MSS_CAL_ABORT_ON_ERROR_YES                                     = 0x00000001,
};

/**
 *  @brief LRDIMM rank multiplication mode.
 */
enum LRDIMM_RANK_MULT_MODE
{
    LRDIMM_RANK_MULT_MODE_NORMAL                                   = 0x00000000,
    LRDIMM_RANK_MULT_MODE_2X_MULT                                  = 0x00000002,
    LRDIMM_RANK_MULT_MODE_4X_MULT                                  = 0x00000004,
};

/**
 *  @brief Possible DRAM voltage override. Firmware notes: Default should
 *	be NONE (0x00).
 */
enum MSS_VOLT_OVERRIDE
{
    MSS_VOLT_OVERRIDE_NONE                                         = 0x00000000,
    MSS_VOLT_OVERRIDE_VOLT_120                                     = 0x00000002,
};

/**
 *  @brief Possible VDDR voltage override.
 */
enum MSS_VDDR_OVERIDE_SPD
{
    MSS_VDDR_OVERIDE_SPD_NONE                                      = 0x00000000,
    MSS_VDDR_OVERIDE_SPD_VOLT_1350                                 = 0x00000001,
    MSS_VDDR_OVERIDE_SPD_VOLT_1200                                 = 0x00000002,
};

/**
 *  @brief Whether or not to override VCCD. Defaults to no.
 */
enum MSS_VCCD_OVERRIDE
{
    MSS_VCCD_OVERRIDE_NO                                           = 0x00000000,
    MSS_VCCD_OVERRIDE_YES                                          = 0x00000001,
};

/**
 *  @brief Maximum Activate Count. Used in various locations and is
 *	computed in mss_eff_cnfg. creator: mss_eff_cnfg consumer: various
 *	firmware notes: none
 */
enum EFF_DRAM_MAC
{
    EFF_DRAM_MAC_UNTESTED                                          = 0x00000000,
    EFF_DRAM_MAC_700K                                              = 0x000002BC,
    EFF_DRAM_MAC_600K                                              = 0x00000258,
    EFF_DRAM_MAC_500K                                              = 0x000001F4,
    EFF_DRAM_MAC_400K                                              = 0x00000190,
    EFF_DRAM_MAC_300K                                              = 0x0000012C,
    EFF_DRAM_MAC_200K                                              = 0x000000C8,
    EFF_DRAM_MAC_UNLIMITED                                         = 0x00000008,
};

/**
 *  @brief DRAM Ron. Used in various locations and comes from the MT
 *	keyword of the VPD OHM48 is for DDR4.
 */
enum EFF_DRAM_RON
{
    EFF_DRAM_RON_INVALID                                           = 0x00000000,
    EFF_DRAM_RON_OHM34                                             = 0x00000022,
    EFF_DRAM_RON_OHM40                                             = 0x00000028,
    EFF_DRAM_RON_OHM48                                             = 0x00000030,
};

/**
 *  @brief TDQS. Used in various locations and is computed in mss_eff_cnfg.
 *	Each memory channel will have a value. creator: mss_eff_cnfg
 *	consumer: various firmware notes: none
 */
enum EFF_DRAM_TDQS
{
    EFF_DRAM_TDQS_DISABLE                                          = 0x00000000,
    EFF_DRAM_TDQS_ENABLE                                           = 0x00000001,
};

/**
 *  @brief Set to IGNORE if you want to ignore the plug rules. Sometimes
 *	this is needed in a partial-good configuration
 */
enum MSS_IGNORE_PLUG_RULES
{
    MSS_IGNORE_PLUG_RULES_NO                                       = 0x00000000,
    MSS_IGNORE_PLUG_RULES_YES                                      = 0x00000001,
};

/**
 *  @brief Contains the settings for write/read reorder queue
 */
enum MSS_REORDER_QUEUE_SETTING
{
    MSS_REORDER_QUEUE_SETTING_REORDER                              = 0x00000000,
    MSS_REORDER_QUEUE_SETTING_FIFO                                 = 0x00000001,
};

/**
 *  @brief Set equal to 1 to disable setting of RTT_NOM to use RTT_WR
 *	values during WR_LEVEL calibration.
 */
enum MSS_RTT_NOM_OVERRIDE_DISABLE
{
    MSS_RTT_NOM_OVERRIDE_DISABLE_NO                                = 0x00000000,
    MSS_RTT_NOM_OVERRIDE_DISABLE_YES                               = 0x00000001,
};

/**
 *  @brief Controls ENABLE/DISABLE of workaround that sets the PHY
 *	sequencer to trigger refresh after draminit.
 */
enum MSS_PHY_SEQ_REFRESH
{
    MSS_PHY_SEQ_REFRESH_DISABLE                                    = 0x00000000,
    MSS_PHY_SEQ_REFRESH_ENABLE                                     = 0x00000001,
};

/**
 *  @brief Machine Readable Workbook Refresh Rate Desired refresh interval
 *	used in refresh register 0, MBAREF0Q_CFG_REFRESH_INTERVAL 7.8 us
 *	(SINGLE) 3.9 us (DOUBLE) 7.02 us (SINGLE_10_PERCENT_FASTER) 3.51 us
 *	(DOUBLE_10_PERCENT_FASTER)
 */
enum MSS_MRW_REFRESH_RATE_REQUEST
{
    MSS_MRW_REFRESH_RATE_REQUEST_DOUBLE                            = 0x00000000,
    MSS_MRW_REFRESH_RATE_REQUEST_SINGLE                            = 0x00000001,
    MSS_MRW_REFRESH_RATE_REQUEST_SINGLE_10_PERCENT_FASTER          = 0x00000002,
    MSS_MRW_REFRESH_RATE_REQUEST_DOUBLE_10_PERCENT_FASTER          = 0x00000003,
};

/**
 *  @brief Machine Readable Workbook enablement of the HWP code to adjust
 *	the VMEM regulator power limit based on number of installed DIMMs.
 */
enum MSS_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE
{
    MSS_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE_FALSE   = 0x00000000,
    MSS_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE_TRUE    = 0x00000001,
};

/**
 *  @brief Used for to determine whether to apply an offset to AVDD.
 *	Supplied by MRW.
 */
enum MSS_MRW_AVDD_OFFSET_DISABLE
{
    MSS_MRW_AVDD_OFFSET_DISABLE_DISABLE                            = 0x00000001,
    MSS_MRW_AVDD_OFFSET_DISABLE_ENABLE                             = 0x00000000,
};

/**
 *  @brief Used for to determine whether to apply an offset to VDD.
 *	Supplied by MRW.
 */
enum MSS_MRW_VDD_OFFSET_DISABLE
{
    MSS_MRW_VDD_OFFSET_DISABLE_DISABLE                             = 0x00000001,
    MSS_MRW_VDD_OFFSET_DISABLE_ENABLE                              = 0x00000000,
};

/**
 *  @brief Used for to determine whether to apply an offset to VCS.
 *	Supplied by MRW.
 */
enum MSS_MRW_VCS_OFFSET_DISABLE
{
    MSS_MRW_VCS_OFFSET_DISABLE_DISABLE                             = 0x00000001,
    MSS_MRW_VCS_OFFSET_DISABLE_ENABLE                              = 0x00000000,
};

/**
 *  @brief Used for to determine whether to apply an offset to VCS.
 *	Supplied by MRW.
 */
enum MSS_MRW_VPP_OFFSET_DISABLE
{
    MSS_MRW_VPP_OFFSET_DISABLE_DISABLE                             = 0x00000001,
    MSS_MRW_VPP_OFFSET_DISABLE_ENABLE                              = 0x00000000,
};

/**
 *  @brief Used for to determine whether to apply an offset to VDDR.
 *	Supplied by MRW.
 */
enum MSS_MRW_VDDR_OFFSET_DISABLE
{
    MSS_MRW_VDDR_OFFSET_DISABLE_DISABLE                            = 0x00000001,
    MSS_MRW_VDDR_OFFSET_DISABLE_ENABLE                             = 0x00000000,
};

/**
 *  @brief Fine refresh mode. Sets DDR4 MRS3. ZZ uses normal mode. From
 *	JEDEC DDR4 Spec 1716.78C from 07-2016 Page 47 Table 4.9.1
 */
enum MSS_MRW_FINE_REFRESH_MODE
{
    MSS_MRW_FINE_REFRESH_MODE_NORMAL                               = 0x00000000,
    MSS_MRW_FINE_REFRESH_MODE_FIXED_2X                             = 0x00000001,
    MSS_MRW_FINE_REFRESH_MODE_FIXED_4X                             = 0x00000002,
    MSS_MRW_FINE_REFRESH_MODE_FLY_2X                               = 0x00000005,
    MSS_MRW_FINE_REFRESH_MODE_FLY_4X                               = 0x00000006,
};

/**
 *  @brief Temperature refresh range. Sets DDR4 MRS4. Should be defaulted
 *	to extended range. NORMAL for running at 85 degrees C or less,
 *	EXTENDED for 95 or less degrees C Used for calculating periodic
 *	refresh intervals JEDEC DDR4 spec 1716.78C from 07-2016 page 46
 *	4.8.1
 */
enum MSS_MRW_TEMP_REFRESH_RANGE
{
    MSS_MRW_TEMP_REFRESH_RANGE_NORMAL                              = 0x00000000,
    MSS_MRW_TEMP_REFRESH_RANGE_EXTEND                              = 0x00000001,
};

/**
 *  @brief For resetting the phy delay values at the beginning of calling
 *	mss_draminit_training. YES means the vaules will be reset.
 */
enum MSS_MRW_RESET_DELAY_BEFORE_CAL
{
    MSS_MRW_RESET_DELAY_BEFORE_CAL_YES                             = 0x00000000,
    MSS_MRW_RESET_DELAY_BEFORE_CAL_NO                              = 0x00000001,
};

/**
 *  @brief Value of on or off. Determines if prefetching enabled or not.
 */
enum MSS_MRW_PREFETCH_ENABLE
{
    MSS_MRW_PREFETCH_ENABLE_ON                                     = 0x00000001,
    MSS_MRW_PREFETCH_ENABLE_OFF                                    = 0x00000000,
};

/**
 *  @brief Value of on or off. Determines if the cleaner of the L4 cache
 *	(write modified entries to memory on idle cycles) enabled or not.
 *	See chapter 7 of the Centaur Workbook.
 */
enum MSS_MRW_CLEANER_ENABLE
{
    MSS_MRW_CLEANER_ENABLE_OFF                                     = 0x00000000,
    MSS_MRW_CLEANER_ENABLE_ON                                      = 0x00000001,
};

/**
 *  @brief Allows user to manually turn on and off 2N Mode. AUTO indicates
 *	to use Signal Integrity generated setting (from VPD).
 */
enum MSS_MRW_DRAM_2N_MODE
{
    MSS_MRW_DRAM_2N_MODE_AUTO                                      = 0x00000000,
    MSS_MRW_DRAM_2N_MODE_FORCE_TO_1N_MODE                          = 0x00000001,
    MSS_MRW_DRAM_2N_MODE_FORCE_TO_2N_MODE                          = 0x00000002,
};

/**
 *  @brief List of memory frequencies supported by the current system.
 */
enum MSS_MRW_SUPPORTED_FREQ
{
    MSS_MRW_SUPPORTED_FREQ_MT1866                                  = 0x0000074A,
    MSS_MRW_SUPPORTED_FREQ_MT2133                                  = 0x00000855,
    MSS_MRW_SUPPORTED_FREQ_MT2400                                  = 0x00000960,
    MSS_MRW_SUPPORTED_FREQ_MT2666                                  = 0x00000A6A,
};

/**
 *  @brief Enables DRAM Write CRC
 */
enum MSS_MRW_DRAM_WRITE_CRC
{
    MSS_MRW_DRAM_WRITE_CRC_DISABLE                                 = 0x00000000,
    MSS_MRW_DRAM_WRITE_CRC_ENABLE                                  = 0x00000001,
};

/**
 *  @brief Register Clock Driver, Input Bus Termination for Command/Address
 *	in tens of Ohms.
 */
enum MSS_VPD_MT_DIMM_RCD_IBT_CA
{
    MSS_VPD_MT_DIMM_RCD_IBT_CA_IBT_OFF                             = 0x00000000,
    MSS_VPD_MT_DIMM_RCD_IBT_CA_IBT_100                             = 0x0000000A,
    MSS_VPD_MT_DIMM_RCD_IBT_CA_IBT_150                             = 0x0000000F,
    MSS_VPD_MT_DIMM_RCD_IBT_CA_IBT_300                             = 0x0000001E,
};

/**
 *  @brief Register Clock Driver, Input Bus Termination for Clock Enable in
 *	tens of Ohms.
 */
enum MSS_VPD_MT_DIMM_RCD_IBT_CKE
{
    MSS_VPD_MT_DIMM_RCD_IBT_CKE_IBT_OFF                            = 0x00000000,
    MSS_VPD_MT_DIMM_RCD_IBT_CKE_IBT_100                            = 0x0000000A,
    MSS_VPD_MT_DIMM_RCD_IBT_CKE_IBT_150                            = 0x0000000F,
    MSS_VPD_MT_DIMM_RCD_IBT_CKE_IBT_300                            = 0x0000001E,
};

/**
 *  @brief Register Clock Driver, Input Bus Termination for Chip Select in
 *	tens of Ohms.
 */
enum MSS_VPD_MT_DIMM_RCD_IBT_CS
{
    MSS_VPD_MT_DIMM_RCD_IBT_CS_IBT_OFF                             = 0x00000000,
    MSS_VPD_MT_DIMM_RCD_IBT_CS_IBT_100                             = 0x0000000A,
    MSS_VPD_MT_DIMM_RCD_IBT_CS_IBT_150                             = 0x0000000F,
    MSS_VPD_MT_DIMM_RCD_IBT_CS_IBT_300                             = 0x0000001E,
};

/**
 *  @brief Register Clock Driver, Input Bus Termination for On Die
 *	Termination in tens of Ohms.
 */
enum MSS_VPD_MT_DIMM_RCD_IBT_ODT
{
    MSS_VPD_MT_DIMM_RCD_IBT_ODT_IBT_OFF                            = 0x00000000,
    MSS_VPD_MT_DIMM_RCD_IBT_ODT_IBT_100                            = 0x0000000A,
    MSS_VPD_MT_DIMM_RCD_IBT_ODT_IBT_150                            = 0x0000000F,
    MSS_VPD_MT_DIMM_RCD_IBT_ODT_IBT_300                            = 0x0000001E,
};

/**
 *  @brief DQ and DQS Drive Impedance for [Port][DIMM][RANK].
 */
enum MSS_VPD_MT_DRAM_DRV_IMP_DQ_DQS
{
    MSS_VPD_MT_DRAM_DRV_IMP_DQ_DQS_OHM30                           = 0x0000001E,
    MSS_VPD_MT_DRAM_DRV_IMP_DQ_DQS_OHM34                           = 0x00000022,
    MSS_VPD_MT_DRAM_DRV_IMP_DQ_DQS_OHM40                           = 0x00000028,
    MSS_VPD_MT_DRAM_DRV_IMP_DQ_DQS_OHM48                           = 0x00000030,
};

/**
 *  @brief DRAM side Nominal Termination Resistance in Ohms.
 */
enum MSS_VPD_MT_DRAM_RTT_NOM
{
    MSS_VPD_MT_DRAM_RTT_NOM_DISABLE                                = 0x00000000,
    MSS_VPD_MT_DRAM_RTT_NOM_OHM34                                  = 0x00000022,
    MSS_VPD_MT_DRAM_RTT_NOM_OHM40                                  = 0x00000028,
    MSS_VPD_MT_DRAM_RTT_NOM_OHM48                                  = 0x00000030,
    MSS_VPD_MT_DRAM_RTT_NOM_OHM60                                  = 0x0000003C,
    MSS_VPD_MT_DRAM_RTT_NOM_OHM80                                  = 0x00000050,
    MSS_VPD_MT_DRAM_RTT_NOM_OHM120                                 = 0x00000078,
    MSS_VPD_MT_DRAM_RTT_NOM_OHM240                                 = 0x000000F0,
};

/**
 *  @brief DRAM side Park Termination Resistance in Ohms.
 */
enum MSS_VPD_MT_DRAM_RTT_PARK
{
    MSS_VPD_MT_DRAM_RTT_PARK_DISABLE                               = 0x00000000,
    MSS_VPD_MT_DRAM_RTT_PARK_60OHM                                 = 0x0000003C,
    MSS_VPD_MT_DRAM_RTT_PARK_120OHM                                = 0x00000078,
    MSS_VPD_MT_DRAM_RTT_PARK_40OHM                                 = 0x00000028,
    MSS_VPD_MT_DRAM_RTT_PARK_240OHM                                = 0x000000F0,
    MSS_VPD_MT_DRAM_RTT_PARK_48OHM                                 = 0x00000030,
    MSS_VPD_MT_DRAM_RTT_PARK_80OHM                                 = 0x00000050,
    MSS_VPD_MT_DRAM_RTT_PARK_34OHM                                 = 0x00000022,
};

/**
 *  @brief DRAM side Write Termination Resistance in Ohms.
 */
enum MSS_VPD_MT_DRAM_RTT_WR
{
    MSS_VPD_MT_DRAM_RTT_WR_DISABLE                                 = 0x00000000,
    MSS_VPD_MT_DRAM_RTT_WR_OHM80                                   = 0x00000050,
    MSS_VPD_MT_DRAM_RTT_WR_OHM120                                  = 0x00000078,
    MSS_VPD_MT_DRAM_RTT_WR_OHM240                                  = 0x000000F0,
    MSS_VPD_MT_DRAM_RTT_WR_HIGHZ                                   = 0x00000001,
};

/**
 *  @brief Memory Controller side Drive Impedance for Clock in Ohms.
 */
enum MSS_VPD_MT_MC_DRV_IMP_CLK
{
    MSS_VPD_MT_MC_DRV_IMP_CLK_OHM30                                = 0x0000001E,
    MSS_VPD_MT_MC_DRV_IMP_CLK_OHM40                                = 0x00000028,
};

/**
 *  @brief Memory Controller side Drive Impedance for Address, Bank
 *	Address, Bank Group and Activate Lines in Ohms.
 */
enum MSS_VPD_MT_MC_DRV_IMP_CMD_ADDR
{
    MSS_VPD_MT_MC_DRV_IMP_CMD_ADDR_OHM30                           = 0x0000001E,
    MSS_VPD_MT_MC_DRV_IMP_CMD_ADDR_OHM40                           = 0x00000028,
};

/**
 *  @brief Memory Controller side Drive Impedance for Clock Enable, ODT,
 *	Parity, and Reset Lines in Ohms.
 */
enum MSS_VPD_MT_MC_DRV_IMP_CNTL
{
    MSS_VPD_MT_MC_DRV_IMP_CNTL_OHM30                               = 0x0000001E,
    MSS_VPD_MT_MC_DRV_IMP_CNTL_OHM40                               = 0x00000028,
};

/**
 *  @brief Memory Controller side Drive Impedance for Chip Select and Chip
 *	ID Lines in Ohms.
 */
enum MSS_VPD_MT_MC_DRV_IMP_CSCID
{
    MSS_VPD_MT_MC_DRV_IMP_CSCID_OHM30                              = 0x0000001E,
    MSS_VPD_MT_MC_DRV_IMP_CSCID_OHM40                              = 0x00000028,
};

/**
 *  @brief Memory Controller side Drive Impedance for [PORT][DP16] Data and
 *	Data Strobe Lines in Ohms.
 */
enum MSS_VPD_MT_MC_DRV_IMP_DQ_DQS
{
    MSS_VPD_MT_MC_DRV_IMP_DQ_DQS_DISABLE                           = 0x00000000,
    MSS_VPD_MT_MC_DRV_IMP_DQ_DQS_OHM34                             = 0x00000022,
    MSS_VPD_MT_MC_DRV_IMP_DQ_DQS_OHM40                             = 0x00000028,
    MSS_VPD_MT_MC_DRV_IMP_DQ_DQS_OHM48                             = 0x00000030,
    MSS_VPD_MT_MC_DRV_IMP_DQ_DQS_OHM60                             = 0x0000003C,
    MSS_VPD_MT_MC_DRV_IMP_DQ_DQS_OHM80                             = 0x00000050,
    MSS_VPD_MT_MC_DRV_IMP_DQ_DQS_OHM120                            = 0x00000078,
    MSS_VPD_MT_MC_DRV_IMP_DQ_DQS_OHM240                            = 0x000000F0,
};

/**
 *  @brief Memory Controller side Receiver Impedance for [PORT][DP16] Data
 *	and Data Strobe Lines in Ohms.
 */
enum MSS_VPD_MT_MC_RCV_IMP_DQ_DQS
{
    MSS_VPD_MT_MC_RCV_IMP_DQ_DQS_DISABLE                           = 0x00000000,
    MSS_VPD_MT_MC_RCV_IMP_DQ_DQS_OHM34                             = 0x00000022,
    MSS_VPD_MT_MC_RCV_IMP_DQ_DQS_OHM40                             = 0x00000028,
    MSS_VPD_MT_MC_RCV_IMP_DQ_DQS_OHM48                             = 0x00000030,
    MSS_VPD_MT_MC_RCV_IMP_DQ_DQS_OHM60                             = 0x0000003C,
    MSS_VPD_MT_MC_RCV_IMP_DQ_DQS_OHM80                             = 0x00000050,
    MSS_VPD_MT_MC_RCV_IMP_DQ_DQS_OHM120                            = 0x00000078,
    MSS_VPD_MT_MC_RCV_IMP_DQ_DQS_OHM240                            = 0x000000F0,
};

/**
 *  @brief Memory Controller side Read Vref setting. Dividing by 1000 gives
 *	you percentage of Vdd
 */
enum MSS_VPD_MT_VREF_MC_RD
{
    MSS_VPD_MT_VREF_MC_RD_VDD91875                                 = 0x000166E3,
    MSS_VPD_MT_VREF_MC_RD_VDD91333                                 = 0x000164C5,
    MSS_VPD_MT_VREF_MC_RD_VDD90791                                 = 0x000162A7,
    MSS_VPD_MT_VREF_MC_RD_VDD90250                                 = 0x0001608A,
    MSS_VPD_MT_VREF_MC_RD_VDD89708                                 = 0x00015E6C,
    MSS_VPD_MT_VREF_MC_RD_VDD89166                                 = 0x00015C4E,
    MSS_VPD_MT_VREF_MC_RD_VDD88625                                 = 0x00015A31,
    MSS_VPD_MT_VREF_MC_RD_VDD88083                                 = 0x00015813,
    MSS_VPD_MT_VREF_MC_RD_VDD87541                                 = 0x000155F5,
    MSS_VPD_MT_VREF_MC_RD_VDD87000                                 = 0x000153D8,
    MSS_VPD_MT_VREF_MC_RD_VDD86458                                 = 0x000151BA,
    MSS_VPD_MT_VREF_MC_RD_VDD85916                                 = 0x00014F9C,
    MSS_VPD_MT_VREF_MC_RD_VDD85375                                 = 0x00014D7F,
    MSS_VPD_MT_VREF_MC_RD_VDD84833                                 = 0x00014B61,
    MSS_VPD_MT_VREF_MC_RD_VDD84291                                 = 0x00014943,
    MSS_VPD_MT_VREF_MC_RD_VDD83750                                 = 0x00014726,
    MSS_VPD_MT_VREF_MC_RD_VDD83208                                 = 0x00014508,
    MSS_VPD_MT_VREF_MC_RD_VDD82666                                 = 0x000142EA,
    MSS_VPD_MT_VREF_MC_RD_VDD82125                                 = 0x000140CD,
    MSS_VPD_MT_VREF_MC_RD_VDD81583                                 = 0x00013EAF,
    MSS_VPD_MT_VREF_MC_RD_VDD81041                                 = 0x00013C91,
    MSS_VPD_MT_VREF_MC_RD_VDD80500                                 = 0x00013A74,
    MSS_VPD_MT_VREF_MC_RD_VDD79958                                 = 0x00013856,
    MSS_VPD_MT_VREF_MC_RD_VDD79416                                 = 0x00013638,
    MSS_VPD_MT_VREF_MC_RD_VDD78875                                 = 0x0001341B,
    MSS_VPD_MT_VREF_MC_RD_VDD78333                                 = 0x000131FD,
    MSS_VPD_MT_VREF_MC_RD_VDD77791                                 = 0x00012FDF,
    MSS_VPD_MT_VREF_MC_RD_VDD77250                                 = 0x00012DC2,
    MSS_VPD_MT_VREF_MC_RD_VDD76708                                 = 0x00012BA4,
    MSS_VPD_MT_VREF_MC_RD_VDD76166                                 = 0x00012986,
    MSS_VPD_MT_VREF_MC_RD_VDD75625                                 = 0x00012769,
    MSS_VPD_MT_VREF_MC_RD_VDD75083                                 = 0x0001254B,
    MSS_VPD_MT_VREF_MC_RD_VDD74541                                 = 0x0001232D,
    MSS_VPD_MT_VREF_MC_RD_VDD74000                                 = 0x00012110,
    MSS_VPD_MT_VREF_MC_RD_VDD73458                                 = 0x00011EF2,
    MSS_VPD_MT_VREF_MC_RD_VDD72916                                 = 0x00011CD4,
    MSS_VPD_MT_VREF_MC_RD_VDD72375                                 = 0x00011AB7,
    MSS_VPD_MT_VREF_MC_RD_VDD71833                                 = 0x00011899,
    MSS_VPD_MT_VREF_MC_RD_VDD71291                                 = 0x0001167B,
    MSS_VPD_MT_VREF_MC_RD_VDD70750                                 = 0x0001145E,
    MSS_VPD_MT_VREF_MC_RD_VDD70208                                 = 0x00011240,
    MSS_VPD_MT_VREF_MC_RD_VDD69666                                 = 0x00011022,
    MSS_VPD_MT_VREF_MC_RD_VDD69125                                 = 0x00010E05,
    MSS_VPD_MT_VREF_MC_RD_VDD68583                                 = 0x00010BE7,
    MSS_VPD_MT_VREF_MC_RD_VDD68041                                 = 0x000109C9,
    MSS_VPD_MT_VREF_MC_RD_VDD67500                                 = 0x000107AC,
    MSS_VPD_MT_VREF_MC_RD_VDD66958                                 = 0x0001058E,
    MSS_VPD_MT_VREF_MC_RD_VDD66416                                 = 0x00010370,
    MSS_VPD_MT_VREF_MC_RD_VDD65875                                 = 0x00010153,
    MSS_VPD_MT_VREF_MC_RD_VDD65333                                 = 0x0000FF35,
    MSS_VPD_MT_VREF_MC_RD_VDD64791                                 = 0x0000FD17,
    MSS_VPD_MT_VREF_MC_RD_VDD64250                                 = 0x0000FAFA,
    MSS_VPD_MT_VREF_MC_RD_VDD63708                                 = 0x0000F8DC,
    MSS_VPD_MT_VREF_MC_RD_VDD63166                                 = 0x0000F6BE,
    MSS_VPD_MT_VREF_MC_RD_VDD62625                                 = 0x0000F4A1,
    MSS_VPD_MT_VREF_MC_RD_VDD62083                                 = 0x0000F283,
    MSS_VPD_MT_VREF_MC_RD_VDD61541                                 = 0x0000F065,
    MSS_VPD_MT_VREF_MC_RD_VDD61000                                 = 0x0000EE48,
    MSS_VPD_MT_VREF_MC_RD_VDD60458                                 = 0x0000EC2A,
    MSS_VPD_MT_VREF_MC_RD_VDD59916                                 = 0x0000EA0C,
    MSS_VPD_MT_VREF_MC_RD_VDD59375                                 = 0x0000E7EF,
    MSS_VPD_MT_VREF_MC_RD_VDD58833                                 = 0x0000E5D1,
    MSS_VPD_MT_VREF_MC_RD_VDD58291                                 = 0x0000E3B3,
    MSS_VPD_MT_VREF_MC_RD_VDD57750                                 = 0x0000E196,
    MSS_VPD_MT_VREF_MC_RD_VDD57208                                 = 0x0000DF78,
    MSS_VPD_MT_VREF_MC_RD_VDD56666                                 = 0x0000DD5A,
    MSS_VPD_MT_VREF_MC_RD_VDD56125                                 = 0x0000DB3D,
    MSS_VPD_MT_VREF_MC_RD_VDD55583                                 = 0x0000D91F,
    MSS_VPD_MT_VREF_MC_RD_VDD55041                                 = 0x0000D701,
    MSS_VPD_MT_VREF_MC_RD_VDD54500                                 = 0x0000D4E4,
    MSS_VPD_MT_VREF_MC_RD_VDD53958                                 = 0x0000D2C6,
    MSS_VPD_MT_VREF_MC_RD_VDD53416                                 = 0x0000D0A8,
    MSS_VPD_MT_VREF_MC_RD_VDD52875                                 = 0x0000CE8B,
    MSS_VPD_MT_VREF_MC_RD_VDD52333                                 = 0x0000CC6D,
    MSS_VPD_MT_VREF_MC_RD_VDD51791                                 = 0x0000CA4F,
    MSS_VPD_MT_VREF_MC_RD_VDD51250                                 = 0x0000C832,
    MSS_VPD_MT_VREF_MC_RD_VDD50708                                 = 0x0000C614,
    MSS_VPD_MT_VREF_MC_RD_VDD50166                                 = 0x0000C3F6,
    MSS_VPD_MT_VREF_MC_RD_VDD49625                                 = 0x0000C1D9,
    MSS_VPD_MT_VREF_MC_RD_VDD49083                                 = 0x0000BFBB,
    MSS_VPD_MT_VREF_MC_RD_VDD48541                                 = 0x0000BD9D,
    MSS_VPD_MT_VREF_MC_RD_VDD48000                                 = 0x0000BB80,
    MSS_VPD_MT_VREF_MC_RD_VDD47458                                 = 0x0000B962,
    MSS_VPD_MT_VREF_MC_RD_VDD46916                                 = 0x0000B744,
    MSS_VPD_MT_VREF_MC_RD_VDD46375                                 = 0x0000B527,
    MSS_VPD_MT_VREF_MC_RD_VDD45833                                 = 0x0000B309,
    MSS_VPD_MT_VREF_MC_RD_VDD45291                                 = 0x0000B0EB,
    MSS_VPD_MT_VREF_MC_RD_VDD44750                                 = 0x0000AECE,
    MSS_VPD_MT_VREF_MC_RD_VDD44208                                 = 0x0000ACB0,
    MSS_VPD_MT_VREF_MC_RD_VDD43666                                 = 0x0000AA92,
    MSS_VPD_MT_VREF_MC_RD_VDD43125                                 = 0x0000A875,
    MSS_VPD_MT_VREF_MC_RD_VDD42583                                 = 0x0000A657,
    MSS_VPD_MT_VREF_MC_RD_VDD42041                                 = 0x0000A439,
    MSS_VPD_MT_VREF_MC_RD_VDD41500                                 = 0x0000A21C,
    MSS_VPD_MT_VREF_MC_RD_VDD40958                                 = 0x00009FFE,
    MSS_VPD_MT_VREF_MC_RD_VDD40416                                 = 0x00009DE0,
    MSS_VPD_MT_VREF_MC_RD_VDD39875                                 = 0x00009BC3,
    MSS_VPD_MT_VREF_MC_RD_VDD39333                                 = 0x000099A5,
    MSS_VPD_MT_VREF_MC_RD_VDD38791                                 = 0x00009787,
    MSS_VPD_MT_VREF_MC_RD_VDD38250                                 = 0x0000956A,
    MSS_VPD_MT_VREF_MC_RD_VDD37708                                 = 0x0000934C,
    MSS_VPD_MT_VREF_MC_RD_VDD37166                                 = 0x0000912E,
    MSS_VPD_MT_VREF_MC_RD_VDD36625                                 = 0x00008F11,
    MSS_VPD_MT_VREF_MC_RD_VDD36083                                 = 0x00008CF3,
    MSS_VPD_MT_VREF_MC_RD_VDD35541                                 = 0x00008AD5,
    MSS_VPD_MT_VREF_MC_RD_VDD35000                                 = 0x000088B8,
    MSS_VPD_MT_VREF_MC_RD_VDD34458                                 = 0x0000869A,
    MSS_VPD_MT_VREF_MC_RD_VDD33916                                 = 0x0000847C,
    MSS_VPD_MT_VREF_MC_RD_VDD33375                                 = 0x0000825F,
    MSS_VPD_MT_VREF_MC_RD_VDD32833                                 = 0x00008041,
    MSS_VPD_MT_VREF_MC_RD_VDD32291                                 = 0x00007E23,
    MSS_VPD_MT_VREF_MC_RD_VDD31750                                 = 0x00007C06,
    MSS_VPD_MT_VREF_MC_RD_VDD31208                                 = 0x000079E8,
};

/**
 *  @brief DRAM Device Type. Decodes SPD byte 2. Generation of memory:
 *	DDR3, DDR4. creator: mss_eff_config consumer: various firmware
 *	notes: none
 */
enum EFF_DRAM_GEN
{
    EFF_DRAM_GEN_EMPTY                                             = 0x00000000,
    EFF_DRAM_GEN_DDR3                                              = 0x00000001,
    EFF_DRAM_GEN_DDR4                                              = 0x00000002,
};

/**
 *  @brief Base Module Type. Decodes SPD Byte 3 (bits 3~0). Type of DIMM:
 *	RDIMM, UDIMM, LRDIMM as specified by the JEDEC standard. creator:
 *	mss_eff_config consumer: various firmware notes: none
 */
enum EFF_DIMM_TYPE
{
    EFF_DIMM_TYPE_EMPTY                                            = 0x00000000,
    EFF_DIMM_TYPE_RDIMM                                            = 0x00000001,
    EFF_DIMM_TYPE_UDIMM                                            = 0x00000002,
    EFF_DIMM_TYPE_LRDIMM                                           = 0x00000003,
};

/**
 *  @brief Hybrid Media. Decodes SPD Byte 3 (bits 6~4) creator:
 *	mss_eff_config consumer: various firmware notes: none
 */
enum EFF_HYBRID_MEMORY_TYPE
{
    EFF_HYBRID_MEMORY_TYPE_NONE                                    = 0x00000000,
    EFF_HYBRID_MEMORY_TYPE_NVDIMM                                  = 0x00000001,
};

/**
 *  @brief Hybrid. Decodes SPD Byte 3 (bit 7) creator: mss_eff_config
 *	consumer: various firmware notes: none
 */
enum EFF_HYBRID
{
    EFF_HYBRID_NOT_HYBRID                                          = 0x00000000,
    EFF_HYBRID_IS_HYBRID                                           = 0x00000001,
};

/**
 *  @brief DRAM Density. Decodes SPD Byte 4 (bits 3~0). Total SDRAM
 *	capacity per die. For multi-die stacks (DDP, QDP, or 3DS), this
 *	represents the capacity of each DRAM die in the stack. creator:
 *	mss_eff_config consumer: various firmware notes: none
 */
enum EFF_DRAM_DENSITY
{
    EFF_DRAM_DENSITY_4G                                            = 0x00000004,
    EFF_DRAM_DENSITY_8G                                            = 0x00000008,
    EFF_DRAM_DENSITY_16G                                           = 0x00000010,
};

/**
 *  @brief Row Address Bits. Decodes Byte 5 (bits 5~3). Number of DRAM
 *	column address bits. Actual number of DRAM rows is 2^N, where N is
 *	the number of row address bits creator: mss_eff_config consumer:
 *	various firmware notes: none
 */
enum EFF_DRAM_ROW_BITS
{
    EFF_DRAM_ROW_BITS_NUM14                                        = 0x0000000E,
    EFF_DRAM_ROW_BITS_NUM15                                        = 0x0000000F,
    EFF_DRAM_ROW_BITS_NUM16                                        = 0x00000010,
    EFF_DRAM_ROW_BITS_NUM17                                        = 0x00000011,
    EFF_DRAM_ROW_BITS_NUM18                                        = 0x00000012,
};

/**
 *  @brief Primary SDRAM Package Type. Decodes Byte 6. This byte defines
 *	the primary set of SDRAMs. Monolithic = SPD, Multi-load stack =
 *	DDP/QDP, Single-load stack = 3DS creator: mss_eff_config consumer:
 *	various firmware notes: none
 */
enum EFF_PRIM_STACK_TYPE
{
    EFF_PRIM_STACK_TYPE_SDP                                        = 0x00000000,
    EFF_PRIM_STACK_TYPE_DDP_QDP                                    = 0x00000001,
    EFF_PRIM_STACK_TYPE_3DS                                        = 0x00000002,
};

/**
 *  @brief Post Package Repair. Used in various locations and is evaluated
 *	in mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware
 *	notes: none
 */
enum EFF_DRAM_PPR
{
    EFF_DRAM_PPR_NOT_SUPPORTED                                     = 0x00000000,
    EFF_DRAM_PPR_SUPPORTED                                         = 0x00000001,
};

/**
 *  @brief Soft Post Package Repair. Used in various locations and is
 *	evaluated in mss_eff_cnfg. creator: mss_eff_cnfg consumer: various
 *	firmware notes: none
 */
enum EFF_DRAM_SOFT_PPR
{
    EFF_DRAM_SOFT_PPR_NOT_SUPPORTED                                = 0x00000000,
    EFF_DRAM_SOFT_PPR_SUPPORTED                                    = 0x00000001,
};

/**
 *  @brief Minimum CAS to CAS Delay Time, same bank group in nck (number of
 *	clock cycles). Decodes SPD byte 40 (bits 7~0) and byte 117 (bits
 *	7~0). This is for DDR4 MRS6. Each memory channel will have a value.
 *	Creator: eff_config Consumer:various Firmware notes: none
 */
enum EFF_DRAM_TCCD_L
{
    EFF_DRAM_TCCD_L_4NCK                                           = 0x00000004,
    EFF_DRAM_TCCD_L_5NCK                                           = 0x00000005,
    EFF_DRAM_TCCD_L_6NCK                                           = 0x00000006,
    EFF_DRAM_TCCD_L_7NCK                                           = 0x00000007,
    EFF_DRAM_TCCD_L_8NCK                                           = 0x00000008,
};

/**
 *  @brief SDRAM Device Width Decodes SPD Byte 12 (bits 2~0). Options: X4
 *	(4 bits), X8 (8 bits), X16 (16 bits), X32 (32 bits). creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum EFF_DRAM_WIDTH
{
    EFF_DRAM_WIDTH_X4                                              = 0x00000004,
    EFF_DRAM_WIDTH_X8                                              = 0x00000008,
    EFF_DRAM_WIDTH_X16                                             = 0x00000010,
    EFF_DRAM_WIDTH_X32                                             = 0x00000020,
};

/**
 *  @brief DRAM Device Rank Mix Decodes SPD Byte 12 (bits 5~3). creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum EFF_DRAM_RANK_MIX
{
    EFF_DRAM_RANK_MIX_SYMMETRICAL                                  = 0x00000000,
    EFF_DRAM_RANK_MIX_ASYMMETICAL                                  = 0x00000001,
};

/**
 *  @brief Total number of ranks in each DIMM. For monolithic and
 *	multi-load stack modules (SDP/DDP) this is the same as the number
 *	of package ranks per DIMM (SPD Byte 12 bits 5~3). For single load
 *	stack (3DS) modules this value represents the number of logical
 *	ranks per DIMM. Logical rank refers the individually addressable
 *	die in a 3DS stack and has no meaning for monolithic or multi-load
 *	stacked SDRAMs. creator: mss_eff_cnfg consumer: various firmware
 *	notes: none
 */
enum EFF_NUM_RANKS_PER_DIMM
{
    EFF_NUM_RANKS_PER_DIMM_1R                                      = 0x00000001,
    EFF_NUM_RANKS_PER_DIMM_2R                                      = 0x00000002,
    EFF_NUM_RANKS_PER_DIMM_4R                                      = 0x00000004,
    EFF_NUM_RANKS_PER_DIMM_8R                                      = 0x00000008,
    EFF_NUM_RANKS_PER_DIMM_16R                                     = 0x00000010,
};

/**
 *  @brief Register Type Decodes SPD Byte 131 creator: mss_eff_cnfg
 *	consumer: eff_dimm
 */
enum EFF_REGISTER_TYPE
{
    EFF_REGISTER_TYPE_RCD01                                        = 0x00000000,
    EFF_REGISTER_TYPE_RCD02                                        = 0x00000001,
};

/**
 *  @brief DRAM Manufacturer ID Code Decodes SPD Byte 350 and 351 creator:
 *	mss_eff_cnfg consumer: power_thermal::decoder
 */
enum EFF_DRAM_MFG_ID
{
    EFF_DRAM_MFG_ID_MICRON                                         = 0x0000802C,
    EFF_DRAM_MFG_ID_SAMSUNG                                        = 0x000080CE,
    EFF_DRAM_MFG_ID_HYNIX                                          = 0x000080AD,
};

/**
 *  @brief Register Manufacturer ID Code Decodes SPD Byte 133 and 134
 *	creator: mss_eff_cnfg
 */
enum EFF_RCD_MFG_ID
{
    EFF_RCD_MFG_ID_INPHI                                           = 0x0000B304,
    EFF_RCD_MFG_ID_MONTAGE                                         = 0x00003286,
    EFF_RCD_MFG_ID_IDT                                             = 0x0000B380,
};

/**
 *  @brief In sub DD1.02 Nimbus in the WR VREF algorithm, certain
 *	work-arounds are needed
 */
enum DO_MSS_WR_VREF
{
    DO_MSS_WR_VREF_NO                                              = 0x00000000,
    DO_MSS_WR_VREF_YES                                             = 0x00000001,
};

/**
 *  @brief In sub DD1.02 Nimbus the HW VREF calibrations should not be run
 */
enum SKIP_HW_VREF_CAL
{
    SKIP_HW_VREF_CAL_RUN                                           = 0x00000000,
    SKIP_HW_VREF_CAL_SKIP                                          = 0x00000001,
};

/**
 *  @brief In sub DD1.03 Nimbus the HW VREF calibrations should not be run
 */
enum SKIP_RD_VREF_VREFSENSE_OVERRIDE
{
    SKIP_RD_VREF_VREFSENSE_OVERRIDE_RUN                            = 0x00000000,
    SKIP_RD_VREF_VREFSENSE_OVERRIDE_SKIP                           = 0x00000001,
};

/**
 *  @brief VREF DAC work-around for Nimbus sub DD1.02
 */
enum DO_MSS_VREF_DAC
{
    DO_MSS_VREF_DAC_NO                                             = 0x00000000,
    DO_MSS_VREF_DAC_YES                                            = 0x00000001,
};

/**
 *  @brief For Nimbus pre DD1.02 we want to pass DDR training if we see
 *	'correctable' errors. This isn't the case for post-DD1.02 where we
 *	want to pass/fail training based on the results from the PHY itself
 */
enum DO_MSS_TRAINING_BAD_BITS
{
    DO_MSS_TRAINING_BAD_BITS_NO                                    = 0x00000000,
    DO_MSS_TRAINING_BAD_BITS_YES                                   = 0x00000001,
};

/**
 *  @brief Selects whether or not DCD should be run
 */
enum MSS_RUN_DCD_CALIBRATION
{
    MSS_RUN_DCD_CALIBRATION_NO                                     = 0x00000000,
    MSS_RUN_DCD_CALIBRATION_YES                                    = 0x00000001,
};

/**
 *  @brief The frequency of a processor's nest mesh clock, in MHz. This is
 *	the same for all chips in the system. Provided by the MRW.
 */
enum FREQ_PB_MHZ
{
    FREQ_PB_MHZ_1600                                               = 0x00000640,
    FREQ_PB_MHZ_1866                                               = 0x0000074A,
    FREQ_PB_MHZ_2000                                               = 0x000007D0,
    FREQ_PB_MHZ_2133                                               = 0x00000855,
    FREQ_PB_MHZ_2400                                               = 0x00000960,
};

/**
 *  @brief The frequency of the memory controller channel. In synchronous
 *	mode, this is equivalent to ATTR_FREQ_PB_MHZ. This may be
 *	independently set per pair of memory channels if operating in
 *	asynchronous mode, but this configuration is not anticipated. This
 *	clock drives the MCU queues, and all the associated logic that
 *	drives the inputs to the DMI and reads its outputs.
 */
enum FREQ_MCA_MHZ
{
    FREQ_MCA_MHZ_2000                                              = 0x000007D0,
    FREQ_MCA_MHZ_2400                                              = 0x00000960,
};

/**
 *  @brief MRW control to permit Normal (100 MHz) or Slow (94 MHz)
 *	operation of PCIE reference clock. On Nimbus DD1 HW, Slow operation
 *	is required to achieve Gen4 operation. Provided by the MRW.
 */
enum DD1_SLOW_PCI_REF_CLOCK
{
    DD1_SLOW_PCI_REF_CLOCK_NORMAL                                  = 0x00000000,
    DD1_SLOW_PCI_REF_CLOCK_SLOW                                    = 0x00000001,
};

/**
 *  @brief Set to force all fabric asynchronous boundary crossings into
 *	safe mode.
 */
enum PROC_FABRIC_ASYNC_SAFE_MODE
{
    PROC_FABRIC_ASYNC_SAFE_MODE_PERFORMANCE_MODE                   = 0x00000000,
    PROC_FABRIC_ASYNC_SAFE_MODE_SAFE_MODE                          = 0x00000001,
};

/**
 *  @brief Processor SMP core floor/nest frequency ratio
 */
enum PROC_FABRIC_CORE_FLOOR_RATIO
{
    PROC_FABRIC_CORE_FLOOR_RATIO_RATIO_8_8                         = 0x00000000,
    PROC_FABRIC_CORE_FLOOR_RATIO_RATIO_7_8                         = 0x00000001,
    PROC_FABRIC_CORE_FLOOR_RATIO_RATIO_6_8                         = 0x00000002,
    PROC_FABRIC_CORE_FLOOR_RATIO_RATIO_5_8                         = 0x00000003,
    PROC_FABRIC_CORE_FLOOR_RATIO_RATIO_4_8                         = 0x00000004,
    PROC_FABRIC_CORE_FLOOR_RATIO_RATIO_2_8                         = 0x00000005,
};

/**
 *  @brief Processor SMP core celing/nest frequency ratio
 */
enum PROC_FABRIC_CORE_CEILING_RATIO
{
    PROC_FABRIC_CORE_CEILING_RATIO_RATIO_8_8                       = 0x00000000,
    PROC_FABRIC_CORE_CEILING_RATIO_RATIO_7_8                       = 0x00000001,
    PROC_FABRIC_CORE_CEILING_RATIO_RATIO_6_8                       = 0x00000002,
    PROC_FABRIC_CORE_CEILING_RATIO_RATIO_5_8                       = 0x00000003,
    PROC_FABRIC_CORE_CEILING_RATIO_RATIO_4_8                       = 0x00000004,
    PROC_FABRIC_CORE_CEILING_RATIO_RATIO_2_8                       = 0x00000005,
};

/**
 *  @brief Processor SMP topology configuration. 0 = default = 1 or 2 hop
 *	topology (PHYP image spans system) Provided by the MRW.
 */
enum PROC_FABRIC_CCSM_MODE
{
    PROC_FABRIC_CCSM_MODE_OFF                                      = 0x00000000,
};

/**
 *  @brief Per-link optics configuration 0 = default = SMP 1 = CAPI 2.0 2 =
 *	NV 2.0 3 = OPENCAPI Provided by the MRW.
 */
enum OPTICS_CONFIG_MODE
{
    OPTICS_CONFIG_MODE_SMP                                         = 0x00000000,
    OPTICS_CONFIG_MODE_CAPI                                        = 0x00000001,
    OPTICS_CONFIG_MODE_NV                                          = 0x00000002,
    OPTICS_CONFIG_MODE_OCAPI                                       = 0x00000003,
};

/**
 *  @brief Per-link optics configuration 0 = default = SMP 1 = CAPI 2.0 2 =
 *	NV 2.0
 */
enum PROC_FABRIC_OPTICS_CONFIG_MODE
{
    PROC_FABRIC_OPTICS_CONFIG_MODE_SMP                             = 0x00000000,
    PROC_FABRIC_OPTICS_CONFIG_MODE_CAPI                            = 0x00000001,
    PROC_FABRIC_OPTICS_CONFIG_MODE_NV                              = 0x00000002,
};

/**
 *  @brief Indicates if the given chip should serve as the fabric system
 *	master.
 */
enum PROC_FABRIC_SYSTEM_MASTER_CHIP
{
    PROC_FABRIC_SYSTEM_MASTER_CHIP_FALSE                           = 0x00000000,
    PROC_FABRIC_SYSTEM_MASTER_CHIP_TRUE                            = 0x00000001,
};

/**
 *  @brief Indicates if the given chip should serve as the fabric group
 *	master.
 */
enum PROC_FABRIC_GROUP_MASTER_CHIP
{
    PROC_FABRIC_GROUP_MASTER_CHIP_FALSE                            = 0x00000000,
    PROC_FABRIC_GROUP_MASTER_CHIP_TRUE                             = 0x00000001,
};

/**
 *  @brief For each fabric X link on this chip, specifies whether or not
 *	the chip at the receiving end of the link is present and configured
 */
enum PROC_FABRIC_X_ATTACHED_CHIP_CNFG
{
    PROC_FABRIC_X_ATTACHED_CHIP_CNFG_FALSE                         = 0x00000000,
    PROC_FABRIC_X_ATTACHED_CHIP_CNFG_TRUE                          = 0x00000001,
};

/**
 *  @brief For each fabric A link on this chip, specifies whether or not
 *	the chip at the receiving end of the link is present and configured
 */
enum PROC_FABRIC_A_ATTACHED_CHIP_CNFG
{
    PROC_FABRIC_A_ATTACHED_CHIP_CNFG_FALSE                         = 0x00000000,
    PROC_FABRIC_A_ATTACHED_CHIP_CNFG_TRUE                          = 0x00000001,
};

/**
 *  @brief Indicates if X links on this chip should be configured in
 *	aggregate mode.
 */
enum PROC_FABRIC_X_AGGREGATE
{
    PROC_FABRIC_X_AGGREGATE_OFF                                    = 0x00000000,
    PROC_FABRIC_X_AGGREGATE_ON                                     = 0x00000001,
};

/**
 *  @brief Indicates if link should be used to carry data only (in
 *	aggregate configurations). Should be considered valid only if
 *	corresponding ATTR_PROC_FABRIC_X_ATTACHED_CHIP_CNFG index is true.
 */
enum PROC_FABRIC_X_ADDR_DIS
{
    PROC_FABRIC_X_ADDR_DIS_OFF                                     = 0x00000000,
    PROC_FABRIC_X_ADDR_DIS_ON                                      = 0x00000001,
};

/**
 *  @brief Average of local/remote end link delay counter values. Used to
 *	designate coherent link in aggregate configurations. Should be
 *	considered valid only if corresponding
 *	ATTR_PROC_FABRIC_X_ATTACHED_CHIP_CNFG index is true.
 */
enum PROC_FABRIC_X_LINK_DELAY
{
    PROC_FABRIC_X_LINK_DELAY_OFF                                   = 0x00000000,
    PROC_FABRIC_X_LINK_DELAY_ON                                    = 0x00000001,
};

/**
 *  @brief Indicates if A links on this chip should be configured in
 *	aggregate mode.
 */
enum PROC_FABRIC_A_AGGREGATE
{
    PROC_FABRIC_A_AGGREGATE_OFF                                    = 0x00000000,
    PROC_FABRIC_A_AGGREGATE_ON                                     = 0x00000001,
};

/**
 *  @brief Indicates if link should be used to carry data only (in
 *	aggregate configurations). Should be considered valid only if
 *	corresponding ATTR_PROC_FABRIC_A_ATTACHED_CHIP_CNFG index is true.
 */
enum PROC_FABRIC_A_ADDR_DIS
{
    PROC_FABRIC_A_ADDR_DIS_OFF                                     = 0x00000000,
    PROC_FABRIC_A_ADDR_DIS_ON                                      = 0x00000001,
};

/**
 *  @brief Average of local/remote end link delay counter values. Used to
 *	designate coherent link in aggregate configurations. Should be
 *	considered valid only if corresponding
 *	ATTR_PROC_FABRIC_A_ATTACHED_CHIP_CNFG index is true.
 */
enum PROC_FABRIC_A_LINK_DELAY
{
    PROC_FABRIC_A_LINK_DELAY_OFF                                   = 0x00000000,
    PROC_FABRIC_A_LINK_DELAY_ON                                    = 0x00000001,
};

/**
 *  @brief Define context for current phase of system IPL.
 */
enum SYSTEM_IPL_PHASE
{
    SYSTEM_IPL_PHASE_HB_IPL                                        = 0x00000001,
    SYSTEM_IPL_PHASE_HB_RUNTIME                                    = 0x00000002,
    SYSTEM_IPL_PHASE_CACHE_CONTAINED                               = 0x00000004,
    SYSTEM_IPL_PHASE_CHIP_CONTAINED                                = 0x00000008,
    SYSTEM_IPL_PHASE_NONHB_IPL                                     = 0x00000010,
};

/**
 *  @brief Indicates if current IPL is memory-preserving
 */
enum IS_MPIPL
{
    IS_MPIPL_FALSE                                                 = 0x00000000,
    IS_MPIPL_TRUE                                                  = 0x00000001,
};

/**
 *  @brief Define placement policy/scheme for non-mirrored/mirrored memory
 *	layout NORMAL = non-mirrored start: 0, mirrored start: 1024TB
 *	FLIPPED = mirrored start: 0, non-mirrored start: 512TB Set by
 *	platform. Used by mss_eff_grouping.
 */
enum MEM_MIRROR_PLACEMENT_POLICY
{
    MEM_MIRROR_PLACEMENT_POLICY_NORMAL                             = 0x00000000,
    MEM_MIRROR_PLACEMENT_POLICY_FLIPPED                            = 0x00000001,
};

/**
 *  @brief Determines the stride covered by each granule in an interleaving
 *	group. The default stride -- 128B -- is the only value intended for
 *	production FW use. All other combinations are for experimental
 *	performance evaluation. Regardless of this attribute value, groups
 *	of size 1, 3, and 6 will be forced to 128B stride based on the
 *	logic capabilities.
 */
enum MSS_INTERLEAVE_GRANULARITY
{
    MSS_INTERLEAVE_GRANULARITY_128_B                               = 0x00000000,
    MSS_INTERLEAVE_GRANULARITY_256_B                               = 0x00000001,
    MSS_INTERLEAVE_GRANULARITY_512_B                               = 0x00000002,
    MSS_INTERLEAVE_GRANULARITY_1_KB                                = 0x00000003,
    MSS_INTERLEAVE_GRANULARITY_2_KB                                = 0x00000004,
    MSS_INTERLEAVE_GRANULARITY_4_KB                                = 0x00000005,
    MSS_INTERLEAVE_GRANULARITY_8_KB                                = 0x00000006,
    MSS_INTERLEAVE_GRANULARITY_16_KB                               = 0x00000007,
    MSS_INTERLEAVE_GRANULARITY_32_KB                               = 0x00000008,
};

/**
 *  @brief TRUE : HW mirroring is enabled. FALSE : HW mirroring is
 *	disabled. Provided by the MRW.
 */
enum MRW_HW_MIRRORING_ENABLE
{
    MRW_HW_MIRRORING_ENABLE_FALSE                                  = 0x00000000,
    MRW_HW_MIRRORING_ENABLE_TRUE                                   = 0x00000001,
};

/**
 *  @brief The amount of memory a user can reserve to store NHTM traces.
 *	This amount will be used to store both NHTM0 and NHTM1 traces. Used
 *	by p9_mss_eff_grouping.
 */
enum PROC_NHTM_BAR_SIZE
{
    PROC_NHTM_BAR_SIZE_256_GB                                      = 0x4000000000,
    PROC_NHTM_BAR_SIZE_128_GB                                      = 0x2000000000,
    PROC_NHTM_BAR_SIZE_64_GB                                       = 0x1000000000,
    PROC_NHTM_BAR_SIZE_32_GB                                       = 0x800000000,
    PROC_NHTM_BAR_SIZE_16_GB                                       = 0x400000000,
    PROC_NHTM_BAR_SIZE_8_GB                                        = 0x200000000,
    PROC_NHTM_BAR_SIZE_4_GB                                        = 0x100000000,
    PROC_NHTM_BAR_SIZE_2_GB                                        = 0x80000000,
    PROC_NHTM_BAR_SIZE_1_GB                                        = 0x40000000,
    PROC_NHTM_BAR_SIZE_512_MB                                      = 0x20000000,
    PROC_NHTM_BAR_SIZE_256_MB                                      = 0x10000000,
    PROC_NHTM_BAR_SIZE_128_MB                                      = 0x08000000,
    PROC_NHTM_BAR_SIZE_64_MB                                       = 0x04000000,
    PROC_NHTM_BAR_SIZE_32_MB                                       = 0x02000000,
    PROC_NHTM_BAR_SIZE_16_MB                                       = 0x01000000,
    PROC_NHTM_BAR_SIZE_ZERO                                        = 0x00000000,
};

/**
 *  @brief The amount of memory a user can reserve to store CHTM traces.
 *	There are 24 cores, thus 24 different sizes. Used by
 *	p9_mss_eff_grouping.
 */
enum PROC_CHTM_BAR_SIZES
{
    PROC_CHTM_BAR_SIZES_256_GB                                     = 0x4000000000,
    PROC_CHTM_BAR_SIZES_128_GB                                     = 0x2000000000,
    PROC_CHTM_BAR_SIZES_64_GB                                      = 0x1000000000,
    PROC_CHTM_BAR_SIZES_32_GB                                      = 0x800000000,
    PROC_CHTM_BAR_SIZES_16_GB                                      = 0x400000000,
    PROC_CHTM_BAR_SIZES_8_GB                                       = 0x200000000,
    PROC_CHTM_BAR_SIZES_4_GB                                       = 0x100000000,
    PROC_CHTM_BAR_SIZES_2_GB                                       = 0x80000000,
    PROC_CHTM_BAR_SIZES_1_GB                                       = 0x40000000,
    PROC_CHTM_BAR_SIZES_512_MB                                     = 0x20000000,
    PROC_CHTM_BAR_SIZES_256_MB                                     = 0x10000000,
    PROC_CHTM_BAR_SIZES_128_MB                                     = 0x08000000,
    PROC_CHTM_BAR_SIZES_64_MB                                      = 0x04000000,
    PROC_CHTM_BAR_SIZES_32_MB                                      = 0x02000000,
    PROC_CHTM_BAR_SIZES_16_MB                                      = 0x01000000,
    PROC_CHTM_BAR_SIZES_ZERO                                       = 0x00000000,
};

/**
 *  @brief The amount of memory a user can reserve to store OCC sandbox
 *	functions. Used by p9_mss_eff_grouping.
 */
enum PROC_OCC_SANDBOX_SIZE
{
    PROC_OCC_SANDBOX_SIZE_256_GB                                   = 0x4000000000,
    PROC_OCC_SANDBOX_SIZE_128_GB                                   = 0x2000000000,
    PROC_OCC_SANDBOX_SIZE_64_GB                                    = 0x1000000000,
    PROC_OCC_SANDBOX_SIZE_32_GB                                    = 0x800000000,
    PROC_OCC_SANDBOX_SIZE_16_GB                                    = 0x400000000,
    PROC_OCC_SANDBOX_SIZE_8_GB                                     = 0x200000000,
    PROC_OCC_SANDBOX_SIZE_4_GB                                     = 0x100000000,
    PROC_OCC_SANDBOX_SIZE_2_GB                                     = 0x80000000,
    PROC_OCC_SANDBOX_SIZE_1_GB                                     = 0x40000000,
    PROC_OCC_SANDBOX_SIZE_512_MB                                   = 0x20000000,
    PROC_OCC_SANDBOX_SIZE_256_MB                                   = 0x10000000,
    PROC_OCC_SANDBOX_SIZE_128_MB                                   = 0x08000000,
    PROC_OCC_SANDBOX_SIZE_64_MB                                    = 0x04000000,
    PROC_OCC_SANDBOX_SIZE_32_MB                                    = 0x02000000,
    PROC_OCC_SANDBOX_SIZE_16_MB                                    = 0x01000000,
    PROC_OCC_SANDBOX_SIZE_ZERO                                     = 0x00000000,
};

/**
 *  @brief DMI inband BAR enable. Set by platform. Used by
 *	p9c_set_inband_addr.
 */
enum DMI_INBAND_BAR_ENABLE
{
    DMI_INBAND_BAR_ENABLE_DISABLE                                  = 0x00000000,
    DMI_INBAND_BAR_ENABLE_ENABLE                                   = 0x00000001,
};

/**
 *  @brief Source: MRW: Downstream MSB Swap and Upstream MSB Swap Usage:
 *	TX_MSBSWAP initfile setting for DMI and X buses This attribute
 *	represents whether or not a single clock group bus such as DMI and
 *	X bus was wired by the board designer using a feature called MSB
 *	Swap where lane 0 of the TX chip wires to lane n-1 on the RX chip
 *	where 'n' is the width of the bus. A basic description of this
 *	capability is that the board designer can save layers on the board
 *	wiring by crossing the wiring between the two chips in a prescribed
 *	manner. In a non-MSB Swapped bus Lane 0 on the TX chip wires to
 *	lane 0 on the RX chip, lane 1 to lane 1 and so on. If a bus is MSB
 *	Swapped then lane 0 of the TX chip wires to lane 'n-1' of the RX
 *	chip, lane 1 to lane 'n-2', etc. Random or arbitrary wiring of TX
 *	to RX lanes on different chips is NOT ALLOWED. The Master Chip of
 *	two connected chips is defined as the chip with the smaller value
 *	of (100*Node + Pos). The Slave Chip of two connected chips is
 *	defined as the chip with the larger value of (100*Node + Pos). The
 *	Downstream direction is defined as the direction from the Master
 *	chip to the Slave chip. The Upstream direction is defined as the
 *	direction from the Slave chip to the Master chip. The Downstream
 *	TX_MSBSWAP from the MRW is a uint8 value. 0x01 means the Downstream
 *	bus is wired msb to lsb etc. and 0x00 means the bus is wired
 *	normally, msb to msb, lsb to lsb (lane0 to lane0). The Upstream
 *	TX_MSBSWAP from the MRW is a uint8 value. 0x01 means the Upstream
 *	bus is wired msb to lsb etc. and 0x00 means the bus is wired
 *	normally, msb to msb, lsb to lsb (lane0 to lane0). It is up to the
 *	platform code to set up each ATTR_EI_BUS_TX_MSBSWAP value for the
 *	correct target endpoints.
 */
enum EI_BUS_TX_MSBSWAP
{
    EI_BUS_TX_MSBSWAP_NO_SWAP                                      = 0x00000000,
    EI_BUS_TX_MSBSWAP_ALL_SWAP                                     = 0x000000FF,
    EI_BUS_TX_MSBSWAP_GROUP_0_SWAP                                 = 0x00000080,
    EI_BUS_TX_MSBSWAP_GROUP_1_SWAP                                 = 0x00000040,
};

/**
 *  @brief Summarizes the fused status of cores. This is same for all P9
 *	chips in the system. If a core is in a fused state, attribute
 *	should read 1 else zero. It needs to be populated during ipl but
 *	before istep 15.
 */
enum FUSED_CORE_MODE
{
    FUSED_CORE_MODE_CORE_UNFUSED                                   = 0x00000000,
    FUSED_CORE_MODE_CORE_FUSED                                     = 0x00000001,
};

/**
 *  @brief The Nest HTM trace type desired to be collected. This setting is
 *	applied to both NHTM0 and NHTM1.
 */
enum NHTM_TRACE_TYPE
{
    NHTM_TRACE_TYPE_DISABLE                                        = 0x00000000,
    NHTM_TRACE_TYPE_FABRIC                                         = 0x00000001,
    NHTM_TRACE_TYPE_EVENT                                          = 0x00000002,
    NHTM_TRACE_TYPE_OCC                                            = 0x00000003,
};

/**
 *  @brief The Core HTM trace type desired to be collected.
 */
enum CHTM_TRACE_TYPE
{
    CHTM_TRACE_TYPE_DISABLE                                        = 0x00000000,
    CHTM_TRACE_TYPE_CORE                                           = 0x00000001,
    CHTM_TRACE_TYPE_LLAT                                           = 0x00000002,
    CHTM_TRACE_TYPE_PPE                                            = 0x00000003,
    CHTM_TRACE_TYPE_DMW                                            = 0x00000004,
};

/**
 *  @brief Nest HTM: TTYPE/TSIZE Capture Invert. HTM Ttype Filter Control
 *	Register (32). This bit controls the inversion of the ttype/tsize
 *	filter. 0 : Capture record based on ttype/tsize pattern matching 1
 *	: Capture record based on ttype/tsize pattern NOT matching
 */
enum HTMSC_TTYPEFILT_INVERT
{
    HTMSC_TTYPEFILT_INVERT_MATCH                                   = 0x00000000,
    HTMSC_TTYPEFILT_INVERT_NOT_MATCH                               = 0x00000001,
};

/**
 *  @brief Nest HTM: CRESP Filter Capture Invert. HTM Ttype Filter Control
 *	Register (33). This bit controls the inversion of the cresp filter.
 *	0: Capture record based on cresp filter pattern/mask match 1:
 *	Capture record based on cresp filter pattern/mask NOT matching.
 */
enum HTMSC_CRESPFILT_INVERT
{
    HTMSC_CRESPFILT_INVERT_MATCH                                   = 0x00000000,
    HTMSC_CRESPFILT_INVERT_NOT_MATCH                               = 0x00000001,
};

/**
 *  @brief Nest HTM: defines the NHTM trace mode. HTM Collection Mode
 *	Register (1:2). Only FABRIC is supported at this time.
 */
enum NHTM_HTMSC_MODE_CONTENT_SEL
{
    NHTM_HTMSC_MODE_CONTENT_SEL_FABRIC                             = 0x00000000,
    NHTM_HTMSC_MODE_CONTENT_SEL_EVENT                              = 0x00000001,
    NHTM_HTMSC_MODE_CONTENT_SEL_OCC                                = 0x00000002,
};

/**
 *  @brief Nest HTM: defines if the generated data writes are captured. HTM
 *	Collection Mode Register (4). 0 - Ignore HTM generated data writes
 *	1 - Capture even HTM generated writes if they meet the filtering
 *	criteria.
 */
enum NHTM_HTMSC_MODE_CAPTURE_GENERATED_WRITES
{
    NHTM_HTMSC_MODE_CAPTURE_GENERATED_WRITES_DISABLE               = 0x00000000,
    NHTM_HTMSC_MODE_CAPTURE_GENERATED_WRITES_ENABLE                = 0x00000001,
};

/**
 *  @brief Nest HTM: defines if the filtering will apply to ttype=PMISC and
 *	ttype=Report Hang commands when filtering is enabled. HTM
 *	Collection Mode Register (5). 0 - filtering ignored on PMISC 1 -
 *	Apply filtering to PMISC also
 */
enum NHTM_HTMSC_MODE_CAPTURE_ENABLE_FILTER_ALL
{
    NHTM_HTMSC_MODE_CAPTURE_ENABLE_FILTER_ALL_DISABLE              = 0x00000000,
    NHTM_HTMSC_MODE_CAPTURE_ENABLE_FILTER_ALL_ENABLE               = 0x00000001,
};

/**
 *  @brief Nest HTM: defines if Precise cresp mode is enabled. 0 - Enable
 *	precisce cresp mode 1 - Disable precisce cresp mode
 */
enum NHTM_HTMSC_MODE_CAPTURE_PRECISE_CRESP_MODE
{
    NHTM_HTMSC_MODE_CAPTURE_PRECISE_CRESP_MODE_ENABLE              = 0x00000000,
    NHTM_HTMSC_MODE_CAPTURE_PRECISE_CRESP_MODE_DISABLE             = 0x00000001,
};

/**
 *  @brief Nest HTM: defines Limit Memory Allocation mode. 0 - Pre-allocate
 *	maximum memory buffers (NHTM=8) 1 - Pre-allocate only one half
 *	maximum memory buffers
 */
enum NHTM_HTMSC_MODE_CAPTURE_LIMIT_MEM_ALLOCATION
{
    NHTM_HTMSC_MODE_CAPTURE_LIMIT_MEM_ALLOCATION_DISABLE           = 0x00000000,
    NHTM_HTMSC_MODE_CAPTURE_LIMIT_MEM_ALLOCATION_ENABLE            = 0x00000001,
};

/**
 *  @brief Nest HTM: defines PMISC only Command trace mode. 0 rCmd amd
 *	cResp port 0 only goes to NHTM0 1 rCmd and Cresp port 0 is stored
 *	alternately to NHTM0 and NHTM1, switching based for each valid
 */
enum NHTM_HTMSC_MODE_CAPTURE_PMISC_ONLY_CMD
{
    NHTM_HTMSC_MODE_CAPTURE_PMISC_ONLY_CMD_DISABLE                 = 0x00000000,
    NHTM_HTMSC_MODE_CAPTURE_PMISC_ONLY_CMD_ENABLE                  = 0x00000001,
};

/**
 *  @brief Use space option. For NHTM only. HTM Collection Mode Register
 *	(22). 0 = Use HTM_CL_Write op to target system memory. Do
 *	pre-allocation sequence. (default) 1 = Use ci_pr_st op to target
 *	anywhere else. Dont do pre-allocate sequence.
 */
enum NHTM_HTMSC_MODE_WRITETOIO
{
    NHTM_HTMSC_MODE_WRITETOIO_DISABLE                              = 0x00000000,
    NHTM_HTMSC_MODE_WRITETOIO_ENABLE                               = 0x00000001,
};

/**
 *  @brief Core HTM: defines the CHTM trace mode. HTM Collection Mode
 *	Register (1:2). Only Direct Memory Write mode (IMA) is supported at
 *	this time.
 */
enum CHTM_HTMSC_MODE_CONTENT_SEL
{
    CHTM_HTMSC_MODE_CONTENT_SEL_CI                                 = 0x00000000,
    CHTM_HTMSC_MODE_CONTENT_SEL_LLAT                               = 0x00000001,
    CHTM_HTMSC_MODE_CONTENT_SEL_PPE                                = 0x00000002,
    CHTM_HTMSC_MODE_CONTENT_SEL_DMW                                = 0x00000003,
};

/**
 *  @brief For CHTM only. 0: Core execution is stalled whenever the data
 *	buffers are almost full to prevent losing records. 1: Core
 *	execution is never stalled and entries may be discarded when buffer
 *	is full
 */
enum CHTM_HTMSC_MODE_CORE_INSTR_STALL
{
    CHTM_HTMSC_MODE_CORE_INSTR_STALL_ENABLE                        = 0x00000000,
    CHTM_HTMSC_MODE_CORE_INSTR_STALL_DISABLE                       = 0x00000001,
};

/**
 *  @brief Trace Wrap mode, used for both NHTM and CHTM HTM Collection Mode
 *	Register (13). 0 = Wrap trace to beginning of Trace Memory 1 = Stop
 *	trace when top of Trace Memory is reached
 */
enum HTMSC_MODE_WRAP
{
    HTMSC_MODE_WRAP_ENABLE                                         = 0x00000000,
    HTMSC_MODE_WRAP_DISABLE                                        = 0x00000001,
};

/**
 *  @brief TimeStamp Writes option, used for both NHTM and CHTM HTM
 *	Collection Mode Register (14). 0 = Write of timestamps enabled to
 *	indicate elapsed time between records. 1 = Timestamps written only
 *	to indicate record loss
 */
enum HTMSC_MODE_DIS_TSTAMP
{
    HTMSC_MODE_DIS_TSTAMP_ENABLE                                   = 0x00000000,
    HTMSC_MODE_DIS_TSTAMP_DISABLE                                  = 0x00000001,
};

/**
 *  @brief Overflow Timestamps option, used for both NHTM and CHTM. HTM
 *	Collection Mode Register (15). 0 = Timestamp written to indicate
 *	elapsed time overflow. 1 = Only one timestamp is written between
 *	entries, overflow indication is lost
 */
enum HTMSC_MODE_SINGLE_TSTAMP
{
    HTMSC_MODE_SINGLE_TSTAMP_DISABLE                               = 0x00000000,
    HTMSC_MODE_SINGLE_TSTAMP_ENABLE                                = 0x00000001,
};

/**
 *  @brief Nest HTM: Stamp/Marker only mode. HTM Collection Mode Register
 *	(17). 0 = Normal trace 1 = Ignore incoming trace data and save only
 *	markers caused by HTM_TRIG writes,
 */
enum HTMSC_MODE_MARKERS_ONLY
{
    HTMSC_MODE_MARKERS_ONLY_DISABLE                                = 0x00000000,
    HTMSC_MODE_MARKERS_ONLY_ENABLE                                 = 0x00000001,
};

/**
 *  @brief Nest HTM: Group scope option. HTM Collection Mode Register (18).
 *	This is a powerbus debug bit 0 = htm write ops sent with group
 *	scope 1 = htm write ops sent with Vg scope using programmed target
 *	bits.
 */
enum HTMSC_MODE_DIS_FORCE_GROUP_SCOPE
{
    HTMSC_MODE_DIS_FORCE_GROUP_SCOPE_DISABLE                       = 0x00000000,
    HTMSC_MODE_DIS_FORCE_GROUP_SCOPE_ENABLE                        = 0x00000001,
};

/**
 *  @brief Setting of memory scope for HTM collection. HTM Memory
 *	Configuration Register (1:3)
 */
enum HTMSC_MEM_SCOPE
{
    HTMSC_MEM_SCOPE_LOCAL                                          = 0x00000000,
    HTMSC_MEM_SCOPE_NEARNODE                                       = 0x00000001,
    HTMSC_MEM_SCOPE_GROUP                                          = 0x00000003,
    HTMSC_MEM_SCOPE_REMOTE                                         = 0x00000004,
    HTMSC_MEM_SCOPE_VECTORED                                       = 0x00000005,
};

/**
 *  @brief Setting of memory priority for HTM collection. HTM Memory
 *	Configuration Register (4)
 */
enum HTMSC_MEM_PRIORITY
{
    HTMSC_MEM_PRIORITY_LOW                                         = 0x00000000,
    HTMSC_MEM_PRIORITY_HIGH                                        = 0x00000001,
};

/**
 *  @brief Setting of Trigger control for NHTM. HTM Trigger Control
 *	Register (0:1) 00 local triggers are not forwarded to the PowerBus,
 *	it is inserted into the trace when tracing. Both local and global
 *	triggers control the HTM 01 local triggers are not forwarded to the
 *	PowerBus, it is inserted into the traCe when tracing. Only local
 *	triggers control the HTM 1x local triggers are forwarded to the
 *	PowerBus, it is not inserted into the trace when tracing. Only
 *	global triggers control the HTM
 */
enum NHTM_CTRL_TRIG
{
    NHTM_CTRL_TRIG_LOCAL_GLOBAL                                    = 0x00000000,
    NHTM_CTRL_TRIG_LOCAL                                           = 0x00000001,
    NHTM_CTRL_TRIG_GLOBAL                                          = 0x00000002,
};

/**
 *  @brief Setting of Mark control for NHTM. HTM Trigger Control Register
 *	(4:5) 00 local markers are not forwarded to the PowerBus. Both
 *	local and global markers are inserted into the trace 01 local
 *	markers are not forwarded to the PowerBus. Only local markers are
 *	inserted into the trace 10 local markers are forwarded to the
 *	PowerBus. Only global markers are inserted into the trace 11 local
 *	markers are forwarded to the PowerBus. Markers are not inserted
 *	into the trace (Fabric Trace Mode)
 */
enum NHTM_CTRL_MARK
{
    NHTM_CTRL_MARK_LOCAL_GLOBAL                                    = 0x00000000,
    NHTM_CTRL_MARK_LOCAL_MARK                                      = 0x00000001,
    NHTM_CTRL_MARK_GLOBAL_MARK                                     = 0x00000002,
    NHTM_CTRL_MARK_NO_MARK                                         = 0x00000003,
};

/**
 *  @brief Setting of Trigger control. HTM Trigger Control Register (0:1)
 *	00 local triggers are not forwarded to the PowerBus, it is inserted
 *	into the trace when tracing. Both local and global triggers control
 *	the HTM 01 local triggers are not forwarded to the PowerBus, it is
 *	inserted into the traCe when tracing. Only local triggers control
 *	the HTM 1x local triggers are forwarded to the PowerBus, it is not
 *	inserted into the trace when tracing. Only global triggers control
 *	the HTM
 */
enum CHTM_CTRL_TRIG
{
    CHTM_CTRL_TRIG_LOCAL_GLOBAL                                    = 0x00000000,
    CHTM_CTRL_TRIG_LOCAL                                           = 0x00000001,
    CHTM_CTRL_TRIG_GLOBAL                                          = 0x00000002,
};

/**
 *  @brief Setting of Mark control. HTM Trigger Control Register (4:5) 00
 *	local markers are not forwarded to the PowerBus. Both local and
 *	global markers are inserted into the trace 01 local markers are not
 *	forwarded to the PowerBus. Only local markers are inserted into the
 *	trace 10 local markers are forwarded to the PowerBus. Only global
 *	markers are inserted into the trace 11 local markers are forwarded
 *	to the PowerBus. Markers are not inserted into the trace (Fabric
 *	Trace Mode)
 */
enum CHTM_CTRL_MARK
{
    CHTM_CTRL_MARK_LOCAL_GLOBAL                                    = 0x00000000,
    CHTM_CTRL_MARK_LOCAL_MARK                                      = 0x00000001,
    CHTM_CTRL_MARK_GLOBAL_MARK                                     = 0x00000002,
    CHTM_CTRL_MARK_NO_MARK                                         = 0x00000003,
};

/**
 *  @brief Enable Stop on PB Chiplet Debug Trigger 0. HTM Trigger Control
 *	Register (6)
 */
enum HTMSC_CTRL_DBG0_STOP
{
    HTMSC_CTRL_DBG0_STOP_DISABLE                                   = 0x00000000,
    HTMSC_CTRL_DBG0_STOP_ENABLE                                    = 0x00000001,
};

/**
 *  @brief Enable Stop on PB Chiplet Debug Trigger 1. HTM Trigger Control
 *	Register (7)
 */
enum HTMSC_CTRL_DBG1_STOP
{
    HTMSC_CTRL_DBG1_STOP_DISABLE                                   = 0x00000000,
    HTMSC_CTRL_DBG1_STOP_ENABLE                                    = 0x00000001,
};

/**
 *  @brief Enable trace stop on falling edge of PB chiplet trace run. HTM
 *	Trigger Control Register (8)
 */
enum HTMSC_CTRL_RUN_STOP
{
    HTMSC_CTRL_RUN_STOP_DISABLE                                    = 0x00000000,
    HTMSC_CTRL_RUN_STOP_ENABLE                                     = 0x00000001,
};

/**
 *  @brief Enable Stop using OCC Control. HTM Trigger Control Register (9)
 */
enum HTMSC_CTRL_OTHER_DBG0_STOP
{
    HTMSC_CTRL_OTHER_DBG0_STOP_DISABLE                             = 0x00000000,
    HTMSC_CTRL_OTHER_DBG0_STOP_ENABLE                              = 0x00000001,
};

/**
 *  @brief Enable Stop on chiplet XSTOP. HTM Trigger Control Register (13)
 *	Platform to default to 0x1
 */
enum HTMSC_CTRL_XSTOP_STOP
{
    HTMSC_CTRL_XSTOP_STOP_ENABLE                                   = 0x00000000,
    HTMSC_CTRL_XSTOP_STOP_DISABLE                                  = 0x00000001,
};

/**
 *  @brief Stop on PC_TC_DBG_Trigger0 1 = stop trigger Core Debug Trigger 0
 *	0 = ignore Core Debug Trigger 0
 */
enum HTMSC_CTRL_CHIP0_STOP
{
    HTMSC_CTRL_CHIP0_STOP_DISABLE                                  = 0x00000000,
    HTMSC_CTRL_CHIP0_STOP_ENABLE                                   = 0x00000001,
};

/**
 *  @brief Stop on PC_TC_DBG_Trigger1 1 = stop trigger Core Debug Trigger 1
 *	0 = ignore Core Debug Trigger 1
 */
enum HTMSC_CTRL_CHIP1_STOP
{
    HTMSC_CTRL_CHIP1_STOP_DISABLE                                  = 0x00000000,
    HTMSC_CTRL_CHIP1_STOP_ENABLE                                   = 0x00000001,
};

/**
 *  @brief This bit controls the indexing of the PDBAR address for the
 *	starting address of the write to the PDBAR space. For CHTM only. 0
 *	'Big Core' mode. 1 'Split Core' mode.
 */
enum HTMSC_IMA_PDBAR_SPLIT_CORE_MODE
{
    HTMSC_IMA_PDBAR_SPLIT_CORE_MODE_DISABLE                        = 0x00000000,
    HTMSC_IMA_PDBAR_SPLIT_CORE_MODE_ENABLE                         = 0x00000001,
};

/**
 *  @brief This register defines the starting Scope of the PowerBus
 *	operation. The Scope will be increased if necessary however it is
 *	more efficient to have the request issued according to where the
 *	target memory is located. 000 LOCAL scope 001 Reserved 010 NEAR
 *	NODE scope (Nn) 011 GROUP scope (G). 100 REMOTE scope (Rn). 101
 *	VECTORED group scope (Vg). 110 Reserved 111 Reserved Note 1: Since
 *	P9 uses a Group Class MCD, the HTM will always force a 'Nodal'
 *	scope to 'Group' scope. If the scope is initialized to 'Vectored
 *	Group Scope', the HTM_MODE[Vg_Target] bits must also be
 *	initialized.
 */
enum HTMSC_IMA_PDBAR_SCOPE
{
    HTMSC_IMA_PDBAR_SCOPE_LOCAL                                    = 0x00000000,
    HTMSC_IMA_PDBAR_SCOPE_NEARNODE                                 = 0x00000002,
    HTMSC_IMA_PDBAR_SCOPE_GROUP                                    = 0x00000003,
    HTMSC_IMA_PDBAR_SCOPE_REMOTE                                   = 0x00000004,
    HTMSC_IMA_PDBAR_SCOPE_VECTORED                                 = 0x00000005,
};

/**
 *  @brief Flags to indicate if rx / tx dccal has been run.
 */
enum IO_DMI_PROC_DCCAL_FLAGS
{
    IO_DMI_PROC_DCCAL_FLAGS_NONE                                   = 0x00000000,
    IO_DMI_PROC_DCCAL_FLAGS_TX                                     = 0x00000001,
    IO_DMI_PROC_DCCAL_FLAGS_RX                                     = 0x00000002,
};

/**
 *  @brief Indicate if debug data should be taken pre / post linktraining.
 */
enum IO_DMI_PROC_DEBUG
{
    IO_DMI_PROC_DEBUG_FALSE                                        = 0x00000000,
    IO_DMI_PROC_DEBUG_TRUE                                         = 0x00000001,
};

/**
 *  @brief Flags to indicate if rx / tx dccal has been run.
 */
enum IO_OBUS_DCCAL_FLAGS
{
    IO_OBUS_DCCAL_FLAGS_NONE                                       = 0x00000000,
    IO_OBUS_DCCAL_FLAGS_TX                                         = 0x00000001,
    IO_OBUS_DCCAL_FLAGS_RX                                         = 0x00000002,
};

/**
 *  @brief Indicate if debug data should be taken pre / post linktraining.
 */
enum IO_O_DEBUG
{
    IO_O_DEBUG_FALSE                                               = 0x00000000,
    IO_O_DEBUG_TRUE                                                = 0x00000001,
};

/**
 *  @brief Indicate if manufcaturing tests should be taken pre / post
 *	linktraining.
 */
enum IO_O_MFG_CHK
{
    IO_O_MFG_CHK_FALSE                                             = 0x00000000,
    IO_O_MFG_CHK_TRUE                                              = 0x00000001,
};

/**
 *  @brief Flags to indicate if rx / tx dccal has been run.
 */
enum IO_XBUS_DCCAL_FLAGS
{
    IO_XBUS_DCCAL_FLAGS_NONE                                       = 0x00000000,
    IO_XBUS_DCCAL_FLAGS_TX                                         = 0x00000001,
    IO_XBUS_DCCAL_FLAGS_RX                                         = 0x00000002,
};

/**
 *  @brief Indicate if debug data should be taken pre / post linktraining.
 */
enum IO_X_DEBUG
{
    IO_X_DEBUG_FALSE                                               = 0x00000000,
    IO_X_DEBUG_TRUE                                                = 0x00000001,
};

/**
 *  @brief Indicate if manufacturing tests should be taken pre / post
 *	linktraining.
 */
enum IO_X_MFG_CHK
{
    IO_X_MFG_CHK_FALSE                                             = 0x00000000,
    IO_X_MFG_CHK_TRUE                                              = 0x00000001,
};

/**
 *  @brief Flag to indicate if the target is a master.
 */
enum IO_XBUS_MASTER_MODE
{
    IO_XBUS_MASTER_MODE_FALSE                                      = 0x00000000,
    IO_XBUS_MASTER_MODE_TRUE                                       = 0x00000001,
};

/**
 *  @brief PCIE MMIO BAR enable creator: platform consumer: p9_pcie_config
 *	firmware notes: Array index: BAR number (0:2) index 0~1 for MMIO
 *	BAR0/1 index 2 for PHB register space
 */
enum PROC_PCIE_BAR_ENABLE
{
    PROC_PCIE_BAR_ENABLE_DISABLE                                   = 0x00000000,
    PROC_PCIE_BAR_ENABLE_ENABLE                                    = 0x00000001,
};

/**
 *  @brief PCIE MMIO BAR size values creator: platform consumer:
 *	p9_pcie_config firmware notes: Array index: BAR number (0:2) NOTE:
 *	supported MMIO BAR0/1 sizes are from 64KB-32PB NOTE: only supported
 *	PHB register size is 16KB
 */
enum PROC_PCIE_BAR_SIZE
{
    PROC_PCIE_BAR_SIZE_32_PB                                       = 0x8000000000000000,
    PROC_PCIE_BAR_SIZE_16_PB                                       = 0xC000000000000000,
    PROC_PCIE_BAR_SIZE_8_PB                                        = 0xE000000000000000,
    PROC_PCIE_BAR_SIZE_4_PB                                        = 0xF000000000000000,
    PROC_PCIE_BAR_SIZE_2_PB                                        = 0xF800000000000000,
    PROC_PCIE_BAR_SIZE_1_PB                                        = 0xFC00000000000000,
    PROC_PCIE_BAR_SIZE_512_TB                                      = 0xFE00000000000000,
    PROC_PCIE_BAR_SIZE_256_TB                                      = 0xFF00000000000000,
    PROC_PCIE_BAR_SIZE_128_TB                                      = 0xFF80000000000000,
    PROC_PCIE_BAR_SIZE_64_TB                                       = 0xFFC0000000000000,
    PROC_PCIE_BAR_SIZE_32_TB                                       = 0xFFE0000000000000,
    PROC_PCIE_BAR_SIZE_16_TB                                       = 0xFFF0000000000000,
    PROC_PCIE_BAR_SIZE_8_TB                                        = 0xFFF8000000000000,
    PROC_PCIE_BAR_SIZE_4_TB                                        = 0xFFFC000000000000,
    PROC_PCIE_BAR_SIZE_2_TB                                        = 0xFFFE000000000000,
    PROC_PCIE_BAR_SIZE_1_TB                                        = 0xFFFF000000000000,
    PROC_PCIE_BAR_SIZE_512_GB                                      = 0xFFFF800000000000,
    PROC_PCIE_BAR_SIZE_256_GB                                      = 0xFFFFC00000000000,
    PROC_PCIE_BAR_SIZE_128_GB                                      = 0xFFFFE00000000000,
    PROC_PCIE_BAR_SIZE_64_GB                                       = 0xFFFFF00000000000,
    PROC_PCIE_BAR_SIZE_32_GB                                       = 0xFFFFF80000000000,
    PROC_PCIE_BAR_SIZE_16_GB                                       = 0xFFFFFC0000000000,
    PROC_PCIE_BAR_SIZE_8_GB                                        = 0xFFFFFE0000000000,
    PROC_PCIE_BAR_SIZE_4_GB                                        = 0xFFFFFF0000000000,
    PROC_PCIE_BAR_SIZE_2_GB                                        = 0xFFFFFF8000000000,
    PROC_PCIE_BAR_SIZE_1_GB                                        = 0xFFFFFFC000000000,
    PROC_PCIE_BAR_SIZE_512_MB                                      = 0xFFFFFFE000000000,
    PROC_PCIE_BAR_SIZE_256_MB                                      = 0xFFFFFFF000000000,
    PROC_PCIE_BAR_SIZE_128_MB                                      = 0xFFFFFFF800000000,
    PROC_PCIE_BAR_SIZE_64_MB                                       = 0xFFFFFFFC00000000,
    PROC_PCIE_BAR_SIZE_32_MB                                       = 0xFFFFFFFE00000000,
    PROC_PCIE_BAR_SIZE_16_MB                                       = 0xFFFFFFFF00000000,
    PROC_PCIE_BAR_SIZE_8_MB                                        = 0xFFFFFFFF80000000,
    PROC_PCIE_BAR_SIZE_4_MB                                        = 0xFFFFFFFFC0000000,
    PROC_PCIE_BAR_SIZE_2_MB                                        = 0xFFFFFFFFE0000000,
    PROC_PCIE_BAR_SIZE_1_MB                                        = 0xFFFFFFFFF0000000,
    PROC_PCIE_BAR_SIZE_512_KB                                      = 0xFFFFFFFFF8000000,
    PROC_PCIE_BAR_SIZE_256_KB                                      = 0xFFFFFFFFFC000000,
    PROC_PCIE_BAR_SIZE_128_KB                                      = 0xFFFFFFFFFE000000,
    PROC_PCIE_BAR_SIZE_64_KB                                       = 0xFFFFFFFFFF000000,
    PROC_PCIE_BAR_SIZE_16_KB                                       = 0xFFFFFFFFFFFFFFFF,
};

/**
 *  @brief FSP BAR enable creator: platform consumer: p9_setup_bars
 *	firmware notes: none
 */
enum PROC_FSP_BAR_ENABLE
{
    PROC_FSP_BAR_ENABLE_DISABLE                                    = 0x00000000,
    PROC_FSP_BAR_ENABLE_ENABLE                                     = 0x00000001,
};

/**
 *  @brief FSP BAR size value creator: platform consumer: p9_setup_bars
 *	firmware notes: none
 */
enum PROC_FSP_BAR_SIZE
{
    PROC_FSP_BAR_SIZE_4_GB                                         = 0xFFFFFC00FFFFFFFF,
    PROC_FSP_BAR_SIZE_2_GB                                         = 0xFFFFFC007FFFFFFF,
    PROC_FSP_BAR_SIZE_1_GB                                         = 0xFFFFFC003FFFFFFF,
    PROC_FSP_BAR_SIZE_512_MB                                       = 0xFFFFFC001FFFFFFF,
    PROC_FSP_BAR_SIZE_256_MB                                       = 0xFFFFFC000FFFFFFF,
    PROC_FSP_BAR_SIZE_128_MB                                       = 0xFFFFFC0007FFFFFF,
    PROC_FSP_BAR_SIZE_64_MB                                        = 0xFFFFFC0003FFFFFF,
    PROC_FSP_BAR_SIZE_32_MB                                        = 0xFFFFFC0001FFFFFF,
    PROC_FSP_BAR_SIZE_16_MB                                        = 0xFFFFFC0000FFFFFF,
    PROC_FSP_BAR_SIZE_8_MB                                         = 0xFFFFFC00007FFFFF,
    PROC_FSP_BAR_SIZE_4_MB                                         = 0xFFFFFC00003FFFFF,
    PROC_FSP_BAR_SIZE_2_MB                                         = 0xFFFFFC00001FFFFF,
    PROC_FSP_BAR_SIZE_1_MB                                         = 0xFFFFFC00000FFFFF,
};

/**
 *  @brief FSP MMIO mask size value creator: platform consumer:
 *	p9_setup_bars firmware notes: AND mask applied to RA 32:35 when
 *	transmitting address to FSP NOTE: RA 8:31 are always replaced with
 *	zero
 */
enum PROC_FSP_MMIO_MASK_SIZE
{
    PROC_FSP_MMIO_MASK_SIZE_4_GB                                   = 0xF0000000000000,
    PROC_FSP_MMIO_MASK_SIZE_2_GB                                   = 0x70000000000000,
    PROC_FSP_MMIO_MASK_SIZE_1_GB                                   = 0x30000000000000,
    PROC_FSP_MMIO_MASK_SIZE_512_MB                                 = 0x10000000000000,
    PROC_FSP_MMIO_MASK_SIZE_256_MB                                 = 0x00000000,
};

/**
 *  @brief NPU PHY0 (stack0) BAR enable creator: platform consumer:
 *	p9_setup_bars firmware notes: none
 */
enum PROC_NPU_PHY0_BAR_ENABLE
{
    PROC_NPU_PHY0_BAR_ENABLE_DISABLE                               = 0x00000000,
    PROC_NPU_PHY0_BAR_ENABLE_ENABLE                                = 0x00000001,
};

/**
 *  @brief NPU PHY1 (stack1) BAR enable creator: platform consumer:
 *	p9_setup_bars firmware notes: none
 */
enum PROC_NPU_PHY1_BAR_ENABLE
{
    PROC_NPU_PHY1_BAR_ENABLE_DISABLE                               = 0x00000000,
    PROC_NPU_PHY1_BAR_ENABLE_ENABLE                                = 0x00000001,
};

/**
 *  @brief NPU MMIO (stack2) BAR enable creator: platform consumer:
 *	p9_setup_bars firmware notes: none
 */
enum PROC_NPU_MMIO_BAR_ENABLE
{
    PROC_NPU_MMIO_BAR_ENABLE_DISABLE                               = 0x00000000,
    PROC_NPU_MMIO_BAR_ENABLE_ENABLE                                = 0x00000001,
};

/**
 *  @brief PSI Bridge BAR enable creator: platform consumer: p9_setup_bars
 *	firmware notes: none
 */
enum PROC_PSI_BRIDGE_BAR_ENABLE
{
    PROC_PSI_BRIDGE_BAR_ENABLE_DISABLE                             = 0x00000000,
    PROC_PSI_BRIDGE_BAR_ENABLE_ENABLE                              = 0x00000001,
};

/**
 *  @brief NX RNG BAR enable creator: platform consumer: p9_rng_init_phase2
 *	firmware notes: none
 */
enum PROC_NX_RNG_BAR_ENABLE
{
    PROC_NX_RNG_BAR_ENABLE_DISABLE                                 = 0x00000000,
    PROC_NX_RNG_BAR_ENABLE_ENABLE                                  = 0x00000001,
};

/**
 *  @brief Enable optional post of interrupt when both NX RNG noise sources
 *	have failed creator: platform consumer: p9_rng_init_phase2 firmware
 *	notes: none
 */
enum PROC_NX_RNG_FAILED_INT_ENABLE
{
    PROC_NX_RNG_FAILED_INT_ENABLE_DISABLE                          = 0x00000000,
    PROC_NX_RNG_FAILED_INT_ENABLE_ENABLE                           = 0x00000001,
};

/**
 *  @brief INT CQ PC BAR enable creator: platform consumer: p9_setup_bars
 *	firmware notes: none
 */
enum PROC_INT_CQ_PC_BAR_ENABLE
{
    PROC_INT_CQ_PC_BAR_ENABLE_DISABLE                              = 0x00000000,
    PROC_INT_CQ_PC_BAR_ENABLE_ENABLE                               = 0x00000001,
};

/**
 *  @brief INT CQ VC BAR enable creator: platform consumer: p9_setup_bars
 *	firmware notes: none
 */
enum PROC_INT_CQ_VC_BAR_ENABLE
{
    PROC_INT_CQ_VC_BAR_ENABLE_DISABLE                              = 0x00000000,
    PROC_INT_CQ_VC_BAR_ENABLE_ENABLE                               = 0x00000001,
};

/**
 *  @brief INT CQ TM1 BAR enable creator: platform consumer: p9_setup_bars
 *	firmware notes: none
 */
enum PROC_INT_CQ_TM1_BAR_ENABLE
{
    PROC_INT_CQ_TM1_BAR_ENABLE_DISABLE                             = 0x00000000,
    PROC_INT_CQ_TM1_BAR_ENABLE_ENABLE                              = 0x00000001,
};

/**
 *  @brief INT CQ TM1 BAR page size creator: platform consumer:
 *	p9_setup_bars firmware notes: none
 */
enum PROC_INT_CQ_TM1_BAR_PAGE_SIZE
{
    PROC_INT_CQ_TM1_BAR_PAGE_SIZE_4K                               = 0x00000000,
    PROC_INT_CQ_TM1_BAR_PAGE_SIZE_64K                              = 0x00000001,
};

/**
 *  @brief INT CQ IC BAR enable creator: platform consumer: p9_setup_bars
 *	firmware notes: none
 */
enum PROC_INT_CQ_IC_BAR_ENABLE
{
    PROC_INT_CQ_IC_BAR_ENABLE_DISABLE                              = 0x00000000,
    PROC_INT_CQ_IC_BAR_ENABLE_ENABLE                               = 0x00000001,
};

/**
 *  @brief INT CQ IC (Interrupt Controller) BAR page size creator: platform
 *	consumer: p9_setup_bars firmware notes: none
 */
enum PROC_INT_CQ_IC_BAR_PAGE_SIZE
{
    PROC_INT_CQ_IC_BAR_PAGE_SIZE_4K                                = 0x00000000,
    PROC_INT_CQ_IC_BAR_PAGE_SIZE_64K                               = 0x00000001,
};

/**
 *  @brief Indicates istep IPL
 */
enum ISTEP_MODE
{
    ISTEP_MODE_NON_IPL                                             = 0x00000000,
    ISTEP_MODE_IPL                                                 = 0x00000001,
};

/**
 *  @brief Indicates that SBE should go directly to runtime functionality
 */
enum SBE_RUNTIME_MODE
{
    SBE_RUNTIME_MODE_FALSE                                         = 0x00000000,
    SBE_RUNTIME_MODE_TRUE                                          = 0x00000001,
};

/**
 *  @brief Indicates whether we are connected to FSP or not
 */
enum IS_SP_MODE
{
    IS_SP_MODE_FSP_LESS                                            = 0x00000000,
    IS_SP_MODE_FSP                                                 = 0x00000001,
};

/**
 *  @brief Indicates whether SBE should collect FFDC
 */
enum SBE_FFDC_ENABLE
{
    SBE_FFDC_ENABLE_FALSE                                          = 0x00000000,
    SBE_FFDC_ENABLE_TRUE                                           = 0x00000001,
};

/**
 *  @brief Indicates that the SBE should send back internal FFDC on any
 *	chipOp failure response
 */
enum SBE_INTERNAL_FFDC_ENABLE
{
    SBE_INTERNAL_FFDC_ENABLE_FALSE                                 = 0x00000000,
    SBE_INTERNAL_FFDC_ENABLE_TRUE                                  = 0x00000001,
};

/**
 *  @brief HWP/Init "risk level" enabled. Used by HB to pass to HB driven
 *	HWPs
 */
enum RISK_LEVEL
{
    RISK_LEVEL_FALSE                                               = 0x00000000,
    RISK_LEVEL_TRUE                                                = 0x00000001,
};

/**
 *  @brief BootLoader HWP flag to not place 12K exception vectors. This
 *	flag is only applicable when security is disabled.
 */
enum DISABLE_HBBL_VECTORS
{
    DISABLE_HBBL_VECTORS_FALSE                                     = 0x00000000,
    DISABLE_HBBL_VECTORS_TRUE                                      = 0x00000001,
};

/**
 *  @brief MC mesh to use Nest mesh or not
 */
enum MC_SYNC_MODE
{
    MC_SYNC_MODE_IN_SYNC                                           = 0x00000001,
    MC_SYNC_MODE_NOT_IN_SYNC                                       = 0x00000000,
};

/**
 *  @brief Indicates if SBE on this chip is serving as hosboot drawer
 *	master
 */
enum PROC_SBE_MASTER_CHIP
{
    PROC_SBE_MASTER_CHIP_FALSE                                     = 0x00000000,
    PROC_SBE_MASTER_CHIP_TRUE                                      = 0x00000001,
};

/**
 *  @brief Defines system specific value of processor refclock receiver
 *	termination
 */
enum CP_REFCLOCK_RCVR_TERM
{
    CP_REFCLOCK_RCVR_TERM_NONE                                     = 0x00000000,
    CP_REFCLOCK_RCVR_TERM_FIFTY_OHM                                = 0x00000001,
};

/**
 *  @brief Defines system specific value of PCI refclock receiver
 *	termination
 */
enum IO_REFCLOCK_RCVR_TERM
{
    IO_REFCLOCK_RCVR_TERM_NONE                                     = 0x00000000,
    IO_REFCLOCK_RCVR_TERM_FIFTY_OHM                                = 0x00000001,
    IO_REFCLOCK_RCVR_TERM_ONE_HUNDRED_OHM                          = 0x00000003,
};

/**
 *  @brief Allow skipping fifo reset during p9_start_cbs, to enable systems
 *	without cfam access to fifo registers (WAFER/RBI).
 */
enum START_CBS_FIFO_RESET_SKIP
{
    START_CBS_FIFO_RESET_SKIP_FALSE                                = 0x00000000,
    START_CBS_FIFO_RESET_SKIP_TRUE                                 = 0x00000001,
};

/**
 *  @brief To allow for selective enablement for lab testing To allow skew
 *	function to be enabled/disabled.
 */
enum SYSTEM_CORECACHE_SKEWADJ_DISABLE
{
    SYSTEM_CORECACHE_SKEWADJ_DISABLE_FALSE                         = 0x00000000,
    SYSTEM_CORECACHE_SKEWADJ_DISABLE_TRUE                          = 0x00000001,
};

/**
 *  @brief To allow for selective enablement for lab testing To allow dcadj
 *	function to be enabled/disabled.
 */
enum SYSTEM_CORECACHE_DCADJ_DISABLE
{
    SYSTEM_CORECACHE_DCADJ_DISABLE_FALSE                           = 0x00000000,
    SYSTEM_CORECACHE_DCADJ_DISABLE_TRUE                            = 0x00000001,
};

/**
 *  @brief SPIPSS Clock Polarity CPOL=0 means that clk idle is deasserted,
 *	CPOH=1 means that clk idle is asserted
 */
enum PM_SPIPSS_CLOCK_POLARITY
{
    PM_SPIPSS_CLOCK_POLARITY_CPOL                                  = 0x00000000,
    PM_SPIPSS_CLOCK_POLARITY_CPOH                                  = 0x00000001,
};

/**
 *  @brief SPIPSS clock phase CPHA=0 means to change/sample values of data
 *	signals on first edge, otherwise on 2nd
 */
enum PM_SPIPSS_CLOCK_PHASE
{
    PM_SPIPSS_CLOCK_PHASE_FIRSTEDGE                                = 0x00000000,
    PM_SPIPSS_CLOCK_PHASE_SECONDEDGE                               = 0x00000001,
};

/**
 *  @brief Indicator that all relevant attributes and required data for
 *	Pstates to be enabled is present and valid Producer:
 *	p9_build_pstate_datablock Consumers: p9_pm_pstate_gpe_init
 */
enum PSTATES_ENABLED
{
    PSTATES_ENABLED_FALSE                                          = 0x00000000,
    PSTATES_ENABLED_TRUE                                           = 0x00000001,
};

/**
 *  @brief Indicator that all relevant attributes and required data for
 *	Resonant Clocking to be enabled is present and valid Producer:
 *	p9_build_pstate_datablock Consumers: p9_hcode_image_build -> PGPE
 *	Header CME Header
 */
enum RESCLK_ENABLED
{
    RESCLK_ENABLED_FALSE                                           = 0x00000000,
    RESCLK_ENABLED_TRUE                                            = 0x00000001,
};

/**
 *  @brief Indicator that all relevant attributes and required data for
 *	Voltage Droop Monitors (VDM) to be enabled is present and valid
 *	Producer: p9_build_pstate_datablock Consumers: p9_hcode_image_build
 *	-> SGPE Header CME Header
 */
enum VDM_ENABLED
{
    VDM_ENABLED_FALSE                                              = 0x00000000,
    VDM_ENABLED_TRUE                                               = 0x00000001,
};

/**
 *  @brief Indicator that all relevant attributes and required data for
 *	Internal Voltage Regulator Macros (IVRMs) to be enabled is present
 *	and valid Producer: p9_build_pstate_datablock Consumers:
 *	p9_hcode_image_build -> PGPE Header CME Header
 */
enum IVRM_ENABLED
{
    IVRM_ENABLED_FALSE                                             = 0x00000000,
    IVRM_ENABLED_TRUE                                              = 0x00000001,
};

/**
 *  @brief Indicator that all relevent attributes and required data for WOF
 *	to be enabled is present and valid Producer:
 *	p9_build_pstate_datablock Consumers: p9_hcode_image_build -> PGPE
 *	Header CME Header
 */
enum WOF_ENABLED
{
    WOF_ENABLED_FALSE                                              = 0x00000000,
    WOF_ENABLED_TRUE                                               = 0x00000001,
};

/**
 *  @brief Indicates that a special wakeup is in progress for a core.
 *	Producer: p9_cpu_special_wakeup_core.C Consumers:
 *	p9_cpu_special_wakeup_core.C
 */
enum CORE_INSIDE_SPECIAL_WAKEUP
{
    CORE_INSIDE_SPECIAL_WAKEUP_FALSE                               = 0x00000000,
    CORE_INSIDE_SPECIAL_WAKEUP_TRUE                                = 0x00000001,
};

/**
 *  @brief Indicates that a special wakeup is in progress for an EX.
 *	Producer: p9_cpu_special_wakeup_ex.C Consumers:
 *	p9_cpu_special_wakeup_ex.C
 */
enum EX_INSIDE_SPECIAL_WAKEUP
{
    EX_INSIDE_SPECIAL_WAKEUP_FALSE                                 = 0x00000000,
    EX_INSIDE_SPECIAL_WAKEUP_TRUE                                  = 0x00000001,
};

/**
 *  @brief Indicates that a special wakeup is in progress for an EQ
 *	Producer: p9_cpu_special_wakeup_eq.C Consumers:
 *	p9_cpu_special_wakeup_eq.C
 */
enum EQ_INSIDE_SPECIAL_WAKEUP
{
    EQ_INSIDE_SPECIAL_WAKEUP_FALSE                                 = 0x00000000,
    EQ_INSIDE_SPECIAL_WAKEUP_TRUE                                  = 0x00000001,
};

/**
 *  @brief Control CME response to execution of PowerPC STOP instruction if
 *	OFF, treat STOP4 as STOP4 if ON, treat STOP4 as STOP2 Producer:
 *	Work-around tools Consumer: p9_hcode_image_build.C Platform
 *	default: OFF
 */
enum STOP4_DISABLE
{
    STOP4_DISABLE_OFF                                              = 0x00000000,
    STOP4_DISABLE_ON                                               = 0x00000001,
};

/**
 *  @brief Control CME response to execution of PowerPC STOP instruction if
 *	OFF, treat STOP5 as STOP5 if ON, treat STOP5 as STOP4 Producer: ???
 *	Consumer: p9_hcode_image_build.C Platform default: ON
 */
enum STOP5_DISABLE
{
    STOP5_DISABLE_OFF                                              = 0x00000000,
    STOP5_DISABLE_ON                                               = 0x00000001,
};

/**
 *  @brief Control CME response to execution of PowerPC STOP instruction if
 *	OFF, treat STOP8 as STOP8 if ON, treat STOP8 as STOP4 Producer:
 *	Work-around tools Consumer: p9_hcode_image_build.C Platform
 *	default: OFF
 */
enum STOP8_DISABLE
{
    STOP8_DISABLE_OFF                                              = 0x00000000,
    STOP8_DISABLE_ON                                               = 0x00000001,
};

/**
 *  @brief Control CME response to execution of PowerPC STOP instruction if
 *	OFF, treat STOP11 as STOP11 if ON, treat STOP11 as STOP8 Producer:
 *	Work-around tools Consumer: p9_hcode_image_build.C Platform
 *	default: OFF
 */
enum STOP11_DISABLE
{
    STOP11_DISABLE_OFF                                             = 0x00000000,
    STOP11_DISABLE_ON                                              = 0x00000001,
};

/**
 *  @brief Disable the Core Periodic Quiesce Hang Buster function Producer:
 *	Lab tools Consumer: p9_hcode_image_build.C -> SGPE Hcode -> CME
 *	Hcode Platform default: OFF
 */
enum SYSTEM_CORE_PERIODIC_QUIESCE_DISABLE
{
    SYSTEM_CORE_PERIODIC_QUIESCE_DISABLE_OFF                       = 0x00000000,
    SYSTEM_CORE_PERIODIC_QUIESCE_DISABLE_ON                        = 0x00000001,
};

/**
 *  @brief Disables Work Load Optimized Frequency (WOF) algorithms to
 *	modify frequency based on active core count and other inputs. OFF:
 *	Will enable WOF given all validity check pass. If validity checks
 *	fail, WOF will be disabled for the present IPL. ON: Will disable
 *	WOF OFF_SKIP_DD: Same as OFF but skips any validity checking of the
 *	chip design level (lab use only). Producer: Override Consumers:
 *	p9_build_pstate_datablock -> Pstate Parameter Block (PSPB) for
 *	PGPE/OCC
 */
enum SYSTEM_WOF_DISABLE
{
    SYSTEM_WOF_DISABLE_OFF                                         = 0x00000000,
    SYSTEM_WOF_DISABLE_ON                                          = 0x00000001,
    SYSTEM_WOF_DISABLE_OFF_SKIP_DD                                 = 0x00000002,
};

/**
 *  @brief Disables IVRM enablement in the system Producer: Override
 *	Consumers: p9_build_pstate_datablock -> Pstate Parameter Block
 *	(PSPB) for PGPE/OCC CME Quad Pstate Region (CQPR) for CM Quad
 *	Manager
 */
enum SYSTEM_IVRM_DISABLE
{
    SYSTEM_IVRM_DISABLE_OFF                                        = 0x00000000,
    SYSTEM_IVRM_DISABLE_ON                                         = 0x00000001,
};

/**
 *  @brief If wof_enabled, defines the Frequency Ratio calculation
 *	performed. (THIS IS NOT SUPPORTED IN P9 GA1!).
 */
enum WOF_ENABLE_FRATIO
{
    WOF_ENABLE_FRATIO_FIXED                                        = 0x00000000,
    WOF_ENABLE_FRATIO_STEPPED                                      = 0x00000001,
};

/**
 *  @brief If wof_enabled, defines the Voltage Ratio calculation performed.
 *	THIS IS NOT SUPPORTED AT PRESENT. GA1 SUPPORT IS TBD).
 */
enum WOF_ENABLE_VRATIO
{
    WOF_ENABLE_VRATIO_FIXED                                        = 0x00000000,
    WOF_ENABLE_VRATIO_STEPPED                                      = 0x00000001,
};

/**
 *  @brief If wof_enabled AND ATTR_WOF_ENABLE_VRATIO = CALCULATED, this
 *	attribute selects the Vratio calculation type. ACTIVE_CORES: Vratio
 *	is the number of active cores to the number of good cores FULL:
 *	Vratio is Vaverage to Vclip(Fclip) where Vclip(Fclip) is the normal
 *	interpolated regulator voltage (including load line uplife @ RDP
 *	current) derated with presently measured Idd current (from the
 *	AVSBus) and the loadline.
 */
enum WOF_VRATIO_SELECT
{
    WOF_VRATIO_SELECT_ACTIVE_CORES                                 = 0x00000000,
    WOF_VRATIO_SELECT_FULL                                         = 0x00000001,
};

/**
 *  @brief Disables the enablement of Voltage Droop Monitors (VDM) in the
 *	system. Producer: Override Consumers: p9_pstate_parameter_block to
 *	clear flag for CME QuadManager Hcode reaction
 */
enum SYSTEM_VDM_DISABLE
{
    SYSTEM_VDM_DISABLE_OFF                                         = 0x00000000,
    SYSTEM_VDM_DISABLE_ON                                          = 0x00000001,
};

/**
 *  @brief Voltage Droop Monitor (VDM) Small Threshold Select Value per VPD
 *	point The enum indicates a negative value below the VDM setting
 *	that will trigger a small droop event. Array of 5 entries: 0 =
 *	PowerSave, 1 = Nominal; 2 = Turbo; 3 = UltraTurbo; 4 = Enable If
 *	index 4 is non-zero, the other entries are considered valid.
 *	Producer: Override
 */
enum VDM_DROOP_SMALL_OVERRIDE
{
    VDM_DROOP_SMALL_OVERRIDE_OFF                                   = 0x00000000,
    VDM_DROOP_SMALL_OVERRIDE_8mV                                   = 0x00000001,
    VDM_DROOP_SMALL_OVERRIDE_16mV                                  = 0x00000002,
    VDM_DROOP_SMALL_OVERRIDE_24mV                                  = 0x00000003,
    VDM_DROOP_SMALL_OVERRIDE_32mV                                  = 0x00000004,
    VDM_DROOP_SMALL_OVERRIDE_40mV                                  = 0x00000005,
    VDM_DROOP_SMALL_OVERRIDE_48mV                                  = 0x00000006,
    VDM_DROOP_SMALL_OVERRIDE_56mV                                  = 0x00000007,
    VDM_DROOP_SMALL_OVERRIDE_64mV                                  = 0x00000008,
    VDM_DROOP_SMALL_OVERRIDE_72mV                                  = 0x00000009,
    VDM_DROOP_SMALL_OVERRIDE_80mV                                  = 0x0000000A,
    VDM_DROOP_SMALL_OVERRIDE_88mV                                  = 0x0000000B,
    VDM_DROOP_SMALL_OVERRIDE_92mV                                  = 0x0000000C,
    VDM_DROOP_SMALL_OVERRIDE_96mV                                  = 0x0000000D,
};

/**
 *  @brief Voltage Droop Monitor (VDM) Large Threshold Select Value per VPD
 *	point The enum indicates a negative value below the VDM setting
 *	that will trigger a large droop event. Array of 5 entries: 0 =
 *	PowerSave, 1 = Nominal; 2 = Turbo; 3 = UltraTurbo; 4 = Enable If
 *	index 4 is non-zero, the other entries are considered valid.
 *	Producer: Override
 */
enum VDM_DROOP_LARGE_OVERRIDE
{
    VDM_DROOP_LARGE_OVERRIDE_OFF                                   = 0x00000000,
    VDM_DROOP_LARGE_OVERRIDE_8mV                                   = 0x00000001,
    VDM_DROOP_LARGE_OVERRIDE_16mV                                  = 0x00000002,
    VDM_DROOP_LARGE_OVERRIDE_24mV                                  = 0x00000003,
    VDM_DROOP_LARGE_OVERRIDE_32mV                                  = 0x00000004,
    VDM_DROOP_LARGE_OVERRIDE_40mV                                  = 0x00000005,
    VDM_DROOP_LARGE_OVERRIDE_48mV                                  = 0x00000006,
    VDM_DROOP_LARGE_OVERRIDE_56mV                                  = 0x00000007,
    VDM_DROOP_LARGE_OVERRIDE_64mV                                  = 0x00000008,
    VDM_DROOP_LARGE_OVERRIDE_72mV                                  = 0x00000009,
    VDM_DROOP_LARGE_OVERRIDE_80mV                                  = 0x0000000A,
    VDM_DROOP_LARGE_OVERRIDE_88mV                                  = 0x0000000B,
    VDM_DROOP_LARGE_OVERRIDE_92mV                                  = 0x0000000C,
    VDM_DROOP_LARGE_OVERRIDE_96mV                                  = 0x0000000D,
};

/**
 *  @brief Voltage Droop Monitor (VDM) Extreme Threshold Select Value per
 *	VPD point. The enum indicates a negative value below the VDM
 *	setting that will trigger an extreme droop event. Array of 5
 *	entries: 0 = PowerSave, 1 = Nominal; 2 = Turbo; 3 = UltraTurbo; 4 =
 *	Enable If index 4 is non-zero, the other entries are considered
 *	valid. Producer: Override
 */
enum VDM_DROOP_EXTREME_OVERRIDE
{
    VDM_DROOP_EXTREME_OVERRIDE_OFF                                 = 0x00000000,
    VDM_DROOP_EXTREME_OVERRIDE_8mV                                 = 0x00000001,
    VDM_DROOP_EXTREME_OVERRIDE_16mV                                = 0x00000002,
    VDM_DROOP_EXTREME_OVERRIDE_24mV                                = 0x00000003,
    VDM_DROOP_EXTREME_OVERRIDE_32mV                                = 0x00000004,
    VDM_DROOP_EXTREME_OVERRIDE_40mV                                = 0x00000005,
    VDM_DROOP_EXTREME_OVERRIDE_48mV                                = 0x00000006,
    VDM_DROOP_EXTREME_OVERRIDE_56mV                                = 0x00000007,
    VDM_DROOP_EXTREME_OVERRIDE_64mV                                = 0x00000008,
    VDM_DROOP_EXTREME_OVERRIDE_72mV                                = 0x00000009,
    VDM_DROOP_EXTREME_OVERRIDE_80mV                                = 0x0000000A,
    VDM_DROOP_EXTREME_OVERRIDE_88mV                                = 0x0000000B,
    VDM_DROOP_EXTREME_OVERRIDE_92mV                                = 0x0000000C,
    VDM_DROOP_EXTREME_OVERRIDE_96mV                                = 0x0000000D,
};

/**
 *  @brief Voltage Droop Monitor (VDM) OverVoltage Threshold Select Value
 *	per VPD point. The enum indicates a positive value above the VDM
 *	setting that will indicate an overvolt droop condition. Array of 5
 *	entries: 0 = PowerSave, 1 = Nominal; 2 = Turbo; 3 = UltraTurbo; 4 =
 *	Enable If index 4 is non-zero, the other entries are considered
 *	valid. Producer: Override
 */
enum VDM_OVERVOLT_OVERRIDE
{
    VDM_OVERVOLT_OVERRIDE_FORCE                                    = 0x00000000,
    VDM_OVERVOLT_OVERRIDE_8mV                                      = 0x00000001,
    VDM_OVERVOLT_OVERRIDE_16mV                                     = 0x00000002,
    VDM_OVERVOLT_OVERRIDE_24mV                                     = 0x00000003,
    VDM_OVERVOLT_OVERRIDE_32mV                                     = 0x00000004,
    VDM_OVERVOLT_OVERRIDE_40mV                                     = 0x00000005,
    VDM_OVERVOLT_OVERRIDE_48mV                                     = 0x00000006,
    VDM_OVERVOLT_OVERRIDE_56mV                                     = 0x00000007,
    VDM_OVERVOLT_OVERRIDE_64mV                                     = 0x00000008,
};

/**
 *  @brief Controls the enablement of Voltage Droop Monitors (VDM) to
 *	throttle the core upon an extreme droop event. Producer: Machine
 *	Readable Workbook Consumers: p9_hcode_image_build to set flag for
 *	CME QuadManager Hcode reaction
 */
enum VDM_EXTREME_THOTTLE_ENABLE
{
    VDM_EXTREME_THOTTLE_ENABLE_OFF                                 = 0x00000000,
    VDM_EXTREME_THOTTLE_ENABLE_ON                                  = 0x00000001,
};

/**
 *  @brief Indicates the response of the DPLL frequency upon VDM events if
 *	ATTR_SYSTEM_VDM_DISABLE is not ON. NONE -> DPLL Mode 2
 *	DROOP_PROTECT -> DPLL Mode 3 DROOP_PROTECT_OVERVOLT -> DPLL Mode
 *	3.5 DYNAMIC -> DPLL Mode 4 DYNAMIC_PROTECT -> DPLL Mode 5 Producer:
 *	MRWB.
 */
enum DPLL_VDM_RESPONSE
{
    DPLL_VDM_RESPONSE_DROOP_PROTECT                                = 0x00000000,
    DPLL_VDM_RESPONSE_DROOP_PROTECT_OVERVOLT                       = 0x00000001,
    DPLL_VDM_RESPONSE_DYNAMIC                                      = 0x00000002,
    DPLL_VDM_RESPONSE_DYNAMIC_PROTECT                              = 0x00000003,
    DPLL_VDM_RESPONSE_NONE                                         = 0x00000004,
};

/**
 *  @brief Disables the enablement of resonant clocking in the system.
 *	Producer: Override Consumers: p9_pstate_parameter_block to clear
 *	the flag for CME QuadManager Hcode reaction
 */
enum SYSTEM_RESCLK_DISABLE
{
    SYSTEM_RESCLK_DISABLE_OFF                                      = 0x00000000,
    SYSTEM_RESCLK_DISABLE_ON                                       = 0x00000001,
};

/**
 *  @brief Debug modes supported for CME/SGPE Scan layout in HOMER.
 */
enum SYSTEM_RING_DBG_MODE
{
    SYSTEM_RING_DBG_MODE_SCAN_RING_NO_DEBUG                        = 0x00000000,
    SYSTEM_RING_DBG_MODE_SCAN_RING_TRACE_DEBUG                     = 0x00000001,
    SYSTEM_RING_DBG_MODE_SCAN_RING_DEEP_DEBUG                      = 0x00000002,
};

/**
 *  @brief Enables the SGPE Hcode to enable the CME instruction traces into
 *	the L3 Trace array for debug. Note: all configured CMEs will be put
 *	into this mode if this attribute is ON. Consumer:
 *	p9_hcode_image_build.c -> SGPE Header field Platform default: OFF
 */
enum CME_INSTRUCTION_TRACE_ENABLE
{
    CME_INSTRUCTION_TRACE_ENABLE_OFF                               = 0x00000000,
    CME_INSTRUCTION_TRACE_ENABLE_ON                                = 0x00000001,
};

/**
 *  @brief Enables the SGPE Hcode to enable the CME instruction traces into
 *	the CHTM for debug. Note: all configured CMEs will be put into this
 *	mode if this attribute is ON. Consumer: p9_hcode_image_build.c ->
 *	SGPE Header field Platform default: OFF
 */
enum CME_CHTM_TRACE_ENABLE
{
    CME_CHTM_TRACE_ENABLE_OFF                                      = 0x00000000,
    CME_CHTM_TRACE_ENABLE_ON                                       = 0x00000001,
};

/**
 *  @brief Enables the PGPE Hcode to physically perform frequency and
 *	voltage operations based on constructed parameters (eg #V VPD,
 *	system parameters, biases, WPF VFRTs. etc). If OFF, the PGPE
 *	provides an immedicate good response to all Pstate/WOF IPC
 *	operations from the OCC for firmware integration testing purposes.
 *	Consumer: p9_hcode_image_build.c -> PGPE Header field Platform
 *	default: ON
 */
enum PGPE_HCODE_FUNCTION_ENABLE
{
    PGPE_HCODE_FUNCTION_ENABLE_OFF                                 = 0x00000000,
    PGPE_HCODE_FUNCTION_ENABLE_ON                                  = 0x00000001,
};

/**
 *  @brief Enables pstate parameter block code to use the static #W data
 *	Consumer: p9_pstate_parameter_block.C -> Platform default: OFF
 */
enum POUND_W_STATIC_DATA_ENABLE
{
    POUND_W_STATIC_DATA_ENABLE_OFF                                 = 0x00000000,
    POUND_W_STATIC_DATA_ENABLE_ON                                  = 0x00000001,
};

/**
 *  @brief Enables pstate parameter block code to use the static system
 *	vfrt data Consumer: p9_pstate_parameter_block.C -> Platform
 *	default: OFF
 */
enum SYS_VFRT_STATIC_DATA_ENABLE
{
    SYS_VFRT_STATIC_DATA_ENABLE_OFF                                = 0x00000000,
    SYS_VFRT_STATIC_DATA_ENABLE_ON                                 = 0x00000001,
};

/**
 *  @brief Controls the mode of Pstate Protocol for testing. ON: Boots the
 *	PGPE in "OCC Pstate Mode" but does NOT start the Pstate protocol
 *	OFF: Does NOT boot the PGPE AUTO: Boots the PGPE and automatically
 *	starts the Pstate protocol. PMCR operations to move Pstates are
 *	honored Producer: Override Consumers: p9_pstate_parameter_block and
 *	p9_pm_pstate_gpe_init
 */
enum SYSTEM_PSTATES_MODE
{
    SYSTEM_PSTATES_MODE_ON                                         = 0x00000000,
    SYSTEM_PSTATES_MODE_OFF                                        = 0x00000001,
    SYSTEM_PSTATES_MODE_AUTO                                       = 0x00000002,
};

/**
 *  @brief Product name of a chip target. Provided by the MRW.
 */
enum NAME
{
    NAME_NONE                                                      = 0x00000000,
    NAME_CENTAUR                                                   = 0x00000003,
    NAME_NIMBUS                                                    = 0x00000005,
    NAME_CUMULUS                                                   = 0x00000006,
    NAME_AXONE                                                     = 0x00000007,
};

/**
 *  @brief 1 if the target is functional, else 0. Set by the platform.
 */
enum FUNCTIONAL
{
    FUNCTIONAL_NON_FUNCTIONAL                                      = 0x00000000,
    FUNCTIONAL_FUNCTIONAL                                          = 0x00000001,
};

/**
 *  @brief Scratch uint64_t attribute Can be used by HWPs for testing.
 */
enum SCRATCH_UINT64_2
{
    SCRATCH_UINT64_2_VAL_A                                         = 0x00000000,
    SCRATCH_UINT64_2_VAL_B                                         = 0x00000005,
    SCRATCH_UINT64_2_VAL_C                                         = 0xFFFFFFFFFFFFFFFF,
};

/**
 *  @brief Scratch uint64_t[2][2] attribute. Can be used by HWPs for
 *	testing.
 */
enum SCRATCH_UINT64_ARRAY_2
{
    SCRATCH_UINT64_ARRAY_2_VAL_A                                   = 0x123456789ABCDEF,
    SCRATCH_UINT64_ARRAY_2_VAL_B                                   = 0x00000000,
    SCRATCH_UINT64_ARRAY_2_VAL_C                                   = 0xFFFFFFFFFFFFFFFF,
};

/**
 *  @brief Scratch int64_t attribute Can be used by HWPs for testing.
 */
enum SCRATCH_INT64_2
{
    SCRATCH_INT64_2_VAL_A                                          = 0x00000000,
    SCRATCH_INT64_2_VAL_B                                          = 0x00000005,
    SCRATCH_INT64_2_VAL_C                                          = 0xFFFFFFFFFFFFFFFF,
};

/**
 *  @brief Scratch int64_t[2][2] attribute. Can be used by HWPs for
 *	testing.
 */
enum SCRATCH_INT64_ARRAY_2
{
    SCRATCH_INT64_ARRAY_2_VAL_A                                    = 0x123456789ABCDEF,
    SCRATCH_INT64_ARRAY_2_VAL_B                                    = 0x00000000,
    SCRATCH_INT64_ARRAY_2_VAL_C                                    = 0xFFFFFFFFFFFFFFFF,
};

/**
 *  @brief Which execution platform the HW Procedure is running on Some
 *	HWPs (e.g. special wakeup) use different registers for different
 *	platforms to avoid arbitration problems when multiple platforms do
 *	the same thing concurrently
 */
enum EXECUTION_PLATFORM
{
    EXECUTION_PLATFORM_HOST                                        = 0x00000001,
    EXECUTION_PLATFORM_FSP                                         = 0x00000002,
    EXECUTION_PLATFORM_OCC                                         = 0x00000003,
};

/**
 *  @brief The manufacturing flags. This is a bitfield. Each bit is a flag
 *	and multiple flags can be set
 */
enum MNFG_FLAGS
{
    MNFG_FLAGS_MNFG_NO_FLAG                                        = 0x00000000,
    MNFG_FLAGS_MNFG_THRESHOLDS                                     = 0x00000001,
    MNFG_FLAGS_MNFG_DISABLE_DRAM_REPAIRS                           = 0x00000080,
    MNFG_FLAGS_MNFG_ENABLE_STANDARD_PATTERN_TEST                   = 0x00000200,
};

/**
 *  @brief Spare DRAM availability for all DIMMs connected to the target
 *	MBA. For each rank on a DIMM, there are 8 DQ lines to spare DRAMs.
 *	- NO_SPARE: No spare DRAMs - LOW_NIBBLE: x4 DRAMs in use, one spare
 *	DRAM connected to SP_DQ0-3 - HIGH_NIBBLE: x4 DRAMs in use, one
 *	spare DRAM connected to SP_DQ4-7 - FULL_BYTE: Either 1/ x4 DRAMs in
 *	use, two spare DRAMs connected to SP_DQ0-7 2/ x8 DRAMs in use, one
 *	spare DRAM connected to SP_DQ0-7 For C-DIMMs, this is in a VPD
 *	field : Record:VSPD, Keyword:AM
 */
enum CEN_VPD_DIMM_SPARE
{
    CEN_VPD_DIMM_SPARE_NO_SPARE                                    = 0x00000000,
    CEN_VPD_DIMM_SPARE_LOW_NIBBLE                                  = 0x00000001,
    CEN_VPD_DIMM_SPARE_HIGH_NIBBLE                                 = 0x00000002,
    CEN_VPD_DIMM_SPARE_FULL_BYTE                                   = 0x00000003,
};

/**
 *  @brief DRAM Device Type. Located in DDR3/DDR4 SPD byte 2.
 */
enum CEN_SPD_DRAM_DEVICE_TYPE
{
    CEN_SPD_DRAM_DEVICE_TYPE_DDR3                                  = 0x0000000B,
    CEN_SPD_DRAM_DEVICE_TYPE_DDR4                                  = 0x0000000C,
};

/**
 *  @brief Module Type. Located in DDR3/DDR4 SPD byte 3, bits 3-0. Note
 *	that CDIMM designation here is obsolete. See ATTR_CEN_SPD_CUSTOM
 */
enum CEN_SPD_MODULE_TYPE
{
    CEN_SPD_MODULE_TYPE_CDIMM                                      = 0x00000000,
    CEN_SPD_MODULE_TYPE_RDIMM                                      = 0x00000001,
    CEN_SPD_MODULE_TYPE_UDIMM                                      = 0x00000002,
    CEN_SPD_MODULE_TYPE_SO_DIMM                                    = 0x00000003,
    CEN_SPD_MODULE_TYPE_LRDIMM                                     = 0x0000000B,
    CEN_SPD_MODULE_TYPE_INVALID                                    = 0x000000FF,
};

/**
 *  @brief Module Type is CUSTOM Located in DDR3/DDR4 SPD byte 3, bit 7.
 *	(Most significant bit) If bit 7 (reserved) is a '1' then this
 *	attribute value should be set to YES
 */
enum CEN_SPD_CUSTOM
{
    CEN_SPD_CUSTOM_NO                                              = 0x00000000,
    CEN_SPD_CUSTOM_YES                                             = 0x00000001,
};

/**
 *  @brief DRAM Density. Located in DDR3/DDR4 SPD byte 4, bits 3-0. 0x00 =
 *	256MB 0x01 = 512MB 0x02 = 1GB 0x03 = 2GB 0x04 = 4GB 0x05 = 8GB 0x06
 *	= 16GB 0x07 = 32GB
 */
enum CEN_SPD_SDRAM_DENSITY
{
    CEN_SPD_SDRAM_DENSITY_D256MB                                   = 0x00000000,
    CEN_SPD_SDRAM_DENSITY_D512Mb                                   = 0x00000001,
    CEN_SPD_SDRAM_DENSITY_D1GB                                     = 0x00000002,
    CEN_SPD_SDRAM_DENSITY_D2GB                                     = 0x00000003,
    CEN_SPD_SDRAM_DENSITY_D4GB                                     = 0x00000004,
    CEN_SPD_SDRAM_DENSITY_D8GB                                     = 0x00000005,
    CEN_SPD_SDRAM_DENSITY_D16GB                                    = 0x00000006,
    CEN_SPD_SDRAM_DENSITY_D32GB                                    = 0x00000007,
};

/**
 *  @brief Number of banks. Located in DDR3 SPD byte 4, bits 6-4. Located
 *	in DDR4 SPD byte 4, bits 5-4. The raw data has different meanings
 *	for DDR3 and DDR4. HWPs must use this DDR neutral enumeration to
 *	decode. Platform support must call an Accessor HWP. For DDR4 ,
 *	Values can be B4 and B8 based on bits 5-4 For DDR3 , Values can be
 *	B8,B16,B32,B64 based on bits 6-4
 */
enum CEN_SPD_SDRAM_BANKS
{
    CEN_SPD_SDRAM_BANKS_B8                                         = 0x00000000,
    CEN_SPD_SDRAM_BANKS_B16                                        = 0x00000001,
    CEN_SPD_SDRAM_BANKS_B32                                        = 0x00000002,
    CEN_SPD_SDRAM_BANKS_B64                                        = 0x00000003,
    CEN_SPD_SDRAM_BANKS_B4                                         = 0x00000004,
    CEN_SPD_SDRAM_BANKS_UNKNOWN                                    = 0x000000FF,
};

/**
 *  @brief Number of Rows. Located in DDR3/DDR4 SPD byte 5, bits 5-3.
 */
enum CEN_SPD_SDRAM_ROWS
{
    CEN_SPD_SDRAM_ROWS_R12                                         = 0x00000000,
    CEN_SPD_SDRAM_ROWS_R13                                         = 0x00000001,
    CEN_SPD_SDRAM_ROWS_R14                                         = 0x00000002,
    CEN_SPD_SDRAM_ROWS_R15                                         = 0x00000003,
    CEN_SPD_SDRAM_ROWS_R16                                         = 0x00000004,
    CEN_SPD_SDRAM_ROWS_R17                                         = 0x00000005,
    CEN_SPD_SDRAM_ROWS_R18                                         = 0x00000006,
};

/**
 *  @brief Number of Columns. Located in DDR3/DDR4 SPD byte 5, bits 2-0.
 */
enum CEN_SPD_SDRAM_COLUMNS
{
    CEN_SPD_SDRAM_COLUMNS_C9                                       = 0x00000000,
    CEN_SPD_SDRAM_COLUMNS_C10                                      = 0x00000001,
    CEN_SPD_SDRAM_COLUMNS_C11                                      = 0x00000002,
    CEN_SPD_SDRAM_COLUMNS_C12                                      = 0x00000003,
};

/**
 *  @brief Nominal voltage (bitmap). Located in DDR3 SPD byte 6, bits 2-0.
 *	Located in DDR4 SPD byte 11, bits 5-0. The raw data has different
 *	meanings for DDR3 and DDR4. HWPs must use this DDR neutral
 *	enumeration to decode. Platform support must call an Accessor HWP.
 *	For DDR3, values would be NOTOP1_5,OP1_35,OP1_2X based on byte 6,
 *	bits 2-0 For DDR4, values would be OP1_2V,END1_2V, based on byte 6,
 *	bits 5-0
 */
enum CEN_SPD_MODULE_NOMINAL_VOLTAGE
{
    CEN_SPD_MODULE_NOMINAL_VOLTAGE_NOTOP1_5                        = 0x00000001,
    CEN_SPD_MODULE_NOMINAL_VOLTAGE_OP1_35                          = 0x00000002,
    CEN_SPD_MODULE_NOMINAL_VOLTAGE_OP1_2X                          = 0x00000004,
    CEN_SPD_MODULE_NOMINAL_VOLTAGE_OP1_2V                          = 0x00000008,
    CEN_SPD_MODULE_NOMINAL_VOLTAGE_END1_2V                         = 0x00000010,
};

/**
 *  @brief Number of ranks. Located in DDR3 SPD byte 7, bits 5-3. Located
 *	in DDR4 SPD byte 12, bits 5-3.
 */
enum CEN_SPD_NUM_RANKS
{
    CEN_SPD_NUM_RANKS_R1                                           = 0x00000000,
    CEN_SPD_NUM_RANKS_R2                                           = 0x00000001,
    CEN_SPD_NUM_RANKS_R4                                           = 0x00000003,
    CEN_SPD_NUM_RANKS_RX                                           = 0x000000FF,
};

/**
 *  @brief DRAM Width. Located in DDR3 SPD byte 7, bits 2-0. Located in
 *	DDR4 SPD byte 12, bits 2-0.
 */
enum CEN_SPD_DRAM_WIDTH
{
    CEN_SPD_DRAM_WIDTH_W4                                          = 0x00000000,
    CEN_SPD_DRAM_WIDTH_W8                                          = 0x00000001,
    CEN_SPD_DRAM_WIDTH_W16                                         = 0x00000002,
    CEN_SPD_DRAM_WIDTH_W32                                         = 0x00000003,
};

/**
 *  @brief Module Memory Bus Width. Located in DDR3 SPD byte 8, bits 4-0
 *	Located in DDR4 SPD byte 13, bits 4-0. Bits 4-3 contain the Bus
 *	Width Extension (ECC) Bits 2-0 contain the Primary Bus Width
 */
enum CEN_SPD_MODULE_MEMORY_BUS_WIDTH
{
    CEN_SPD_MODULE_MEMORY_BUS_WIDTH_W8                             = 0x00000000,
    CEN_SPD_MODULE_MEMORY_BUS_WIDTH_W16                            = 0x00000001,
    CEN_SPD_MODULE_MEMORY_BUS_WIDTH_W32                            = 0x00000002,
    CEN_SPD_MODULE_MEMORY_BUS_WIDTH_W64                            = 0x00000003,
    CEN_SPD_MODULE_MEMORY_BUS_WIDTH_WE8                            = 0x00000008,
    CEN_SPD_MODULE_MEMORY_BUS_WIDTH_WE16                           = 0x00000009,
    CEN_SPD_MODULE_MEMORY_BUS_WIDTH_WE32                           = 0x0000000A,
    CEN_SPD_MODULE_MEMORY_BUS_WIDTH_WE64                           = 0x0000000B,
};

/**
 *  @brief CAS Latencies supported (bitmap). Located in DDR3 SPD byte 14
 *	(LSB) and byte 15. Located in DDR4 SPD byte 20 (LSB) through byte
 *	23 The raw data has different meanings for DDR3 and DDR4. HWPs must
 *	use this DDR neutral enumeration to decode. Platform support must
 *	call an Accessor HWP. For DDR3, the values would be from CL_4
 *	through CL_18 For DDR4, the values would be from CL_7 through CL_24
 */
enum CEN_SPD_CAS_LATENCIES_SUPPORTED
{
    CEN_SPD_CAS_LATENCIES_SUPPORTED_CL_24                          = 0x00100000,
    CEN_SPD_CAS_LATENCIES_SUPPORTED_CL_23                          = 0x00080000,
    CEN_SPD_CAS_LATENCIES_SUPPORTED_CL_22                          = 0x00040000,
    CEN_SPD_CAS_LATENCIES_SUPPORTED_CL_21                          = 0x00020000,
    CEN_SPD_CAS_LATENCIES_SUPPORTED_CL_20                          = 0x00010000,
    CEN_SPD_CAS_LATENCIES_SUPPORTED_CL_19                          = 0x00008000,
    CEN_SPD_CAS_LATENCIES_SUPPORTED_CL_18                          = 0x00004000,
    CEN_SPD_CAS_LATENCIES_SUPPORTED_CL_17                          = 0x00002000,
    CEN_SPD_CAS_LATENCIES_SUPPORTED_CL_16                          = 0x00001000,
    CEN_SPD_CAS_LATENCIES_SUPPORTED_CL_15                          = 0x00000800,
    CEN_SPD_CAS_LATENCIES_SUPPORTED_CL_14                          = 0x00000400,
    CEN_SPD_CAS_LATENCIES_SUPPORTED_CL_13                          = 0x00000200,
    CEN_SPD_CAS_LATENCIES_SUPPORTED_CL_12                          = 0x00000100,
    CEN_SPD_CAS_LATENCIES_SUPPORTED_CL_11                          = 0x00000080,
    CEN_SPD_CAS_LATENCIES_SUPPORTED_CL_10                          = 0x00000040,
    CEN_SPD_CAS_LATENCIES_SUPPORTED_CL_9                           = 0x00000020,
    CEN_SPD_CAS_LATENCIES_SUPPORTED_CL_8                           = 0x00000010,
    CEN_SPD_CAS_LATENCIES_SUPPORTED_CL_7                           = 0x00000008,
    CEN_SPD_CAS_LATENCIES_SUPPORTED_CL_6                           = 0x00000004,
    CEN_SPD_CAS_LATENCIES_SUPPORTED_CL_5                           = 0x00000002,
    CEN_SPD_CAS_LATENCIES_SUPPORTED_CL_4                           = 0x00000001,
};

/**
 *  @brief SDRAM Optional Features (bitmap). Located in DDR3 SPD byte 30.
 *	Located in DDR4 SPD byte 7, will be reserved and set to 0x0.
 */
enum CEN_SPD_SDRAM_OPTIONAL_FEATURES
{
    CEN_SPD_SDRAM_OPTIONAL_FEATURES_DLL_OFF                        = 0x00000080,
    CEN_SPD_SDRAM_OPTIONAL_FEATURES_RZQ7                           = 0x00000002,
    CEN_SPD_SDRAM_OPTIONAL_FEATURES_RZQ6                           = 0x00000001,
};

/**
 *  @brief SDRAM Thermal and Refresh Options (bitmap). Located in DDR3 SPD
 *	byte 31. Located in DDR4 SPD byte 8, will be reserved and set to
 *	0x0.
 */
enum CEN_SPD_SDRAM_THERMAL_AND_REFRESH_OPTIONS
{
    CEN_SPD_SDRAM_THERMAL_AND_REFRESH_OPTIONS_PASR                 = 0x00000080,
    CEN_SPD_SDRAM_THERMAL_AND_REFRESH_OPTIONS_ODTS                 = 0x00000008,
    CEN_SPD_SDRAM_THERMAL_AND_REFRESH_OPTIONS_ASR                  = 0x00000005,
    CEN_SPD_SDRAM_THERMAL_AND_REFRESH_OPTIONS_ETRR                 = 0x00000002,
    CEN_SPD_SDRAM_THERMAL_AND_REFRESH_OPTIONS_ETR                  = 0x00000001,
};

/**
 *  @brief Module Thermal Sensor. Located in DDR3 SPD byte 32. Located in
 *	DDR4 SPD byte 14.
 */
enum CEN_SPD_MODULE_THERMAL_SENSOR
{
    CEN_SPD_MODULE_THERMAL_SENSOR_PRESENT                          = 0x00000080,
    CEN_SPD_MODULE_THERMAL_SENSOR_ACCURACY_MASK                    = 0x0000007F,
};

/**
 *  @brief SDRAM Device Type. Located in DDR3 SPD byte 33, bit 7. Located
 *	in DDR4 SPD byte 6, bit 7.
 */
enum CEN_SPD_SDRAM_DEVICE_TYPE
{
    CEN_SPD_SDRAM_DEVICE_TYPE_STANDARD_MONOLITHIC                  = 0x00000000,
    CEN_SPD_SDRAM_DEVICE_TYPE_NON_STANDARD                         = 0x00000001,
};

/**
 *  @brief SDRAM Device Type Signal Loading for stacked DRAMs. Located in
 *	DDR3 SPD byte 33, bits 1-0. Located in DDR4 SPD byte 6, bit 1-0.
 */
enum CEN_SPD_SDRAM_DEVICE_TYPE_SIGNAL_LOADING
{
    CEN_SPD_SDRAM_DEVICE_TYPE_SIGNAL_LOADING_NOT_SPECIFIED         = 0x00000000,
    CEN_SPD_SDRAM_DEVICE_TYPE_SIGNAL_LOADING_MULTI_LOAD_STACK      = 0x00000001,
    CEN_SPD_SDRAM_DEVICE_TYPE_SIGNAL_LOADING_SINGLE_LOAD_STACK     = 0x00000002,
};

/**
 *  @brief SDRAM Device Type Die Count. Located in DDR4 SPD byte 6, bit
 *	6-4.
 */
enum CEN_SPD_SDRAM_DIE_COUNT
{
    CEN_SPD_SDRAM_DIE_COUNT_DIE1                                   = 0x00000000,
    CEN_SPD_SDRAM_DIE_COUNT_DIE2                                   = 0x00000001,
    CEN_SPD_SDRAM_DIE_COUNT_DIE3                                   = 0x00000002,
    CEN_SPD_SDRAM_DIE_COUNT_DIE4                                   = 0x00000003,
    CEN_SPD_SDRAM_DIE_COUNT_DIE5                                   = 0x00000004,
    CEN_SPD_SDRAM_DIE_COUNT_DIE6                                   = 0x00000005,
    CEN_SPD_SDRAM_DIE_COUNT_DIE7                                   = 0x00000006,
    CEN_SPD_SDRAM_DIE_COUNT_DIE8                                   = 0x00000007,
};

/**
 *  @brief RCD Timing. Supplied by VPD, used by mss_eff_config.C. Each dimm
 *	will have a value. consumer: mss_eff_config
 */
enum CEN_VPD_DIMM_RCD_OUTPUT_TIMING
{
    CEN_VPD_DIMM_RCD_OUTPUT_TIMING_1T                              = 0x00000001,
    CEN_VPD_DIMM_RCD_OUTPUT_TIMING_3T                              = 0x00000003,
};

/**
 *  @brief defines a value in picoseconds that represents the fundamental
 *	timebase for medium grain timing calculations. This value is used
 *	as a multiplier for formulating subsequent timing parameters.
 *	Located in DDR4 SPD byte 17, bits 3-2.
 */
enum CEN_SPD_TIMEBASE_MTB_DDR4
{
    CEN_SPD_TIMEBASE_MTB_DDR4_PS125                                = 0x00000000,
};

/**
 *  @brief defines a value in picoseconds that represents the fundamental
 *	timebase for fine grain timing calculations. This value is used as
 *	a multiplier for formulating subsequent timing parameters. Located
 *	in DDR4 SPD byte 17, bits 1-0.
 */
enum CEN_SPD_TIMEBASE_FTB_DDR4
{
    CEN_SPD_TIMEBASE_FTB_DDR4_PS1                                  = 0x00000000,
};

/**
 *  @brief The VPD Version of this DIMM. The version number can be an
 *	indication of when different DIMM keywords are valid and is loaded
 *	from the platform. The version represented here represents one of
 *	three distinct vintages of parts : unknown/error, early build
 *	CDIMMs with VZ less than 10, everything else. In other words, this
 *	attribute does NOT equate to the VZ keyword.
 */
enum CEN_VPD_VERSION
{
    CEN_VPD_VERSION_UNKNOWN                                        = 0x00003030,
    CEN_VPD_VERSION_OLD_CDIMM                                      = 0x00003031,
    CEN_VPD_VERSION_CURRENT                                        = 0x00003230,
};

/**
 *  @brief The C-DIMM ranks that have address mirroring. This data is in
 *	the Record:VSPD, Keyword:AM field in C-DIMM VPD. This attribute is
 *	only valid for C-DIMMs, an error should be returned if queried from
 *	IS-DIMMs. Note: Muliple ranks can be mirrored.
 */
enum CEN_VPD_DRAM_ADDRESS_MIRRORING
{
    CEN_VPD_DRAM_ADDRESS_MIRRORING_RANK0_MIRRORED                  = 0x00000008,
    CEN_VPD_DRAM_ADDRESS_MIRRORING_RANK1_MIRRORED                  = 0x00000004,
    CEN_VPD_DRAM_ADDRESS_MIRRORING_RANK2_MIRRORED                  = 0x00000002,
    CEN_VPD_DRAM_ADDRESS_MIRRORING_RANK3_MIRRORED                  = 0x00000001,
};

/**
 *  @brief DRAM Ron. Used in various locations and comes from the MT
 *	keyword of the VPD or is computed in mss_eff_cnfg_termination. Can
 *	be overwritten by ODM vendors if done from the PNOR or
 *	odm_eff_cnfg. OHM48 is for DDR4. creator:
 *	VPD(MT)/mss_eff_cnfg_termination consumer: various.C files (no
 *	initfile) firmware notes: none This Attribute is to be interpreted
 *	as an Integer
 */
enum CEN_VPD_DRAM_RON
{
    CEN_VPD_DRAM_RON_INVALID                                       = 0x00000000,
    CEN_VPD_DRAM_RON_OHM34                                         = 0x00000022,
    CEN_VPD_DRAM_RON_OHM40                                         = 0x00000028,
    CEN_VPD_DRAM_RON_OHM48                                         = 0x00000030,
};

/**
 *  @brief DRAM Rtt_Nom. Used in various locations and comes from the MT
 *	keyword of the VPD or is computed in mss_eff_cnfg_termination. Can
 *	be overwritten by ODM vendors if done from the PNOR or
 *	odm_eff_cnfg. creator: VPD(MT),mss_eff_cnfg_termination consumer:
 *	various.C files (no initfiles) firmware notes: none This Attribute
 *	is to be interpreted as an Integer
 */
enum CEN_VPD_DRAM_RTT_NOM
{
    CEN_VPD_DRAM_RTT_NOM_DISABLE                                   = 0x00000000,
    CEN_VPD_DRAM_RTT_NOM_OHM20                                     = 0x00000014,
    CEN_VPD_DRAM_RTT_NOM_OHM30                                     = 0x0000001E,
    CEN_VPD_DRAM_RTT_NOM_OHM34                                     = 0x00000022,
    CEN_VPD_DRAM_RTT_NOM_OHM40                                     = 0x00000028,
    CEN_VPD_DRAM_RTT_NOM_OHM48                                     = 0x00000030,
    CEN_VPD_DRAM_RTT_NOM_OHM60                                     = 0x0000003C,
    CEN_VPD_DRAM_RTT_NOM_OHM80                                     = 0x00000050,
    CEN_VPD_DRAM_RTT_NOM_OHM120                                    = 0x00000078,
    CEN_VPD_DRAM_RTT_NOM_OHM240                                    = 0x000000F0,
};

/**
 *  @brief DRAM Rtt_WR. Used in various locations and comes from the MT
 *	keyword of the VPD or is computed in mss_eff_cnfg_termination. Can
 *	be overwritten by ODM vendors if done from the PNOR or
 *	odm_eff_cnfg. Creator: VPD(MT), mss_eff_cnfg_termination consumer:
 *	various.C files (no initfiles) firmware notes: none This Attribute
 *	is to be interpreted as an Integer
 */
enum CEN_VPD_DRAM_RTT_WR
{
    CEN_VPD_DRAM_RTT_WR_DISABLE                                    = 0x00000000,
    CEN_VPD_DRAM_RTT_WR_OHM60                                      = 0x0000003C,
    CEN_VPD_DRAM_RTT_WR_OHM120                                     = 0x00000078,
    CEN_VPD_DRAM_RTT_WR_OHM240                                     = 0x000000F0,
    CEN_VPD_DRAM_RTT_WR_HIGHZ                                      = 0x00000001,
};

/**
 *  @brief DRAM Rtt_PARK. Used in various locations and comes from the MT
 *	keyword of the VPD or is computed in mss_eff_cnfg_termination. Can
 *	be overwritten by ODM vendors if done from the PNOR or
 *	odm_eff_cnfg. RTT_Park value. This is for DDR4 MRS5.Each memory
 *	channel will have a value. Creator: VPD(MT),
 *	mss_eff_cnfg_termination consumer: various.C files (no initfiles)
 *	firmware notes: none This Attribute is to be interpreted as an
 *	Integer
 */
enum CEN_VPD_DRAM_RTT_PARK
{
    CEN_VPD_DRAM_RTT_PARK_DISABLE                                  = 0x00000000,
    CEN_VPD_DRAM_RTT_PARK_60OHM                                    = 0x0000003C,
    CEN_VPD_DRAM_RTT_PARK_120OHM                                   = 0x00000078,
    CEN_VPD_DRAM_RTT_PARK_40OHM                                    = 0x00000028,
    CEN_VPD_DRAM_RTT_PARK_240OHM                                   = 0x000000F0,
    CEN_VPD_DRAM_RTT_PARK_48OHM                                    = 0x00000030,
    CEN_VPD_DRAM_RTT_PARK_80OHM                                    = 0x00000050,
    CEN_VPD_DRAM_RTT_PARK_34OHM                                    = 0x00000022,
};

/**
 *  @brief DRAM Write Vref. Used in various locations and comes from the MT
 *	keyword of the VPD or is computed in mss_eff_cnfg_termination. Can
 *	be overwritten by ODM vendors if done from the PNOR or
 *	odm_eff_cnfg. creator: VPD(MT) or mss_eff_cnfg_termination
 *	consumer: various.C and initfile firmware notes: none This is the
 *	nominal value This is for DDR3 This Attribute is to be interpreted
 *	as an Integer
 */
enum CEN_VPD_DRAM_WR_VREF
{
    CEN_VPD_DRAM_WR_VREF_VDD420                                    = 0x000001A4,
    CEN_VPD_DRAM_WR_VREF_VDD425                                    = 0x000001A9,
    CEN_VPD_DRAM_WR_VREF_VDD430                                    = 0x000001AE,
    CEN_VPD_DRAM_WR_VREF_VDD435                                    = 0x000001B3,
    CEN_VPD_DRAM_WR_VREF_VDD440                                    = 0x000001B8,
    CEN_VPD_DRAM_WR_VREF_VDD445                                    = 0x000001BD,
    CEN_VPD_DRAM_WR_VREF_VDD450                                    = 0x000001C2,
    CEN_VPD_DRAM_WR_VREF_VDD455                                    = 0x000001C7,
    CEN_VPD_DRAM_WR_VREF_VDD460                                    = 0x000001CC,
    CEN_VPD_DRAM_WR_VREF_VDD465                                    = 0x000001D1,
    CEN_VPD_DRAM_WR_VREF_VDD470                                    = 0x000001D6,
    CEN_VPD_DRAM_WR_VREF_VDD475                                    = 0x000001DB,
    CEN_VPD_DRAM_WR_VREF_VDD480                                    = 0x000001E0,
    CEN_VPD_DRAM_WR_VREF_VDD485                                    = 0x000001E5,
    CEN_VPD_DRAM_WR_VREF_VDD490                                    = 0x000001EA,
    CEN_VPD_DRAM_WR_VREF_VDD495                                    = 0x000001EF,
    CEN_VPD_DRAM_WR_VREF_VDD500                                    = 0x000001F4,
    CEN_VPD_DRAM_WR_VREF_VDD505                                    = 0x000001F9,
    CEN_VPD_DRAM_WR_VREF_VDD510                                    = 0x000001FE,
    CEN_VPD_DRAM_WR_VREF_VDD515                                    = 0x00000203,
    CEN_VPD_DRAM_WR_VREF_VDD520                                    = 0x00000208,
    CEN_VPD_DRAM_WR_VREF_VDD525                                    = 0x0000020D,
    CEN_VPD_DRAM_WR_VREF_VDD530                                    = 0x00000212,
    CEN_VPD_DRAM_WR_VREF_VDD535                                    = 0x00000217,
    CEN_VPD_DRAM_WR_VREF_VDD540                                    = 0x0000021C,
    CEN_VPD_DRAM_WR_VREF_VDD545                                    = 0x00000221,
    CEN_VPD_DRAM_WR_VREF_VDD550                                    = 0x00000226,
    CEN_VPD_DRAM_WR_VREF_VDD555                                    = 0x0000022B,
    CEN_VPD_DRAM_WR_VREF_VDD560                                    = 0x00000230,
    CEN_VPD_DRAM_WR_VREF_VDD565                                    = 0x00000235,
    CEN_VPD_DRAM_WR_VREF_VDD570                                    = 0x0000023A,
    CEN_VPD_DRAM_WR_VREF_VDD575                                    = 0x0000023F,
};

/**
 *  @brief Centaur DQ and DQS Drive Impedance Used in various locations and
 *	comes from the MT Keyword of the VPD or is computed in
 *	mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done
 *	from the PNOR or odm_eff_cnfg. creator:
 *	VPD(MT)/mss_eff_cnfg_termination consumer: initfile,various.C files
 *	firmware notes: none This is the nominal value This Attribute is to
 *	be interpreted as an Integer
 */
enum CEN_VPD_DRV_IMP_DQ_DQS
{
    CEN_VPD_DRV_IMP_DQ_DQS_OHM24_FFE0                              = 0x0000000A,
    CEN_VPD_DRV_IMP_DQ_DQS_OHM30_FFE0                              = 0x00000008,
    CEN_VPD_DRV_IMP_DQ_DQS_OHM30_FFE480                            = 0x00000048,
    CEN_VPD_DRV_IMP_DQ_DQS_OHM30_FFE240                            = 0x00000038,
    CEN_VPD_DRV_IMP_DQ_DQS_OHM30_FFE160                            = 0x00000028,
    CEN_VPD_DRV_IMP_DQ_DQS_OHM30_FFE120                            = 0x00000018,
    CEN_VPD_DRV_IMP_DQ_DQS_OHM34_FFE0                              = 0x00000007,
    CEN_VPD_DRV_IMP_DQ_DQS_OHM34_FFE480                            = 0x00000047,
    CEN_VPD_DRV_IMP_DQ_DQS_OHM34_FFE240                            = 0x00000037,
    CEN_VPD_DRV_IMP_DQ_DQS_OHM34_FFE160                            = 0x00000027,
    CEN_VPD_DRV_IMP_DQ_DQS_OHM34_FFE120                            = 0x00000017,
    CEN_VPD_DRV_IMP_DQ_DQS_OHM40_FFE0                              = 0x00000006,
    CEN_VPD_DRV_IMP_DQ_DQS_OHM40_FFE480                            = 0x00000046,
    CEN_VPD_DRV_IMP_DQ_DQS_OHM40_FFE240                            = 0x00000036,
    CEN_VPD_DRV_IMP_DQ_DQS_OHM40_FFE160                            = 0x00000026,
    CEN_VPD_DRV_IMP_DQ_DQS_OHM40_FFE120                            = 0x00000016,
};

/**
 *  @brief Centaur Address Drive Impedance Used in various locations and
 *	comes from the MT keyword of the VPD or is computed in
 *	mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done
 *	from the PNOR or odm_eff_cnfg. creator: mss_eff_cnfg_termination
 *	consumer: initfile and various.C firmware notes: none This is the
 *	nominal value This Attribute is to be interpreted as an Integer
 */
enum CEN_VPD_DRV_IMP_ADDR
{
    CEN_VPD_DRV_IMP_ADDR_OHM15                                     = 0x0000000F,
    CEN_VPD_DRV_IMP_ADDR_OHM20                                     = 0x00000014,
    CEN_VPD_DRV_IMP_ADDR_OHM30                                     = 0x0000001E,
    CEN_VPD_DRV_IMP_ADDR_OHM40                                     = 0x00000028,
};

/**
 *  @brief Centaur Control Drive Impedance Used in various locations and
 *	comes from the MT keyword of the VPD or is computed in
 *	mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done
 *	from the PNOR or odm_eff_cnfg. creator:
 *	VPD(MT)/mss_eff_cnfg_termination consumer: initfile,various .C
 *	firmware notes: none This is the nominal value This Attribute is to
 *	be interpreted as an Integer
 */
enum CEN_VPD_DRV_IMP_CNTL
{
    CEN_VPD_DRV_IMP_CNTL_OHM15                                     = 0x0000000F,
    CEN_VPD_DRV_IMP_CNTL_OHM20                                     = 0x00000014,
    CEN_VPD_DRV_IMP_CNTL_OHM30                                     = 0x0000001E,
    CEN_VPD_DRV_IMP_CNTL_OHM40                                     = 0x00000028,
};

/**
 *  @brief Centaur Clock Drive Impedance Used in various locations and
 *	comes from the MT keyword of the VPD or is computed in
 *	mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done
 *	from the PNOR or odm_eff_cnfg. creator:
 *	VPD(MT),mss_eff_cnfg_termination consumer: initfiles,various
 *	firmware notes: none This is the nominal value This Attribute is to
 *	be interpreted as an Integer
 */
enum CEN_VPD_DRV_IMP_CLK
{
    CEN_VPD_DRV_IMP_CLK_OHM15                                      = 0x0000000F,
    CEN_VPD_DRV_IMP_CLK_OHM20                                      = 0x00000014,
    CEN_VPD_DRV_IMP_CLK_OHM30                                      = 0x0000001E,
    CEN_VPD_DRV_IMP_CLK_OHM40                                      = 0x00000028,
};

/**
 *  @brief Centaur Spare Clock Drive Impedance Used in various locations
 *	and comes from the MT keyword of the VPD or is computed in
 *	mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done
 *	from the PNOR or odm_eff_cnfg. creator: VPD(MT) ,
 *	mss_eff_cnfg_termination consumer: initfiles, various.C firmware
 *	notes: none This is the nominal value This Attribute is to be
 *	interpreted as an Integer
 */
enum CEN_VPD_DRV_IMP_SPCKE
{
    CEN_VPD_DRV_IMP_SPCKE_OHM15                                    = 0x0000000F,
    CEN_VPD_DRV_IMP_SPCKE_OHM20                                    = 0x00000014,
    CEN_VPD_DRV_IMP_SPCKE_OHM30                                    = 0x0000001E,
    CEN_VPD_DRV_IMP_SPCKE_OHM40                                    = 0x00000028,
};

/**
 *  @brief Centaur DQ and DQS Receiver Impedance Used in various locations
 *	and it comes from the VPD MT keyword for custom DIMMs or is
 *	computed in mss_eff_cnfg_termination. Can be overwritten by ODM
 *	vendors if done from the PNOR or odm_eff_cnfg. creator: VPD,
 *	mss_eff_cnfg_termination Consumer: initfile + C code firmware
 *	notes: none This is the nominal value This Attribute is to be
 *	interpreted as an Integer
 */
enum CEN_VPD_RCV_IMP_DQ_DQS
{
    CEN_VPD_RCV_IMP_DQ_DQS_OHM15                                   = 0x0000000F,
    CEN_VPD_RCV_IMP_DQ_DQS_OHM20                                   = 0x00000014,
    CEN_VPD_RCV_IMP_DQ_DQS_OHM30                                   = 0x0000001E,
    CEN_VPD_RCV_IMP_DQ_DQS_OHM40                                   = 0x00000028,
    CEN_VPD_RCV_IMP_DQ_DQS_OHM48                                   = 0x00000030,
    CEN_VPD_RCV_IMP_DQ_DQS_OHM60                                   = 0x0000003C,
    CEN_VPD_RCV_IMP_DQ_DQS_OHM80                                   = 0x00000050,
    CEN_VPD_RCV_IMP_DQ_DQS_OHM120                                  = 0x00000078,
    CEN_VPD_RCV_IMP_DQ_DQS_OHM160                                  = 0x000000A0,
    CEN_VPD_RCV_IMP_DQ_DQS_OHM240                                  = 0x000000F0,
};

/**
 *  @brief Centaur DQ and DQS Slew Rate Used in various locations and comes
 *	from the MT keyword of the VPD or is computed in
 *	mss_eff_cnfg_termination. Slowest slew rate is 0, incrementing by
 *	one. The lower the number the slower the slew rate the higher the
 *	faster. Can be overwritten by ODM vendors if done from the PNOR or
 *	odm_eff_cnfg. creator: VPD(MT), mss_eff_cnfg_termination consumer:
 *	initfiles,various.C firmware notes: none This is the nominal value
 *	This Attribute is to be interpreted as an Integer except MAX
 */
enum CEN_VPD_SLEW_RATE_DQ_DQS
{
    CEN_VPD_SLEW_RATE_DQ_DQS_SLEW_3V_NS                            = 0x00000003,
    CEN_VPD_SLEW_RATE_DQ_DQS_SLEW_4V_NS                            = 0x00000004,
    CEN_VPD_SLEW_RATE_DQ_DQS_SLEW_5V_NS                            = 0x00000005,
    CEN_VPD_SLEW_RATE_DQ_DQS_SLEW_6V_NS                            = 0x00000006,
    CEN_VPD_SLEW_RATE_DQ_DQS_SLEW_MAXV_NS                          = 0x00000007,
};

/**
 *  @brief Centaur Address Slew Rate Used in various locations and comes
 *	from the MT keyword of the VPD or is computed in
 *	mss_eff_cnfg_termination. Slowest slew rate is 0, incrementing by
 *	one. The lower the number the slower the slew rate the higher the
 *	faster. Can be overwritten by ODM vendors if done from the PNOR or
 *	odm_eff_cnfg. creator: VPD(MT),mss_eff_cnfg_termination consumer:
 *	initfile,various .C files firmware notes: none This is the nominal
 *	value This Attribute is to be interpreted as an Integer except Max
 */
enum CEN_VPD_SLEW_RATE_ADDR
{
    CEN_VPD_SLEW_RATE_ADDR_SLEW_3V_NS                              = 0x00000003,
    CEN_VPD_SLEW_RATE_ADDR_SLEW_4V_NS                              = 0x00000004,
    CEN_VPD_SLEW_RATE_ADDR_SLEW_5V_NS                              = 0x00000005,
    CEN_VPD_SLEW_RATE_ADDR_SLEW_6V_NS                              = 0x00000006,
    CEN_VPD_SLEW_RATE_ADDR_SLEW_MAXV_NS                            = 0x00000007,
};

/**
 *  @brief Centaur Clock Slew Rate Used in various locations and comes from
 *	the MT keyword of the VPD or is computed in
 *	mss_eff_cnfg_termination. Slowest slew rate is 0, incrementing by
 *	one. The lower the number the slower the slew rate the higher the
 *	faster. Can be overwritten by ODM vendors if done from the PNOR or
 *	odm_eff_cnfg. creator: VPD(MT)mss_eff_cnfg_termination consumer:
 *	initfile,various.C files firmware notes: none This is the nominal
 *	value This Attribute is to be interpreted as an Integer except max
 */
enum CEN_VPD_SLEW_RATE_CLK
{
    CEN_VPD_SLEW_RATE_CLK_SLEW_3V_NS                               = 0x00000003,
    CEN_VPD_SLEW_RATE_CLK_SLEW_4V_NS                               = 0x00000004,
    CEN_VPD_SLEW_RATE_CLK_SLEW_5V_NS                               = 0x00000005,
    CEN_VPD_SLEW_RATE_CLK_SLEW_6V_NS                               = 0x00000006,
    CEN_VPD_SLEW_RATE_CLK_SLEW_MAXV_NS                             = 0x00000007,
};

/**
 *  @brief Centaur Spare Clock Slew Rate Used in various locations and
 *	comes from the MT keyword or is computed in
 *	mss_eff_cnfg_termination. Slowest slew rate is 0, incrementing by
 *	one. The lower the number the slower the slew rate the higher the
 *	faster. Can be overwritten by ODM vendors if done from the PNOR or
 *	odm_eff_cnfg. creator: VPD(MT) or mss_eff_cnfg_termination
 *	consumer: initfile,various.C firmware notes: none This is the
 *	nominal value This Attribute is to be interpreted as an Integer
 *	except max
 */
enum CEN_VPD_SLEW_RATE_SPCKE
{
    CEN_VPD_SLEW_RATE_SPCKE_SLEW_3V_NS                             = 0x00000003,
    CEN_VPD_SLEW_RATE_SPCKE_SLEW_4V_NS                             = 0x00000004,
    CEN_VPD_SLEW_RATE_SPCKE_SLEW_5V_NS                             = 0x00000005,
    CEN_VPD_SLEW_RATE_SPCKE_SLEW_6V_NS                             = 0x00000006,
    CEN_VPD_SLEW_RATE_SPCKE_SLEW_MAXV_NS                           = 0x00000007,
};

/**
 *  @brief Centaur Control Slew Rate Used in various locations and comes
 *	from the MT keyword of the VPD or is computed in
 *	mss_eff_cnfg_termination. Slowest slew rate is 0, incrementing by
 *	one. The lower the number the slower the slew rate the higher the
 *	faster. Can be overwritten by ODM vendors if done from the PNOR or
 *	odm_eff_cnfg. creator: VPD(MT),mss_eff_cnfg_termination
 *	consumer:initfile, various .C files firmware notes: none This is
 *	the nominal value This Attribute is to be interpreted as an Integer
 *	except for max
 */
enum CEN_VPD_SLEW_RATE_CNTL
{
    CEN_VPD_SLEW_RATE_CNTL_SLEW_3V_NS                              = 0x00000003,
    CEN_VPD_SLEW_RATE_CNTL_SLEW_4V_NS                              = 0x00000004,
    CEN_VPD_SLEW_RATE_CNTL_SLEW_5V_NS                              = 0x00000005,
    CEN_VPD_SLEW_RATE_CNTL_SLEW_6V_NS                              = 0x00000006,
    CEN_VPD_SLEW_RATE_CNTL_SLEW_MAXV_NS                            = 0x00000007,
};

/**
 *  @brief Centaur Read Vref. Used in various locations and comes from the
 *	MT keyword of the VPD or is computed in mss_eff_cnfg_termination.
 *	Can be overwritten by ODM vendors if done from the PNOR or
 *	odm_eff_cnfg. Creator: VPD(MT) or mss_eff_cnfg_termination
 *	consumer: various.C and initfiles firmware notes: none This is the
 *	nominal value This Attribute is to be interpreted as an Integer
 */
enum CEN_VPD_RD_VREF
{
    CEN_VPD_RD_VREF_VDD40375                                       = 0x00009DB7,
    CEN_VPD_RD_VREF_VDD41750                                       = 0x0000A316,
    CEN_VPD_RD_VREF_VDD43125                                       = 0x0000A875,
    CEN_VPD_RD_VREF_VDD44500                                       = 0x0000ADD4,
    CEN_VPD_RD_VREF_VDD45875                                       = 0x0000B333,
    CEN_VPD_RD_VREF_VDD47250                                       = 0x0000B892,
    CEN_VPD_RD_VREF_VDD48625                                       = 0x0000BDF1,
    CEN_VPD_RD_VREF_VDD50000                                       = 0x0000C350,
    CEN_VPD_RD_VREF_VDD51375                                       = 0x0000C8AF,
    CEN_VPD_RD_VREF_VDD52750                                       = 0x0000CE0E,
    CEN_VPD_RD_VREF_VDD54125                                       = 0x0000D36D,
    CEN_VPD_RD_VREF_VDD55500                                       = 0x0000D8CC,
    CEN_VPD_RD_VREF_VDD56875                                       = 0x0000DE2B,
    CEN_VPD_RD_VREF_VDD58250                                       = 0x0000E38A,
    CEN_VPD_RD_VREF_VDD59625                                       = 0x0000E8E9,
    CEN_VPD_RD_VREF_VDD61000                                       = 0x0000EE48,
    CEN_VPD_RD_VREF_VDD60375                                       = 0x0000EBD7,
    CEN_VPD_RD_VREF_VDD61750                                       = 0x0000F136,
    CEN_VPD_RD_VREF_VDD63125                                       = 0x0000F695,
    CEN_VPD_RD_VREF_VDD64500                                       = 0x0000FBF4,
    CEN_VPD_RD_VREF_VDD65875                                       = 0x00010153,
    CEN_VPD_RD_VREF_VDD67250                                       = 0x000106B2,
    CEN_VPD_RD_VREF_VDD68625                                       = 0x00010C11,
    CEN_VPD_RD_VREF_VDD70000                                       = 0x00011170,
    CEN_VPD_RD_VREF_VDD71375                                       = 0x000116CF,
    CEN_VPD_RD_VREF_VDD72750                                       = 0x00011C2E,
    CEN_VPD_RD_VREF_VDD74125                                       = 0x0001218D,
    CEN_VPD_RD_VREF_VDD75500                                       = 0x000126EC,
    CEN_VPD_RD_VREF_VDD76875                                       = 0x00012C4B,
    CEN_VPD_RD_VREF_VDD78250                                       = 0x000131AA,
    CEN_VPD_RD_VREF_VDD79625                                       = 0x00013709,
    CEN_VPD_RD_VREF_VDD81000                                       = 0x00013C68,
};

/**
 *  @brief Describes if this MBA is in 2N address mode. The DIMM attributes
 *	associated with this MBA describes if this mode is needed for SI.
 *	Come from the VPD and consumed in the mba_def.initfile.
 */
enum CEN_VPD_DRAM_2N_MODE_ENABLED
{
    CEN_VPD_DRAM_2N_MODE_ENABLED_FALSE                             = 0x00000000,
    CEN_VPD_DRAM_2N_MODE_ENABLED_TRUE                              = 0x00000001,
};

/**
 *  @brief Capable power control settings.
 */
enum CEN_VPD_POWER_CONTROL_CAPABLE
{
    CEN_VPD_POWER_CONTROL_CAPABLE_NONE                             = 0x00000000,
    CEN_VPD_POWER_CONTROL_CAPABLE_SLOWEXIT_CAPABLE                 = 0x00000001,
    CEN_VPD_POWER_CONTROL_CAPABLE_FASTEXIT_CAPABLE                 = 0x00000002,
    CEN_VPD_POWER_CONTROL_CAPABLE_FASTSLOW_CAPABLE                 = 0x00000003,
};

/**
 *  @brief RCD IBT. Used in mss_dram_init and is computed in mss_eff_cnfg.
 *	Can be overwritten by ODM vendors if done from the PNOR or
 *	odm_eff_cnfg. Each dimm will have a value. creator: mss_eff_cnfg
 *	consumer: mss_dram_init firmware notes: none
 */
enum CEN_VPD_DIMM_RCD_IBT
{
    CEN_VPD_DIMM_RCD_IBT_IBT_OFF                                   = 0x00000000,
    CEN_VPD_DIMM_RCD_IBT_IBT_100                                   = 0x00000064,
    CEN_VPD_DIMM_RCD_IBT_IBT_150                                   = 0x00000096,
    CEN_VPD_DIMM_RCD_IBT_IBT_200                                   = 0x000000C8,
    CEN_VPD_DIMM_RCD_IBT_IBT_300                                   = 0x0000012C,
};

/**
 *  @brief FOR LAB USE ONLY: Frequency override of this memory channel in
 *	MHz, comprising of up to three DIMMs. Set by config file or an
 *	attribute writing program. Consumed by mss_freq. The default of
 *	AUTO means mss_freq will find the best frequencies given the DIMMs
 *	plugged in and other rules. Otherwise, this is the system
 *	frequency. firmware notes: Platforms should initialize this
 *	attribute to AUTO (0)
 */
enum CEN_MSS_FREQ_OVERRIDE
{
    CEN_MSS_FREQ_OVERRIDE_AUTO                                     = 0x00000000,
};

/**
 *  @brief Type of DIMM: RDIMM, UDIMM, LRDIMM as specified by the JEDIC
 *	standard. Used in various locations and is computed in
 *	mss_eff_cnfg. Can be overwritten by ODM vendors if done from the
 *	PNOR or odm_eff_cnfg. creator: mss_eff_cnfg consumer: various
 *	firmware notes: none NOTE: Do not use the enum type of CDIMM. Use
 *	the attribute EFF_DIMM_CUSTOM to test for a CUSTOM DIMM or CDIMM.
 */
enum CEN_EFF_DIMM_TYPE
{
    CEN_EFF_DIMM_TYPE_CDIMM                                        = 0x00000000,
    CEN_EFF_DIMM_TYPE_RDIMM                                        = 0x00000001,
    CEN_EFF_DIMM_TYPE_UDIMM                                        = 0x00000002,
    CEN_EFF_DIMM_TYPE_LRDIMM                                       = 0x00000003,
};

/**
 *  @brief DIMM is a custom DIMM. This is commonly known as a CDIMM, but
 *	technically, we could support Custom DIMMs of different types than
 *	an UDIMM, such as RDIMM and LRDIMM. Created in mss_eff_cnfg Use
 *	this attribute if you need to know if the Centaur is on the DIMM
 *	instead of on a planar.
 */
enum CEN_EFF_CUSTOM_DIMM
{
    CEN_EFF_CUSTOM_DIMM_NO                                         = 0x00000000,
    CEN_EFF_CUSTOM_DIMM_YES                                        = 0x00000001,
};

/**
 *  @brief DRAM Device Width: X4, X8, X16, X32. Used in various locations
 *	and is computed in mss_eff_cnfg. creator: mss_eff_cnfg consumer:
 *	various firmware notes: none
 */
enum CEN_EFF_DRAM_WIDTH
{
    CEN_EFF_DRAM_WIDTH_X4                                          = 0x00000004,
    CEN_EFF_DRAM_WIDTH_X8                                          = 0x00000008,
    CEN_EFF_DRAM_WIDTH_X16                                         = 0x00000010,
    CEN_EFF_DRAM_WIDTH_X32                                         = 0x00000020,
};

/**
 *  @brief Generation of memory: DDR3, DDR4. Used in various locations and
 *	is computed in mss_eff_cnfg. creator: mss_eff_cnfg consumer:
 *	various firmware notes: none
 */
enum CEN_EFF_DRAM_GEN
{
    CEN_EFF_DRAM_GEN_EMPTY                                         = 0x00000000,
    CEN_EFF_DRAM_GEN_DDR3                                          = 0x00000001,
    CEN_EFF_DRAM_GEN_DDR4                                          = 0x00000002,
};

/**
 *  @brief RankGroup. Used in various locations and is computed in
 *	mss_eff_cnfg_rank_group. Can be overwritten by ODM vendors if done
 *	from the PNOR or odm_eff_cnfg. creator: mss_eff_cnfg_rank_group
 *	consumer: various firmware notes: none
 */
enum CEN_EFF_PRIMARY_RANK_GROUP0
{
    CEN_EFF_PRIMARY_RANK_GROUP0_INVALID                            = 0x000000FF,
};

/**
 *  @brief RankGroup. Used in various locations and is computed in
 *	mss_eff_cnfg_rank_group. Can be overwritten by ODM vendors if done
 *	from the PNOR or odm_eff_cnfg. creator: mss_eff_cnfg_rank_group
 *	consumer: various firmware notes: none
 */
enum CEN_EFF_PRIMARY_RANK_GROUP1
{
    CEN_EFF_PRIMARY_RANK_GROUP1_INVALID                            = 0x000000FF,
};

/**
 *  @brief RankGroup. Used in various locations and is computed in
 *	mss_eff_cnfg_rank_group. Can be overwritten by ODM vendors if done
 *	from the PNOR or odm_eff_cnfg. creator: mss_eff_cnfg_rank_group
 *	consumer: various firmware notes: none
 */
enum CEN_EFF_PRIMARY_RANK_GROUP2
{
    CEN_EFF_PRIMARY_RANK_GROUP2_INVALID                            = 0x000000FF,
};

/**
 *  @brief RankGroup. Used in various locations and is computed in
 *	mss_eff_cnfg_rank_group. Can be overwritten by ODM vendors if done
 *	from the PNOR or odm_eff_cnfg. creator: mss_eff_cnfg_rank_group
 *	consumer: various firmware notes: none
 */
enum CEN_EFF_PRIMARY_RANK_GROUP3
{
    CEN_EFF_PRIMARY_RANK_GROUP3_INVALID                            = 0x000000FF,
};

/**
 *  @brief RankGroup. Used in various locations and is computed in
 *	mss_eff_cnfg_rank_group. Can be overwritten by ODM vendors if done
 *	from the PNOR or odm_eff_cnfg. creator: mss_eff_cnfg_rank_group
 *	consumer: various firmware notes: none
 */
enum CEN_EFF_SECONDARY_RANK_GROUP0
{
    CEN_EFF_SECONDARY_RANK_GROUP0_INVALID                          = 0x000000FF,
};

/**
 *  @brief RankGroup. Used in various locations and is computed in
 *	mss_eff_cnfg_rank_group. Can be overwritten by ODM vendors if done
 *	from the PNOR or odm_eff_cnfg. creator: mss_eff_cnfg_rank_group
 *	consumer: various firmware notes: none
 */
enum CEN_EFF_SECONDARY_RANK_GROUP1
{
    CEN_EFF_SECONDARY_RANK_GROUP1_INVALID                          = 0x000000FF,
};

/**
 *  @brief RankGroup. Used in various locations and is computed in
 *	mss_eff_cnfg_rank_group. Can be overwritten by ODM vendors if done
 *	from the PNOR or odm_eff_cnfg. creator: mss_eff_cnfg_rank_group
 *	consumer: various firmware notes: none
 */
enum CEN_EFF_SECONDARY_RANK_GROUP2
{
    CEN_EFF_SECONDARY_RANK_GROUP2_INVALID                          = 0x000000FF,
};

/**
 *  @brief RankGroup. Used in various locations and is computed in
 *	mss_eff_cnfg_rank_group. Can be overwritten by ODM vendors if done
 *	from the PNOR or odm_eff_cnfg. creator: mss_eff_cnfg_rank_group
 *	consumer: various firmware notes: none
 */
enum CEN_EFF_SECONDARY_RANK_GROUP3
{
    CEN_EFF_SECONDARY_RANK_GROUP3_INVALID                          = 0x000000FF,
};

/**
 *  @brief RankGroup. Used in various locations and is computed in
 *	mss_eff_cnfg_rank_group. Can be overwritten by ODM vendors if done
 *	from the PNOR or odm_eff_cnfg. creator: mss_eff_cnfg_rank_group
 *	consumer: various firmware notes: none
 */
enum CEN_EFF_TERTIARY_RANK_GROUP0
{
    CEN_EFF_TERTIARY_RANK_GROUP0_INVALID                           = 0x000000FF,
};

/**
 *  @brief RankGroup. Used in various locations and is computed in
 *	mss_eff_cnfg_rank_group. Can be overwritten by ODM vendors if done
 *	from the PNOR or odm_eff_cnfg. creator: mss_eff_cnfg_rank_group
 *	consumer: various firmware notes: none
 */
enum CEN_EFF_TERTIARY_RANK_GROUP1
{
    CEN_EFF_TERTIARY_RANK_GROUP1_INVALID                           = 0x000000FF,
};

/**
 *  @brief RankGroup. Used in various locations and is computed in
 *	mss_eff_cnfg_rank_group. Can be overwritten by ODM vendors if done
 *	from the PNOR or odm_eff_cnfg. creator: mss_eff_cnfg_rank_group
 *	consumer: various firmware notes: none
 */
enum CEN_EFF_TERTIARY_RANK_GROUP2
{
    CEN_EFF_TERTIARY_RANK_GROUP2_INVALID                           = 0x000000FF,
};

/**
 *  @brief RankGroup. Used in various locations and is computed in
 *	mss_eff_cnfg_rank_group. Can be overwritten by ODM vendors if done
 *	from the PNOR or odm_eff_cnfg. creator: mss_eff_cnfg_rank_group
 *	consumer: various firmware notes: none
 */
enum CEN_EFF_TERTIARY_RANK_GROUP3
{
    CEN_EFF_TERTIARY_RANK_GROUP3_INVALID                           = 0x000000FF,
};

/**
 *  @brief RankGroup. Used in various locations and is computed in
 *	mss_eff_cnfg_rank_group. Can be overwritten by ODM vendors if done
 *	from the PNOR or odm_eff_cnfg. creator: mss_eff_cnfg_rank_group
 *	consumer: various firmware notes: none
 */
enum CEN_EFF_QUATERNARY_RANK_GROUP0
{
    CEN_EFF_QUATERNARY_RANK_GROUP0_INVALID                         = 0x000000FF,
};

/**
 *  @brief RankGroup. Used in various locations and is computed in
 *	mss_eff_cnfg_rank_group. Can be overwritten by ODM vendors if done
 *	from the PNOR or odm_eff_cnfg. creator: mss_eff_cnfg_rank_group
 *	consumer: various firmware notes: none
 */
enum CEN_EFF_QUATERNARY_RANK_GROUP1
{
    CEN_EFF_QUATERNARY_RANK_GROUP1_INVALID                         = 0x000000FF,
};

/**
 *  @brief RankGroup. Used in various locations and is computed in
 *	mss_eff_cnfg_rank_group. Can be overwritten by ODM vendors if done
 *	from the PNOR or odm_eff_cnfg. creator: mss_eff_cnfg_rank_group
 *	consumer: various firmware notes: none
 */
enum CEN_EFF_QUATERNARY_RANK_GROUP2
{
    CEN_EFF_QUATERNARY_RANK_GROUP2_INVALID                         = 0x000000FF,
};

/**
 *  @brief RankGroup. Used in various locations and is computed in
 *	mss_eff_cnfg_rank_group. Can be overwritten by ODM vendors if done
 *	from the PNOR or odm_eff_cnfg. creator: mss_eff_cnfg_rank_group
 *	consumer: various firmware notes: none
 */
enum CEN_EFF_QUATERNARY_RANK_GROUP3
{
    CEN_EFF_QUATERNARY_RANK_GROUP3_INVALID                         = 0x000000FF,
};

/**
 *  @brief DRAM Write Vref. Used in various locations and comes from the MT
 *	keyword of the VPD or is computed in mss_eff_cnfg_termination. Can
 *	be overwritten by ODM vendors if done from the PNOR or
 *	odm_eff_cnfg. creator: VPD(MT) or mss_eff_cnfg_termination
 *	consumer: various.C and initfile firmware notes: none This is the
 *	nominal value This is for DDR3
 */
enum CEN_EFF_DRAM_WR_VREF
{
    CEN_EFF_DRAM_WR_VREF_VDD420                                    = 0x000001A4,
    CEN_EFF_DRAM_WR_VREF_VDD425                                    = 0x000001A9,
    CEN_EFF_DRAM_WR_VREF_VDD430                                    = 0x000001AE,
    CEN_EFF_DRAM_WR_VREF_VDD435                                    = 0x000001B3,
    CEN_EFF_DRAM_WR_VREF_VDD440                                    = 0x000001B8,
    CEN_EFF_DRAM_WR_VREF_VDD445                                    = 0x000001BD,
    CEN_EFF_DRAM_WR_VREF_VDD450                                    = 0x000001C2,
    CEN_EFF_DRAM_WR_VREF_VDD455                                    = 0x000001C7,
    CEN_EFF_DRAM_WR_VREF_VDD460                                    = 0x000001CC,
    CEN_EFF_DRAM_WR_VREF_VDD465                                    = 0x000001D1,
    CEN_EFF_DRAM_WR_VREF_VDD470                                    = 0x000001D6,
    CEN_EFF_DRAM_WR_VREF_VDD475                                    = 0x000001DB,
    CEN_EFF_DRAM_WR_VREF_VDD480                                    = 0x000001E0,
    CEN_EFF_DRAM_WR_VREF_VDD485                                    = 0x000001E5,
    CEN_EFF_DRAM_WR_VREF_VDD490                                    = 0x000001EA,
    CEN_EFF_DRAM_WR_VREF_VDD495                                    = 0x000001EF,
    CEN_EFF_DRAM_WR_VREF_VDD500                                    = 0x000001F4,
    CEN_EFF_DRAM_WR_VREF_VDD505                                    = 0x000001F9,
    CEN_EFF_DRAM_WR_VREF_VDD510                                    = 0x000001FE,
    CEN_EFF_DRAM_WR_VREF_VDD515                                    = 0x00000203,
    CEN_EFF_DRAM_WR_VREF_VDD520                                    = 0x00000208,
    CEN_EFF_DRAM_WR_VREF_VDD525                                    = 0x0000020D,
    CEN_EFF_DRAM_WR_VREF_VDD530                                    = 0x00000212,
    CEN_EFF_DRAM_WR_VREF_VDD535                                    = 0x00000217,
    CEN_EFF_DRAM_WR_VREF_VDD540                                    = 0x0000021C,
    CEN_EFF_DRAM_WR_VREF_VDD545                                    = 0x00000221,
    CEN_EFF_DRAM_WR_VREF_VDD550                                    = 0x00000226,
    CEN_EFF_DRAM_WR_VREF_VDD555                                    = 0x0000022B,
    CEN_EFF_DRAM_WR_VREF_VDD560                                    = 0x00000230,
    CEN_EFF_DRAM_WR_VREF_VDD565                                    = 0x00000235,
    CEN_EFF_DRAM_WR_VREF_VDD570                                    = 0x0000023A,
    CEN_EFF_DRAM_WR_VREF_VDD575                                    = 0x0000023F,
};

/**
 *  @brief Centaur DQ and DQS Drive Impedance Used in various locations and
 *	comes from the MT Keyword of the VPD or is computed in
 *	mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done
 *	from the PNOR or odm_eff_cnfg. creator:
 *	VPD(MT)/mss_eff_cnfg_termination consumer: initfile,various.C files
 *	firmware notes: none This is the nominal value
 */
enum CEN_EFF_CEN_DRV_IMP_DQ_DQS
{
    CEN_EFF_CEN_DRV_IMP_DQ_DQS_OHM24_FFE0                          = 0x0000000A,
    CEN_EFF_CEN_DRV_IMP_DQ_DQS_OHM30_FFE0                          = 0x00000008,
    CEN_EFF_CEN_DRV_IMP_DQ_DQS_OHM30_FFE480                        = 0x00000048,
    CEN_EFF_CEN_DRV_IMP_DQ_DQS_OHM30_FFE240                        = 0x00000038,
    CEN_EFF_CEN_DRV_IMP_DQ_DQS_OHM30_FFE160                        = 0x00000028,
    CEN_EFF_CEN_DRV_IMP_DQ_DQS_OHM30_FFE120                        = 0x00000018,
    CEN_EFF_CEN_DRV_IMP_DQ_DQS_OHM34_FFE0                          = 0x00000007,
    CEN_EFF_CEN_DRV_IMP_DQ_DQS_OHM34_FFE480                        = 0x00000047,
    CEN_EFF_CEN_DRV_IMP_DQ_DQS_OHM34_FFE240                        = 0x00000037,
    CEN_EFF_CEN_DRV_IMP_DQ_DQS_OHM34_FFE160                        = 0x00000027,
    CEN_EFF_CEN_DRV_IMP_DQ_DQS_OHM34_FFE120                        = 0x00000017,
    CEN_EFF_CEN_DRV_IMP_DQ_DQS_OHM40_FFE0                          = 0x00000006,
    CEN_EFF_CEN_DRV_IMP_DQ_DQS_OHM40_FFE480                        = 0x00000046,
    CEN_EFF_CEN_DRV_IMP_DQ_DQS_OHM40_FFE240                        = 0x00000036,
    CEN_EFF_CEN_DRV_IMP_DQ_DQS_OHM40_FFE160                        = 0x00000026,
    CEN_EFF_CEN_DRV_IMP_DQ_DQS_OHM40_FFE120                        = 0x00000016,
};

/**
 *  @brief Centaur DQ and DQS Receiver Impedance Used in various locations
 *	and it comes from the VPD MT keyword for custom DIMMs or is
 *	computed in mss_eff_cnfg_termination. Can be overwritten by ODM
 *	vendors if done from the PNOR or odm_eff_cnfg. creator: VPD,
 *	mss_eff_cnfg_termination Consumer: initfile + C code firmware
 *	notes: none This is the nominal value
 */
enum CEN_EFF_CEN_RCV_IMP_DQ_DQS
{
    CEN_EFF_CEN_RCV_IMP_DQ_DQS_OHM15                               = 0x0000000F,
    CEN_EFF_CEN_RCV_IMP_DQ_DQS_OHM20                               = 0x00000014,
    CEN_EFF_CEN_RCV_IMP_DQ_DQS_OHM30                               = 0x0000001E,
    CEN_EFF_CEN_RCV_IMP_DQ_DQS_OHM40                               = 0x00000028,
    CEN_EFF_CEN_RCV_IMP_DQ_DQS_OHM48                               = 0x00000030,
    CEN_EFF_CEN_RCV_IMP_DQ_DQS_OHM60                               = 0x0000003C,
    CEN_EFF_CEN_RCV_IMP_DQ_DQS_OHM80                               = 0x00000050,
    CEN_EFF_CEN_RCV_IMP_DQ_DQS_OHM120                              = 0x00000078,
    CEN_EFF_CEN_RCV_IMP_DQ_DQS_OHM160                              = 0x000000A0,
    CEN_EFF_CEN_RCV_IMP_DQ_DQS_OHM240                              = 0x000000F0,
};

/**
 *  @brief Centaur DQ and DQS Slew Rate Used in various locations and comes
 *	from the MT keyword of the VPD or is computed in
 *	mss_eff_cnfg_termination. Slowest slew rate is 0, incrementing by
 *	one. The lower the number the slower the slew rate the higher the
 *	faster. Can be overwritten by ODM vendors if done from the PNOR or
 *	odm_eff_cnfg. creator: VPD(MT), mss_eff_cnfg_termination consumer:
 *	initfiles,various.C firmware notes: none This is the nominal value
 */
enum CEN_EFF_CEN_SLEW_RATE_DQ_DQS
{
    CEN_EFF_CEN_SLEW_RATE_DQ_DQS_SLEW_3V_NS                        = 0x00000003,
    CEN_EFF_CEN_SLEW_RATE_DQ_DQS_SLEW_4V_NS                        = 0x00000004,
    CEN_EFF_CEN_SLEW_RATE_DQ_DQS_SLEW_5V_NS                        = 0x00000005,
    CEN_EFF_CEN_SLEW_RATE_DQ_DQS_SLEW_6V_NS                        = 0x00000006,
    CEN_EFF_CEN_SLEW_RATE_DQ_DQS_SLEW_MAXV_NS                      = 0x00000007,
};

/**
 *  @brief Centaur Read Vref. Used in various locations and comes from the
 *	MT keyword of the VPD or is computed in mss_eff_cnfg_termination.
 *	Can be overwritten by ODM vendors if done from the PNOR or
 *	odm_eff_cnfg. Creator: VPD(MT) or mss_eff_cnfg_termination
 *	consumer: various.C and initfiles firmware notes: none This is the
 *	nominal value
 */
enum CEN_EFF_RD_VREF
{
    CEN_EFF_RD_VREF_VDD40375                                       = 0x00009DB7,
    CEN_EFF_RD_VREF_VDD41750                                       = 0x0000A316,
    CEN_EFF_RD_VREF_VDD43125                                       = 0x0000A875,
    CEN_EFF_RD_VREF_VDD44500                                       = 0x0000ADD4,
    CEN_EFF_RD_VREF_VDD45875                                       = 0x0000B333,
    CEN_EFF_RD_VREF_VDD47250                                       = 0x0000B892,
    CEN_EFF_RD_VREF_VDD48625                                       = 0x0000BDF1,
    CEN_EFF_RD_VREF_VDD50000                                       = 0x0000C350,
    CEN_EFF_RD_VREF_VDD51375                                       = 0x0000C8AF,
    CEN_EFF_RD_VREF_VDD52750                                       = 0x0000CE0E,
    CEN_EFF_RD_VREF_VDD54125                                       = 0x0000D36D,
    CEN_EFF_RD_VREF_VDD55500                                       = 0x0000D8CC,
    CEN_EFF_RD_VREF_VDD56875                                       = 0x0000DE2B,
    CEN_EFF_RD_VREF_VDD58250                                       = 0x0000E38A,
    CEN_EFF_RD_VREF_VDD59625                                       = 0x0000E8E9,
    CEN_EFF_RD_VREF_VDD61000                                       = 0x0000EE48,
    CEN_EFF_RD_VREF_VDD60375                                       = 0x0000EBD7,
    CEN_EFF_RD_VREF_VDD61750                                       = 0x0000F136,
    CEN_EFF_RD_VREF_VDD63125                                       = 0x0000F695,
    CEN_EFF_RD_VREF_VDD64500                                       = 0x0000FBF4,
    CEN_EFF_RD_VREF_VDD65875                                       = 0x00010153,
    CEN_EFF_RD_VREF_VDD67250                                       = 0x000106B2,
    CEN_EFF_RD_VREF_VDD68625                                       = 0x00010C11,
    CEN_EFF_RD_VREF_VDD70000                                       = 0x00011170,
    CEN_EFF_RD_VREF_VDD71375                                       = 0x000116CF,
    CEN_EFF_RD_VREF_VDD72750                                       = 0x00011C2E,
    CEN_EFF_RD_VREF_VDD74125                                       = 0x0001218D,
    CEN_EFF_RD_VREF_VDD75500                                       = 0x000126EC,
    CEN_EFF_RD_VREF_VDD76875                                       = 0x00012C4B,
    CEN_EFF_RD_VREF_VDD78250                                       = 0x000131AA,
    CEN_EFF_RD_VREF_VDD79625                                       = 0x00013709,
    CEN_EFF_RD_VREF_VDD81000                                       = 0x00013C68,
};

/**
 *  @brief Burst Length. Used in various locations and is computed in
 *	mss_eff_cnfg. Can be overwritten by ODM vendors if done from the
 *	PNOR or odm_eff_cnfg. Each memory channel will have a value.
 *	creator: mss_eff_cnfg consumer: various firmware notes: none
 */
enum CEN_EFF_DRAM_BL
{
    CEN_EFF_DRAM_BL_BL8                                            = 0x00000000,
    CEN_EFF_DRAM_BL_OTF                                            = 0x00000001,
    CEN_EFF_DRAM_BL_BC4                                            = 0x00000002,
};

/**
 *  @brief Additive Latency. Used in various locations and is computed in
 *	mss_eff_cnfg_timing. Can be overwritten by ODM vendors if done from
 *	the PNOR or odm_eff_cnfg. Each memory channel will have a value.
 *	creator: mss_eff_cnfg_timing consumer: various firmware notes: none
 */
enum CEN_EFF_DRAM_AL
{
    CEN_EFF_DRAM_AL_DISABLE                                        = 0x00000000,
    CEN_EFF_DRAM_AL_CL_MINUS_1                                     = 0x00000001,
    CEN_EFF_DRAM_AL_CL_MINUS_2                                     = 0x00000002,
    CEN_EFF_DRAM_AL_CL_MINUS_3                                     = 0x00000003,
};

/**
 *  @brief Read Burst Type. Used in various locations and is computed in
 *	mss_eff_cnfg. Can be overwritten by ODM vendors if done from the
 *	PNOR or odm_eff_cnfg. Each memory channel will have a value.
 *	creator: mss_eff_cnfg consumer: various firmware notes: none
 */
enum CEN_EFF_DRAM_RBT
{
    CEN_EFF_DRAM_RBT_SEQUENTIAL                                    = 0x00000000,
    CEN_EFF_DRAM_RBT_INTERLEAVE                                    = 0x00000001,
};

/**
 *  @brief Test Mode. Used in various locations and is computed in
 *	mss_eff_cnfg. Can be overwritten by ODM vendors if done from the
 *	PNOR or odm_eff_cnfg. Each memory channel will have a value.
 *	creator: mss_eff_cnfg consumer: various firmware notes: none
 */
enum CEN_EFF_DRAM_TM
{
    CEN_EFF_DRAM_TM_NORMAL                                         = 0x00000000,
    CEN_EFF_DRAM_TM_TEST                                           = 0x00000001,
};

/**
 *  @brief DLL Reset. Used in various locations and is computed in
 *	mss_eff_cnfg. Can be overwritten by ODM vendors if done from the
 *	PNOR or odm_eff_cnfg. Each memory channel will have a value.
 *	creator: mss_eff_cnfg consumer: various firmware notes: none
 */
enum CEN_EFF_DRAM_DLL_RESET
{
    CEN_EFF_DRAM_DLL_RESET_NO                                      = 0x00000000,
    CEN_EFF_DRAM_DLL_RESET_YES                                     = 0x00000001,
};

/**
 *  @brief DLL Precharge PD. Used in various locations and is computed in
 *	mss_eff_cnfg. Can be overwritten by ODM vendors if done from the
 *	PNOR or odm_eff_cnfg. Each memory channel will have a value.
 *	creator: mss_eff_cnfg consumer: various firmware notes: none
 */
enum CEN_EFF_DRAM_DLL_PPD
{
    CEN_EFF_DRAM_DLL_PPD_SLOWEXIT                                  = 0x00000000,
    CEN_EFF_DRAM_DLL_PPD_FASTEXIT                                  = 0x00000001,
};

/**
 *  @brief DLL Enable. Used in various locations and is computed in
 *	mss_eff_cnfg. Can be overwritten by ODM vendors if done from the
 *	PNOR or odm_eff_cnfg. Each memory channel will have a value.
 *	creator: mss_eff_cnfg consumer: various firmware notes: none
 */
enum CEN_EFF_DRAM_DLL_ENABLE
{
    CEN_EFF_DRAM_DLL_ENABLE_ENABLE                                 = 0x00000000,
    CEN_EFF_DRAM_DLL_ENABLE_DISABLE                                = 0x00000001,
};

/**
 *  @brief TDQS. Used in various locations and is computed in mss_eff_cnfg.
 *	Can be overwritten by ODM vendors if done from the PNOR or
 *	odm_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum CEN_EFF_DRAM_TDQS
{
    CEN_EFF_DRAM_TDQS_DISABLE                                      = 0x00000000,
    CEN_EFF_DRAM_TDQS_ENABLE                                       = 0x00000001,
};

/**
 *  @brief Write Level Enable. Used in various locations and is computed in
 *	mss_eff_cnfg. Can be overwritten by ODM vendors if done from the
 *	PNOR or odm_eff_cnfg. Each memory channel will have a value.
 *	creator: mss_eff_cnfg consumer: various firmware notes: none
 */
enum CEN_EFF_DRAM_WR_LVL_ENABLE
{
    CEN_EFF_DRAM_WR_LVL_ENABLE_DISABLE                             = 0x00000000,
    CEN_EFF_DRAM_WR_LVL_ENABLE_ENABLE                              = 0x00000001,
};

/**
 *  @brief DRAM Qoff. Enables or disables DRAM output. Used in various
 *	locations and is computed in mss_eff_cnfg. Can be overwritten by
 *	ODM vendors if done from the PNOR or odm_eff_cnfg. Each memory
 *	channel will have a value. creator: mss_eff_cnfg consumer: various
 *	firmware notes: none
 */
enum CEN_EFF_DRAM_OUTPUT_BUFFER
{
    CEN_EFF_DRAM_OUTPUT_BUFFER_ENABLE                              = 0x00000000,
    CEN_EFF_DRAM_OUTPUT_BUFFER_DISABLE                             = 0x00000001,
};

/**
 *  @brief Partial Array Self-Refresh. Used in various locations and is
 *	computed in mss_eff_cnfg. Can be overwritten by ODM vendors if done
 *	from the PNOR or odm_eff_cnfg. Each memory channel will have a
 *	value. creator: mss_eff_cnfg consumer: various firmware notes: none
 */
enum CEN_EFF_DRAM_PASR
{
    CEN_EFF_DRAM_PASR_FULL                                         = 0x00000000,
    CEN_EFF_DRAM_PASR_FIRST_HALF                                   = 0x00000001,
    CEN_EFF_DRAM_PASR_FIRST_QUARTER                                = 0x00000002,
    CEN_EFF_DRAM_PASR_FIRST_EIGHTH                                 = 0x00000003,
    CEN_EFF_DRAM_PASR_LAST_THREE_FOURTH                            = 0x00000004,
    CEN_EFF_DRAM_PASR_LAST_HALF                                    = 0x00000005,
    CEN_EFF_DRAM_PASR_LAST_QUARTER                                 = 0x00000006,
    CEN_EFF_DRAM_PASR_LAST_EIGHTH                                  = 0x00000007,
};

/**
 *  @brief Auto Self-Refresh. Used in various locations and is computed in
 *	mss_eff_cnfg. Can be overwritten by ODM vendors if done from the
 *	PNOR or odm_eff_cnfg. Each memory channel will have a value.
 *	creator: mss_eff_cnfg consumer: various firmware notes: none
 */
enum CEN_EFF_DRAM_ASR
{
    CEN_EFF_DRAM_ASR_SRT                                           = 0x00000000,
    CEN_EFF_DRAM_ASR_ASR                                           = 0x00000001,
};

/**
 *  @brief Self-Refresh Temperature Range. Used in various locations and is
 *	computed in mss_eff_cnfg. Can be overwritten by ODM vendors if done
 *	from the PNOR or odm_eff_cnfg. Each memory channel will have a
 *	value. creator: mss_eff_cnfg consumer: various firmware notes: none
 */
enum CEN_EFF_DRAM_SRT
{
    CEN_EFF_DRAM_SRT_NORMAL                                        = 0x00000000,
    CEN_EFF_DRAM_SRT_EXTEND                                        = 0x00000001,
};

/**
 *  @brief Multi Purpose Register Mode. Used in various locations and is
 *	computed in mss_eff_cnfg. Can be overwritten by ODM vendors if done
 *	from the PNOR or odm_eff_cnfg. Each memory channel will have a
 *	value. creator: mss_eff_cnfg consumer: various firmware notes: none
 */
enum CEN_EFF_MPR_MODE
{
    CEN_EFF_MPR_MODE_DISABLE                                       = 0x00000000,
    CEN_EFF_MPR_MODE_ENABLE                                        = 0x00000001,
};

/**
 *  @brief Specifies the schmoo mode to use during draminit_train_adv.
 */
enum CEN_EFF_SCHMOO_MODE
{
    CEN_EFF_SCHMOO_MODE_FAST                                       = 0x00000000,
    CEN_EFF_SCHMOO_MODE_ONE_SLOW                                   = 0x00000001,
    CEN_EFF_SCHMOO_MODE_QUARTER_SLOW                               = 0x00000002,
    CEN_EFF_SCHMOO_MODE_HALF_SLOW                                  = 0x00000003,
    CEN_EFF_SCHMOO_MODE_FULL_SLOW                                  = 0x00000004,
    CEN_EFF_SCHMOO_MODE_ONE_CHAR                                   = 0x00000005,
    CEN_EFF_SCHMOO_MODE_QUARTER_CHAR                               = 0x00000006,
    CEN_EFF_SCHMOO_MODE_HALF_CHAR                                  = 0x00000007,
    CEN_EFF_SCHMOO_MODE_FULL_CHAR                                  = 0x00000008,
};

/**
 *  @brief Specifies the schmoo mode to use during draminit_train_adv
 */
enum CEN_EFF_SCHMOO_ADDR_MODE
{
    CEN_EFF_SCHMOO_ADDR_MODE_FEW_ADDR                              = 0x00000000,
    CEN_EFF_SCHMOO_ADDR_MODE_QUARTER_ADDR                          = 0x00000001,
    CEN_EFF_SCHMOO_ADDR_MODE_HALF_ADDR                             = 0x00000002,
    CEN_EFF_SCHMOO_ADDR_MODE_FULL_ADDR                             = 0x00000003,
};

/**
 *  @brief Specifies the schmoo test to run during draminit_train_adv. Bit
 *	wise.
 */
enum CEN_EFF_SCHMOO_TEST_VALID
{
    CEN_EFF_SCHMOO_TEST_VALID_NONE                                 = 0x00000000,
    CEN_EFF_SCHMOO_TEST_VALID_MCBIST                               = 0x00000001,
    CEN_EFF_SCHMOO_TEST_VALID_WR_EYE                               = 0x00000002,
    CEN_EFF_SCHMOO_TEST_VALID_RD_EYE                               = 0x00000004,
    CEN_EFF_SCHMOO_TEST_VALID_WR_DQS                               = 0x00000008,
    CEN_EFF_SCHMOO_TEST_VALID_RD_DQS                               = 0x00000010,
};

/**
 *  @brief Specifies the schmoo parameters to use during
 *	draminit_train_adv. Bit wise.
 */
enum CEN_EFF_SCHMOO_PARAM_VALID
{
    CEN_EFF_SCHMOO_PARAM_VALID_PARAM_NONE                          = 0x00000000,
    CEN_EFF_SCHMOO_PARAM_VALID_DELAY_REG                           = 0x00000001,
    CEN_EFF_SCHMOO_PARAM_VALID_DRV_IMP                             = 0x00000002,
    CEN_EFF_SCHMOO_PARAM_VALID_SLEW_RATE                           = 0x00000004,
    CEN_EFF_SCHMOO_PARAM_VALID_WR_VREF                             = 0x00000008,
    CEN_EFF_SCHMOO_PARAM_VALID_RD_VREF                             = 0x00000010,
    CEN_EFF_SCHMOO_PARAM_VALID_RCV_IMP                             = 0x00000020,
};

/**
 *  @brief Specifies the memcal interval in clocks.
 */
enum CEN_EFF_MEMCAL_INTERVAL
{
    CEN_EFF_MEMCAL_INTERVAL_DISABLE                                = 0x00000000,
};

/**
 *  @brief Specifies the zqcal interval in clocks.
 */
enum CEN_EFF_ZQCAL_INTERVAL
{
    CEN_EFF_ZQCAL_INTERVAL_DISABLE                                 = 0x00000000,
};

/**
 *  @brief Specifies the memory topology type. See centaur workbook.
 */
enum CEN_EFF_IBM_TYPE
{
    CEN_EFF_IBM_TYPE_UNDEFINED                                     = 0x00000000,
    CEN_EFF_IBM_TYPE_TYPE_1A                                       = 0x00000001,
    CEN_EFF_IBM_TYPE_TYPE_1B                                       = 0x00000002,
    CEN_EFF_IBM_TYPE_TYPE_1C                                       = 0x00000003,
    CEN_EFF_IBM_TYPE_TYPE_1D                                       = 0x00000004,
    CEN_EFF_IBM_TYPE_TYPE_2A                                       = 0x00000005,
    CEN_EFF_IBM_TYPE_TYPE_2B                                       = 0x00000006,
    CEN_EFF_IBM_TYPE_TYPE_2C                                       = 0x00000007,
    CEN_EFF_IBM_TYPE_TYPE_3A                                       = 0x00000008,
    CEN_EFF_IBM_TYPE_TYPE_3B                                       = 0x00000009,
    CEN_EFF_IBM_TYPE_TYPE_3C                                       = 0x0000000A,
    CEN_EFF_IBM_TYPE_TYPE_4A                                       = 0x0000000B,
    CEN_EFF_IBM_TYPE_TYPE_4B                                       = 0x0000000C,
    CEN_EFF_IBM_TYPE_TYPE_4C                                       = 0x0000000D,
    CEN_EFF_IBM_TYPE_TYPE_5A                                       = 0x0000000E,
    CEN_EFF_IBM_TYPE_TYPE_5B                                       = 0x0000000F,
    CEN_EFF_IBM_TYPE_TYPE_5C                                       = 0x00000010,
    CEN_EFF_IBM_TYPE_TYPE_5D                                       = 0x00000011,
    CEN_EFF_IBM_TYPE_TYPE_6A                                       = 0x00000012,
    CEN_EFF_IBM_TYPE_TYPE_6B                                       = 0x00000013,
    CEN_EFF_IBM_TYPE_TYPE_6C                                       = 0x00000014,
    CEN_EFF_IBM_TYPE_TYPE_7A                                       = 0x00000015,
    CEN_EFF_IBM_TYPE_TYPE_7B                                       = 0x00000016,
    CEN_EFF_IBM_TYPE_TYPE_7C                                       = 0x00000017,
    CEN_EFF_IBM_TYPE_TYPE_8A                                       = 0x00000018,
    CEN_EFF_IBM_TYPE_TYPE_8B                                       = 0x00000019,
    CEN_EFF_IBM_TYPE_TYPE_8C                                       = 0x0000001A,
};

/**
 *  @brief Specifies the number of DIMM dimensions that are valid per port.
 */
enum CEN_EFF_NUM_DROPS_PER_PORT
{
    CEN_EFF_NUM_DROPS_PER_PORT_EMPTY                               = 0x00000000,
    CEN_EFF_NUM_DROPS_PER_PORT_SINGLE                              = 0x00000001,
    CEN_EFF_NUM_DROPS_PER_PORT_DUAL                                = 0x00000002,
};

/**
 *  @brief Specifies the DRAM package type.
 */
enum CEN_EFF_STACK_TYPE
{
    CEN_EFF_STACK_TYPE_NONE                                        = 0x00000000,
    CEN_EFF_STACK_TYPE_DDP_QDP                                     = 0x00000001,
    CEN_EFF_STACK_TYPE_STACK_3DS                                   = 0x00000002,
};

/**
 *  @brief Value of on or off. On is 256 bit interleave. Off, the
 *	translation is on 128 bit interleave mode. See centaur workbook
 *	chapter 5.
 */
enum CEN_MSS_DERIVED_MBA_CACHELINE_INTERLEAVE_MODE
{
    CEN_MSS_DERIVED_MBA_CACHELINE_INTERLEAVE_MODE_OFF              = 0x00000000,
    CEN_MSS_DERIVED_MBA_CACHELINE_INTERLEAVE_MODE_ON               = 0x00000001,
};

/**
 *  @brief At a system level, this attribute controls if interleaving is
 *	required, requested or never. The MRW.
 */
enum CEN_MRW_MBA_CACHELINE_INTERLEAVE_MODE_CONTROL
{
    CEN_MRW_MBA_CACHELINE_INTERLEAVE_MODE_CONTROL_NEVER            = 0x00000000,
    CEN_MRW_MBA_CACHELINE_INTERLEAVE_MODE_CONTROL_REQUIRED         = 0x00000001,
    CEN_MRW_MBA_CACHELINE_INTERLEAVE_MODE_CONTROL_REQUESTED        = 0x00000002,
};

/**
 *  @brief Reflects the functionality of the L4 Cache. Determines if the L4
 *	is enabled or not. See chapter 6 of the Centaur Workbook. On means
 *	the full cache is enabled. HALF_A (EVEN) means only A is enabled
 *	and HALF_B (ODD) means only B is enabled. For DD1X, the values of
 *	UNK_OFF, UNK_ON, UNK_HALF_A and UNK_HALFB were added because early
 *	parts did not have the fuses blown correctly, so the cache repairs
 *	may not have worked. This value is set by the platform which can
 *	get the chips value by running the mss_cen_get_ecid function. Note:
 *	Cronus and Firmware plus our initfiles do not really support any of
 *	the UNK values. It is the responsibility of the platform to map the
 *	UNK values to the appropriate value of OFF/ON/HALF_A/HALF_B
 */
enum CEN_MSS_CACHE_ENABLE
{
    CEN_MSS_CACHE_ENABLE_OFF                                       = 0x00000000,
    CEN_MSS_CACHE_ENABLE_ON                                        = 0x00000001,
    CEN_MSS_CACHE_ENABLE_HALF_A                                    = 0x00000003,
    CEN_MSS_CACHE_ENABLE_HALF_B                                    = 0x00000005,
    CEN_MSS_CACHE_ENABLE_UNK_OFF                                   = 0x00000008,
    CEN_MSS_CACHE_ENABLE_UNK_ON                                    = 0x00000009,
    CEN_MSS_CACHE_ENABLE_UNK_HALF_A                                = 0x0000000B,
    CEN_MSS_CACHE_ENABLE_UNK_HALF_B                                = 0x0000000D,
};

/**
 *  @brief Value of on or off. Determines if prefetching enabled or not.
 *	See chapter 7 of the Centaur Workbook.
 */
enum CEN_MSS_PREFETCH_ENABLE
{
    CEN_MSS_PREFETCH_ENABLE_OFF                                    = 0x00000000,
    CEN_MSS_PREFETCH_ENABLE_ON                                     = 0x00000001,
};

/**
 *  @brief Value of on or off. Determines if the cleaner of the L4 cache
 *	(write modified entries to memory on idle cycles) enabled or not.
 *	See chapter 7 of the Centaur Workbook.
 */
enum CEN_MSS_CLEANER_ENABLE
{
    CEN_MSS_CLEANER_ENABLE_OFF                                     = 0x00000000,
    CEN_MSS_CLEANER_ENABLE_ON                                      = 0x00000001,
};

/**
 *  @brief Low Power Auto Self-Refresh. This is for DDR4 MRS2. Computed in
 *	mss_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum CEN_EFF_DRAM_LPASR
{
    CEN_EFF_DRAM_LPASR_MANUAL_NORMAL                               = 0x00000000,
    CEN_EFF_DRAM_LPASR_MANUAL_REDUCED                              = 0x00000001,
    CEN_EFF_DRAM_LPASR_MANUAL_EXTENDED                             = 0x00000002,
    CEN_EFF_DRAM_LPASR_ASR                                         = 0x00000003,
};

/**
 *  @brief MPR Page Selection This is for DDR4 MRS3. Computed in
 *	mss_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum CEN_EFF_MPR_PAGE
{
    CEN_EFF_MPR_PAGE_PG0                                           = 0x00000000,
    CEN_EFF_MPR_PAGE_PG1                                           = 0x00000001,
    CEN_EFF_MPR_PAGE_PG2                                           = 0x00000002,
    CEN_EFF_MPR_PAGE_PG3                                           = 0x00000003,
};

/**
 *  @brief Gear Down Mode. This is for DDR4 MRS3. Computed in mss_eff_cnfg.
 *	Each memory channel will have a value. creator: mss_eff_cnfg
 *	consumer: various firmware notes: none
 */
enum CEN_EFF_GEARDOWN_MODE
{
    CEN_EFF_GEARDOWN_MODE_HALF                                     = 0x00000000,
    CEN_EFF_GEARDOWN_MODE_QUARTER                                  = 0x00000001,
};

/**
 *  @brief Per DRAM accessibility. This is for DDR4 MRS3. Computed in
 *	mss_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum CEN_EFF_PER_DRAM_ACCESS
{
    CEN_EFF_PER_DRAM_ACCESS_DISABLE                                = 0x00000000,
    CEN_EFF_PER_DRAM_ACCESS_ENABLE                                 = 0x00000001,
};

/**
 *  @brief Temperature sensor readout. This is for DDR4 MRS3. Computed in
 *	mss_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum CEN_EFF_TEMP_READOUT
{
    CEN_EFF_TEMP_READOUT_DISABLE                                   = 0x00000000,
    CEN_EFF_TEMP_READOUT_ENABLE                                    = 0x00000001,
};

/**
 *  @brief Fine refresh mode. This is for DDR4 MRS3. Computed in
 *	mss_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum CEN_EFF_FINE_REFRESH_MODE
{
    CEN_EFF_FINE_REFRESH_MODE_NORMAL                               = 0x00000000,
    CEN_EFF_FINE_REFRESH_MODE_FIXED_2X                             = 0x00000001,
    CEN_EFF_FINE_REFRESH_MODE_FIXED_4X                             = 0x00000002,
    CEN_EFF_FINE_REFRESH_MODE_FLY_2X                               = 0x00000005,
    CEN_EFF_FINE_REFRESH_MODE_FLY_4X                               = 0x00000006,
};

/**
 *  @brief write latency for CRC and DM. This is for DDR4 MRS3. Computed in
 *	mss_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum CEN_EFF_CRC_WR_LATENCY
{
    CEN_EFF_CRC_WR_LATENCY_4NCK                                    = 0x00000004,
    CEN_EFF_CRC_WR_LATENCY_5NCK                                    = 0x00000005,
    CEN_EFF_CRC_WR_LATENCY_6NCK                                    = 0x00000006,
};

/**
 *  @brief MPR READ FORMAT. This is for DDR4 MRS3. Computed in
 *	mss_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum CEN_EFF_MPR_RD_FORMAT
{
    CEN_EFF_MPR_RD_FORMAT_SERIAL                                   = 0x00000000,
    CEN_EFF_MPR_RD_FORMAT_PARALLEL                                 = 0x00000001,
    CEN_EFF_MPR_RD_FORMAT_STAGGERED                                = 0x00000002,
    CEN_EFF_MPR_RD_FORMAT_RESERVED_TEMP                            = 0x00000003,
};

/**
 *  @brief Max Power down mode. This is for DDR4 MRS4. Computed in
 *	mss_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum CEN_EFF_MAX_POWERDOWN_MODE
{
    CEN_EFF_MAX_POWERDOWN_MODE_DISABLE                             = 0x00000000,
    CEN_EFF_MAX_POWERDOWN_MODE_ENABLE                              = 0x00000001,
};

/**
 *  @brief Temp ref range. This is for DDR4 MRS4. Computed in mss_eff_cnfg.
 *	Each memory channel will have a value. creator: mss_eff_cnfg
 *	consumer: various firmware notes: none
 */
enum CEN_EFF_TEMP_REF_RANGE
{
    CEN_EFF_TEMP_REF_RANGE_NORMAL                                  = 0x00000000,
    CEN_EFF_TEMP_REF_RANGE_EXTEND                                  = 0x00000001,
};

/**
 *  @brief Temp controlled ref mode. This is for DDR4 MRS4. Computed in
 *	mss_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum CEN_EFF_TEMP_REF_MODE
{
    CEN_EFF_TEMP_REF_MODE_DISABLE                                  = 0x00000000,
    CEN_EFF_TEMP_REF_MODE_ENABLE                                   = 0x00000001,
};

/**
 *  @brief Internal Vref Monitor.. This is for DDR4 MRS4. Computed in
 *	mss_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum CEN_EFF_INT_VREF_MON
{
    CEN_EFF_INT_VREF_MON_DISABLE                                   = 0x00000000,
    CEN_EFF_INT_VREF_MON_ENABLE                                    = 0x00000001,
};

/**
 *  @brief CS to CMD/ADDR Latency. This is for DDR4 MRS4. Computed in
 *	mss_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum CEN_EFF_CS_CMD_LATENCY
{
    CEN_EFF_CS_CMD_LATENCY_DISABLE                                 = 0x00000000,
    CEN_EFF_CS_CMD_LATENCY_3CYC                                    = 0x00000003,
    CEN_EFF_CS_CMD_LATENCY_4CYC                                    = 0x00000004,
    CEN_EFF_CS_CMD_LATENCY_5CYC                                    = 0x00000005,
    CEN_EFF_CS_CMD_LATENCY_6CYC                                    = 0x00000006,
    CEN_EFF_CS_CMD_LATENCY_8CYC                                    = 0x00000008,
};

/**
 *  @brief Self Refresh Abort. This is for DDR4 MRS4. Computed in
 *	mss_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum CEN_EFF_SELF_REF_ABORT
{
    CEN_EFF_SELF_REF_ABORT_DISABLE                                 = 0x00000000,
    CEN_EFF_SELF_REF_ABORT_ENABLE                                  = 0x00000001,
};

/**
 *  @brief Read Pre amble Training Mode. This is for DDR4 MRS4. Computed in
 *	mss_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum CEN_EFF_RD_PREAMBLE_TRAIN
{
    CEN_EFF_RD_PREAMBLE_TRAIN_DISABLE                              = 0x00000000,
    CEN_EFF_RD_PREAMBLE_TRAIN_ENABLE                               = 0x00000001,
};

/**
 *  @brief Read Pre amble. This is for DDR4 MRS4. Computed in mss_eff_cnfg.
 *	Each memory channel will have a value. creator: mss_eff_cnfg
 *	consumer: various firmware notes: none
 */
enum CEN_EFF_RD_PREAMBLE
{
    CEN_EFF_RD_PREAMBLE_1NCLK                                      = 0x00000001,
    CEN_EFF_RD_PREAMBLE_2NCLK                                      = 0x00000002,
};

/**
 *  @brief Write Pre amble. This is for DDR4 MRS4. Computed in
 *	mss_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum CEN_EFF_WR_PREAMBLE
{
    CEN_EFF_WR_PREAMBLE_1NCLK                                      = 0x00000001,
    CEN_EFF_WR_PREAMBLE_2NCLK                                      = 0x00000002,
};

/**
 *  @brief C/A Parity Latency Mode. This is for DDR4 MRS5. Computed in
 *	mss_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum CEN_EFF_CA_PARITY_LATENCY
{
    CEN_EFF_CA_PARITY_LATENCY_DISABLE                              = 0x00000000,
    CEN_EFF_CA_PARITY_LATENCY_PL4                                  = 0x00000004,
    CEN_EFF_CA_PARITY_LATENCY_PL5                                  = 0x00000005,
    CEN_EFF_CA_PARITY_LATENCY_PL6                                  = 0x00000006,
    CEN_EFF_CA_PARITY_LATENCY_PL8                                  = 0x00000008,
};

/**
 *  @brief CRC Error Clear. This is for DDR4 MRS5. Computed in
 *	mss_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum CEN_EFF_CRC_ERROR_CLEAR
{
    CEN_EFF_CRC_ERROR_CLEAR_CLEAR                                  = 0x00000000,
    CEN_EFF_CRC_ERROR_CLEAR_ERROR                                  = 0x00000001,
};

/**
 *  @brief C/A Parity Error Status. This is for DDR4 MRS5. Computed in
 *	mss_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum CEN_EFF_CA_PARITY_ERROR_STATUS
{
    CEN_EFF_CA_PARITY_ERROR_STATUS_CLEAR                           = 0x00000000,
    CEN_EFF_CA_PARITY_ERROR_STATUS_ERROR                           = 0x00000001,
};

/**
 *  @brief ODT Input Buffer during power down. This is for DDR4 MRS5.
 *	Computed in mss_eff_cnfg. Each memory channel will have a value.
 *	creator: mss_eff_cnfg consumer: various firmware notes: none
 */
enum CEN_EFF_ODT_INPUT_BUFF
{
    CEN_EFF_ODT_INPUT_BUFF_ACTIVATED                               = 0x00000000,
    CEN_EFF_ODT_INPUT_BUFF_DEACTIVATED                             = 0x00000001,
};

/**
 *  @brief CA Parity Persistance Error. This is for DDR4 MRS5. Computed in
 *	mss_eff_cnfg. Each memory channel will have a value. creator:
 *	mss_eff_cnfg consumer: various firmware notes: none
 */
enum CEN_EFF_CA_PARITY
{
    CEN_EFF_CA_PARITY_DISABLE                                      = 0x00000000,
    CEN_EFF_CA_PARITY_ENABLE                                       = 0x00000001,
};

/**
 *  @brief Data Mask. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each
 *	memory channel will have a value. creator: mss_eff_cnfg consumer:
 *	various firmware notes: none
 */
enum CEN_EFF_DATA_MASK
{
    CEN_EFF_DATA_MASK_DISABLE                                      = 0x00000000,
    CEN_EFF_DATA_MASK_ENABLE                                       = 0x00000001,
};

/**
 *  @brief Write DBI. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each
 *	memory channel will have a value. creator: mss_eff_cnfg consumer:
 *	various firmware notes: none
 */
enum CEN_EFF_WRITE_DBI
{
    CEN_EFF_WRITE_DBI_DISABLE                                      = 0x00000000,
    CEN_EFF_WRITE_DBI_ENABLE                                       = 0x00000001,
};

/**
 *  @brief Read DBI. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each
 *	memory channel will have a value. creator: mss_eff_cnfg consumer:
 *	various firmware notes: none
 */
enum CEN_EFF_READ_DBI
{
    CEN_EFF_READ_DBI_DISABLE                                       = 0x00000000,
    CEN_EFF_READ_DBI_ENABLE                                        = 0x00000001,
};

/**
 *  @brief vrefdq_train range. This is for DDR4 MRS6. Computed in
 *	mss_eff_cnfg. Each memory channel will have a value. Creator:
 *	mss_eff_cnfg Consumer:various Firmware notes: none
 */
enum CEN_EFF_VREF_DQ_TRAIN_RANGE
{
    CEN_EFF_VREF_DQ_TRAIN_RANGE_RANGE1                             = 0x00000000,
    CEN_EFF_VREF_DQ_TRAIN_RANGE_RANGE2                             = 0x00000001,
};

/**
 *  @brief vrefdq_train enable. This is for DDR4 MRS6. Computed in
 *	mss_eff_cnfg. Each memory channel will have a value. Creator:
 *	mss_eff_cnfg Consumer:various Firmware notes: none
 */
enum CEN_EFF_VREF_DQ_TRAIN_ENABLE
{
    CEN_EFF_VREF_DQ_TRAIN_ENABLE_DISABLE                           = 0x00000000,
    CEN_EFF_VREF_DQ_TRAIN_ENABLE_ENABLE                            = 0x00000001,
};

/**
 *  @brief tccd_l. This is for DDR4 MRS6. Computed in mss_eff_cnfg. Each
 *	memory channel will have a value. Creator: mss_eff_cnfg
 *	Consumer:various Firmware notes: none
 */
enum CEN_EFF_DRAM_TCCD_L
{
    CEN_EFF_DRAM_TCCD_L_4NCK                                       = 0x00000004,
    CEN_EFF_DRAM_TCCD_L_5NCK                                       = 0x00000005,
    CEN_EFF_DRAM_TCCD_L_6NCK                                       = 0x00000006,
    CEN_EFF_DRAM_TCCD_L_7NCK                                       = 0x00000007,
    CEN_EFF_DRAM_TCCD_L_8NCK                                       = 0x00000008,
};

/**
 *  @brief tccd_l. This is for DDR4 MRS6. Computed in mss_eff_cnfg. Each
 *	memory channel will have a value. Creator: mss_eff_cnfg
 *	Consumer:various Firmware notes: none
 */
enum CEN_TCCD_L
{
    CEN_TCCD_L_4NCK                                                = 0x00000004,
    CEN_TCCD_L_5NCK                                                = 0x00000005,
    CEN_TCCD_L_6NCK                                                = 0x00000006,
    CEN_TCCD_L_7NCK                                                = 0x00000007,
    CEN_TCCD_L_8NCK                                                = 0x00000008,
};

/**
 *  @brief Write CRC control for DDR4 in MRS2. Set in mss_eff_cnfg. Each
 *	memory channel will have a value. Creator: mss_eff_cnfg
 *	Consumer:various Firmware notes: none
 */
enum CEN_EFF_WRITE_CRC
{
    CEN_EFF_WRITE_CRC_DISABLE                                      = 0x00000000,
    CEN_EFF_WRITE_CRC_ENABLE                                       = 0x00000001,
};

/**
 *  @brief A disable switch for resetting the phy delay values at the
 *	beginning of calling mss_draminit_training.
 */
enum CEN_MSS_DRAMINIT_RESET_DISABLE
{
    CEN_MSS_DRAMINIT_RESET_DISABLE_DISABLE                         = 0x00000001,
    CEN_MSS_DRAMINIT_RESET_DISABLE_ENABLE                          = 0x00000000,
};

/**
 *  @brief When this value is true, then mss_eff config will allow a single
 *	port to have one dimm and will allow ports to have different sizes.
 *	Used in eff_config
 */
enum CEN_MSS_ALLOW_SINGLE_PORT
{
    CEN_MSS_ALLOW_SINGLE_PORT_FALSE                                = 0x00000000,
    CEN_MSS_ALLOW_SINGLE_PORT_TRUE                                 = 0x00000001,
};

/**
 *  @brief DQS Swizzle type is set by the platform to describe what kind of
 *	DQS connection is being used for register acceses. Type 0 is
 *	normal, type 1 is for systems with wiring like glacier 1, type 2 is
 *	for Pallmeto. Additional types maybe defined if new boards have
 *	even different DQS swizzle features
 */
enum CEN_MSS_DQS_SWIZZLE_TYPE
{
    CEN_MSS_DQS_SWIZZLE_TYPE_NORMAL_TYPE_0                         = 0x00000000,
    CEN_MSS_DQS_SWIZZLE_TYPE_GLACIER_TYPE_1                        = 0x00000001,
    CEN_MSS_DQS_SWIZZLE_TYPE_ISDIMM_TYPE_2                         = 0x00000002,
};

/**
 *  @brief Set by the platform depending on DD1 vs DD1.01. If true, then SI
 *	settings affected by the NWELL problem are adjusted. Used in
 *	eff_config
 */
enum CEN_MSS_NWELL_MISPLACEMENT
{
    CEN_MSS_NWELL_MISPLACEMENT_FALSE                               = 0x00000000,
    CEN_MSS_NWELL_MISPLACEMENT_TRUE                                = 0x00000001,
};

/**
 *  @brief Set by the platform depending on DD1.0X vs DD1.03 or newer. If
 *	true, then draminit_train will modify dqs_clk_ps and gate to work
 *	around the issue. Set in get ecid which determines if we are at
 *	1.03
 */
enum CEN_MSS_BLUEWATERFALL_BROKEN
{
    CEN_MSS_BLUEWATERFALL_BROKEN_FALSE                             = 0x00000000,
    CEN_MSS_BLUEWATERFALL_BROKEN_TRUE                              = 0x00000001,
};

/**
 *  @brief LRDIMM rank multiplication mode. Will be set at an MBA level
 *	with one policy to be used
 */
enum CEN_LRDIMM_RANK_MULT_MODE
{
    CEN_LRDIMM_RANK_MULT_MODE_NORMAL                               = 0x00000000,
    CEN_LRDIMM_RANK_MULT_MODE_2X_MULT                              = 0x00000002,
    CEN_LRDIMM_RANK_MULT_MODE_4X_MULT                              = 0x00000004,
};

/**
 *  @brief How far into the ipl istep the centaur has been brought up
 */
enum CEN_MSS_INIT_STATE
{
    CEN_MSS_INIT_STATE_COLD                                        = 0x00000000,
    CEN_MSS_INIT_STATE_CLOCKS_ON                                   = 0x00000001,
    CEN_MSS_INIT_STATE_DMI_ACTIVE                                  = 0x00000002,
};

/**
 *  @brief The NEST frequencies the memory chip can run at computed by the
 *	mss_freq. The possibilities are ORed together. The platform uses
 *	these value and the MRW to determine what frequency to boot the
 *	fabric (nest) if it can. There are two values: 8G and 9.6G
 */
enum CEN_MSS_NEST_CAPABLE_FREQUENCIES
{
    CEN_MSS_NEST_CAPABLE_FREQUENCIES_NONE                          = 0x00000000,
    CEN_MSS_NEST_CAPABLE_FREQUENCIES_8_0G                          = 0x00000001,
    CEN_MSS_NEST_CAPABLE_FREQUENCIES_9_6G                          = 0x00000002,
    CEN_MSS_NEST_CAPABLE_FREQUENCIES_8_0G_OR_9_6G                  = 0x00000003,
};

/**
 *  @brief The MRW for a system should set this to TRUE for systems that
 *	must obey plug rules. Lab environments should default this to off
 *	and allow the user to override using normal methods to test.
 */
enum CEN_MRW_STRICT_MBA_PLUG_RULE_CHECKING
{
    CEN_MRW_STRICT_MBA_PLUG_RULE_CHECKING_FALSE                    = 0x00000000,
    CEN_MRW_STRICT_MBA_PLUG_RULE_CHECKING_TRUE                     = 0x00000001,
};

/**
 *  @brief Used for Custom DIMMs to not enable the reading of the dimm
 *	temperature sensor on the master i2c bus
 */
enum CEN_MRW_CDIMM_MASTER_I2C_TEMP_SENSOR_ENABLE
{
    CEN_MRW_CDIMM_MASTER_I2C_TEMP_SENSOR_ENABLE_OFF                = 0x00000000,
    CEN_MRW_CDIMM_MASTER_I2C_TEMP_SENSOR_ENABLE_ON                 = 0x00000001,
};

/**
 *  @brief Used for Custom DIMMs to not enable the reading of the dimm
 *	temperature sensor on the spare i2c bus
 */
enum CEN_MRW_CDIMM_SPARE_I2C_TEMP_SENSOR_ENABLE
{
    CEN_MRW_CDIMM_SPARE_I2C_TEMP_SENSOR_ENABLE_OFF                 = 0x00000000,
    CEN_MRW_CDIMM_SPARE_I2C_TEMP_SENSOR_ENABLE_ON                  = 0x00000001,
};

/**
 *  @brief Possible DRAM voltage override.
 */
enum CEN_MSS_VOLT_OVERRIDE
{
    CEN_MSS_VOLT_OVERRIDE_NONE                                     = 0x00000000,
    CEN_MSS_VOLT_OVERRIDE_VOLT_135                                 = 0x00000001,
    CEN_MSS_VOLT_OVERRIDE_VOLT_120                                 = 0x00000002,
};

/**
 *  @brief List of Voltages that are compliant with the system. DIMMs that
 *	do not have voltages listed in their SPD as supported are errored
 *	out. Procedure defined is currently 1.2V and 1.35V only.
 */
enum CEN_MSS_VOLT_COMPLIANT_DIMMS
{
    CEN_MSS_VOLT_COMPLIANT_DIMMS_PROCEDURE_DEFINED                 = 0x00000000,
    CEN_MSS_VOLT_COMPLIANT_DIMMS_ALL_VOLTAGES                      = 0x00000001,
};

/**
 *  @brief Capable power control settings. In MRW.
 */
enum CEN_MRW_POWER_CONTROL_REQUESTED
{
    CEN_MRW_POWER_CONTROL_REQUESTED_OFF                            = 0x00000000,
    CEN_MRW_POWER_CONTROL_REQUESTED_SLOWEXIT                       = 0x00000001,
    CEN_MRW_POWER_CONTROL_REQUESTED_FASTEXIT                       = 0x00000002,
};

/**
 *  @brief Machine Readable Workbook enablement of the HWP code to adjust
 *	the VMEM regulator power limit based on number of installed DIMMs.
 */
enum CEN_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE
{
    CEN_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE_FALSE   = 0x00000000,
    CEN_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE_TRUE    = 0x00000001,
};

/**
 *  @brief Enumeration indicating the target's class
 */
enum CLASS
{
    CLASS_NA                                                       = 0x00000000,
    CLASS_CARD                                                     = 0x00000001,
    CLASS_ENC                                                      = 0x00000002,
    CLASS_CHIP                                                     = 0x00000003,
    CLASS_UNIT                                                     = 0x00000004,
    CLASS_DEV                                                      = 0x00000005,
    CLASS_SYS                                                      = 0x00000006,
    CLASS_LOGICAL_CARD                                             = 0x00000007,
    CLASS_BATTERY                                                  = 0x00000008,
    CLASS_LED                                                      = 0x00000009,
    CLASS_SP                                                       = 0x0000000A,
    CLASS_MAX                                                      = 0x0000000B,
};

/**
 *  @brief Enumeration indicating the target's type
 */
enum TYPE
{
    TYPE_NA                                                        = 0x00000000,
    TYPE_SYS                                                       = 0x00000001,
    TYPE_NODE                                                      = 0x00000002,
    TYPE_DIMM                                                      = 0x00000003,
    TYPE_MEMBUF                                                    = 0x00000004,
    TYPE_PROC                                                      = 0x00000005,
    TYPE_EX                                                        = 0x00000006,
    TYPE_CORE                                                      = 0x00000007,
    TYPE_L2                                                        = 0x00000008,
    TYPE_L3                                                        = 0x00000009,
    TYPE_L4                                                        = 0x0000000A,
    TYPE_MCS                                                       = 0x0000000B,
    TYPE_MBA                                                       = 0x0000000D,
    TYPE_XBUS                                                      = 0x0000000E,
    TYPE_ABUS                                                      = 0x0000000F,
    TYPE_PCI                                                       = 0x00000010,
    TYPE_DPSS                                                      = 0x00000011,
    TYPE_APSS                                                      = 0x00000012,
    TYPE_OCC                                                       = 0x00000013,
    TYPE_PSI                                                       = 0x00000014,
    TYPE_FSP                                                       = 0x00000015,
    TYPE_PNOR                                                      = 0x00000016,
    TYPE_OSC                                                       = 0x00000017,
    TYPE_TODCLK                                                    = 0x00000018,
    TYPE_CONTROL_NODE                                              = 0x00000019,
    TYPE_OSCREFCLK                                                 = 0x0000001A,
    TYPE_OSCPCICLK                                                 = 0x0000001B,
    TYPE_REFCLKENDPT                                               = 0x0000001C,
    TYPE_PCICLKENDPT                                               = 0x0000001D,
    TYPE_NX                                                        = 0x0000001E,
    TYPE_PORE                                                      = 0x0000001F,
    TYPE_PCIESWITCH                                                = 0x00000020,
    TYPE_CAPP                                                      = 0x00000021,
    TYPE_FSI                                                       = 0x00000022,
    TYPE_EQ                                                        = 0x00000023,
    TYPE_MCA                                                       = 0x00000024,
    TYPE_MCBIST                                                    = 0x00000025,
    TYPE_MI                                                        = 0x00000026,
    TYPE_DMI                                                       = 0x00000027,
    TYPE_OBUS                                                      = 0x00000028,
    TYPE_SBE                                                       = 0x0000002A,
    TYPE_PPE                                                       = 0x0000002B,
    TYPE_PERV                                                      = 0x0000002C,
    TYPE_PEC                                                       = 0x0000002D,
    TYPE_PHB                                                       = 0x0000002E,
    TYPE_SYSREFCLKENDPT                                            = 0x0000002F,
    TYPE_MFREFCLKENDPT                                             = 0x00000030,
    TYPE_TPM                                                       = 0x00000031,
    TYPE_SP                                                        = 0x00000032,
    TYPE_UART                                                      = 0x00000033,
    TYPE_PS                                                        = 0x00000034,
    TYPE_FAN                                                       = 0x00000035,
    TYPE_VRM                                                       = 0x00000036,
    TYPE_USB                                                       = 0x00000037,
    TYPE_ETH                                                       = 0x00000038,
    TYPE_PANEL                                                     = 0x00000039,
    TYPE_BMC                                                       = 0x0000003A,
    TYPE_FLASH                                                     = 0x0000003B,
    TYPE_SEEPROM                                                   = 0x0000003C,
    TYPE_TMP                                                       = 0x0000003D,
    TYPE_GPIO_EXPANDER                                             = 0x0000003E,
    TYPE_POWER_SEQUENCER                                           = 0x0000003F,
    TYPE_RTC                                                       = 0x00000040,
    TYPE_FANCTLR                                                   = 0x00000041,
    TYPE_OBUS_BRICK                                                = 0x00000042,
    TYPE_NPU                                                       = 0x00000043,
    TYPE_MC                                                        = 0x00000044,
    TYPE_TEST_FAIL                                                 = 0x00000045,
    TYPE_MFREFCLK                                                  = 0x00000046,
    TYPE_LAST_IN_RANGE                                             = 0x00000047,
};

/**
 *  @brief Enumeration indicating the target's model
 */
enum MODEL
{
    MODEL_NA                                                       = 0x00000000,
    MODEL_RESERVED                                                 = 0x00000010,
    MODEL_VENICE                                                   = 0x00000011,
    MODEL_MURANO                                                   = 0x00000012,
    MODEL_NAPLES                                                   = 0x00000013,
    MODEL_NIMBUS                                                   = 0x00000014,
    MODEL_CUMULUS                                                  = 0x00000015,
    MODEL_CENTAUR                                                  = 0x00000030,
    MODEL_JEDEC                                                    = 0x00000050,
    MODEL_CDIMM                                                    = 0x00000051,
    MODEL_POWER8                                                   = 0x00000070,
    MODEL_POWER9                                                   = 0x00000090,
    MODEL_CECTPM                                                   = 0x00000091,
    MODEL_BMC                                                      = 0x00000092,
    MODEL_AST2500                                                  = 0x00000093,
};

/**
 *  @brief Enumeration indicating the target's engine type
 */
enum ENGINE_TYPE
{
    ENGINE_TYPE_NA                                                 = 0x00000000,
    ENGINE_TYPE_ENGINE_IIC                                         = 0x00000001,
    ENGINE_TYPE_ENGINE_SCOM                                        = 0x00000002,
};

/**
 *  @brief Enumeration indicating the master's FSI type
 */
enum FSI_MASTER_TYPE
{
    FSI_MASTER_TYPE_MFSI                                           = 0x00000000,
    FSI_MASTER_TYPE_CMFSI                                          = 0x00000001,
    FSI_MASTER_TYPE_NO_MASTER                                      = 0x00000002,
};

/**
 *  @brief Enumeration indicating the services that are concerned with
 *	target changes (ie, via HCDB change). The values can be combined
 *	using a bitwise 'OR'.
 */
enum HWAS_CHANGED_BIT
{
    HWAS_CHANGED_BIT_GARD                                          = 0x00000001,
    HWAS_CHANGED_BIT_MEMDIAG                                       = 0x00000002,
    HWAS_CHANGED_BIT_PSIDIAG                                       = 0x00000004,
    HWAS_CHANGED_BIT_DIAG_MASK                                     = 0x00000006,
    HWAS_CHANGED_BIT_HOSTSVC_HBEL                                  = 0x00000008,
};

/**
 *  @brief Processor epsilon table type. Used to calculate the processor
 *	nest epsilon register values. Provided by the MRW.
 */
enum PROC_EPS_TABLE_TYPE
{
    PROC_EPS_TABLE_TYPE_EPS_TYPE_LE                                = 0x00000001,
    PROC_EPS_TABLE_TYPE_EPS_TYPE_HE                                = 0x00000002,
    PROC_EPS_TABLE_TYPE_EPS_TYPE_HE_F8                             = 0x00000003,
};

/**
 *  @brief Processor SMP Fabric broadcast scope configuration. CHIP_IS_NODE
 *	= MODE1 = default CHIP_IS_GROUP = MODE2 Provided by the MRW.
 */
enum PROC_FABRIC_PUMP_MODE
{
    PROC_FABRIC_PUMP_MODE_CHIP_IS_NODE                             = 0x00000001,
    PROC_FABRIC_PUMP_MODE_CHIP_IS_GROUP                            = 0x00000002,
};

/**
 *  @brief Enumeration indicating what kind of payload is to be started
 */
enum PAYLOAD_KIND
{
    PAYLOAD_KIND_UNKNOWN                                           = 0x00000000,
    PAYLOAD_KIND_PHYP                                              = 0x00000001,
    PAYLOAD_KIND_SAPPHIRE                                          = 0x00000002,
    PAYLOAD_KIND_NONE                                              = 0x00000003,
};

/**
 *  @brief Enumeration indicating the mnfg flags that are set by the user.
 *	The values can be combined using a bitwise 'OR'. The values will
 *	need to be kept in sync with the FAPI enumerator values. Also the
 *	enumeration type is used by the ATTR_MNFG_FLAGS attribute. Should
 *	note that the MNFG_FLAG values are of type uint32_t
 */
enum MNFG_FLAG
{
    MNFG_FLAG_THRESHOLDS                                           = 0x00000001,
    MNFG_FLAG_AVP_ENABLE                                           = 0x00000002,
    MNFG_FLAG_HDAT_AVP_ENABLE                                      = 0x00000004,
    MNFG_FLAG_SRC_TERM                                             = 0x00000008,
    MNFG_FLAG_IPL_MEMORY_CE_CHECKING                               = 0x00000010,
    MNFG_FLAG_FAST_BACKGROUND_SCRUB                                = 0x00000020,
    MNFG_FLAG_TEST_DRAM_REPAIRS                                    = 0x00000040,
    MNFG_FLAG_DISABLE_DRAM_REPAIRS                                 = 0x00000080,
    MNFG_FLAG_ENABLE_EXHAUSTIVE_PATTERN_TEST                       = 0x00000100,
    MNFG_FLAG_ENABLE_STANDARD_PATTERN_TEST                         = 0x00000200,
    MNFG_FLAG_ENABLE_MINIMUM_PATTERN_TEST                          = 0x00000400,
    MNFG_FLAG_DISABLE_FABRIC_eREPAIR                               = 0x00000800,
    MNFG_FLAG_DISABLE_MEMORY_eREPAIR                               = 0x00001000,
    MNFG_FLAG_FABRIC_DEPLOY_LANE_SPARES                            = 0x00002000,
    MNFG_FLAG_DMI_DEPLOY_LANE_SPARES                               = 0x00004000,
    MNFG_FLAG_PSI_DIAGNOSTIC                                       = 0x00008000,
    MNFG_FLAG_BRAZOS_WRAP_CONFIG                                   = 0x00010000,
    MNFG_FLAG_FSP_UPDATE_SBE_IMAGE                                 = 0x00020000,
    MNFG_FLAG_UPDATE_BOTH_SIDES_OF_SBE                             = 0x00040000,
};

/**
 *  @brief Enumeration indicating the BAR size used with
 *	ATTR_PROC_NPU_MMIO_BAR_SIZE
 */
enum NPU_MMIO_BAR_SIZE
{
    NPU_MMIO_BAR_SIZE_2_MB                                         = 0x00200000,
    NPU_MMIO_BAR_SIZE_1_MB                                         = 0x00100000,
    NPU_MMIO_BAR_SIZE_512_KB                                       = 0x00080000,
    NPU_MMIO_BAR_SIZE_256_KB                                       = 0x00040000,
    NPU_MMIO_BAR_SIZE_128_KB                                       = 0x00020000,
    NPU_MMIO_BAR_SIZE_64_KB                                        = 0x00010000,
};

/**
 *  @brief Enumeration indicating which chip should be used as the
 *	PROC_SELECT_BOOT_MASTER
 */
enum PROC_SELECT_BOOT_MASTER
{
    PROC_SELECT_BOOT_MASTER_PRIMARY                                = 0x00000001,
    PROC_SELECT_BOOT_MASTER_SECONDARY                              = 0x00000002,
};

/**
 *  @brief Enumeration indicating which SEEPROM image should be used for
 *	the boot master
 */
enum PROC_SELECT_SEEPROM_IMAGE
{
    PROC_SELECT_SEEPROM_IMAGE_FIRST                                = 0x00000001,
    PROC_SELECT_SEEPROM_IMAGE_SECOND                               = 0x00000002,
};

/**
 *  @brief Enumeration indicating which SEEPROM image should be used to
 *	boot a processor
 */
enum PROC_SELECT_BOOT_SEEPROM_IMAGE
{
    PROC_SELECT_BOOT_SEEPROM_IMAGE_FIRST                           = 0x00000001,
    PROC_SELECT_BOOT_SEEPROM_IMAGE_SECOND                          = 0x00000002,
};

/**
 *  @brief Enumeration indicating which _PBIEX_ASYNC_SEL should be use
 */
enum PROC_PBIEX_ASYNC_SEL
{
    PROC_PBIEX_ASYNC_SEL_SEL0                                      = 0x00000000,
    PROC_PBIEX_ASYNC_SEL_SEL1                                      = 0x00000001,
    PROC_PBIEX_ASYNC_SEL_SEL2                                      = 0x00000002,
};

/**
 *  @brief Enumeration of CDM_POLICIES flags
 */
enum CDM_POLICIES
{
    CDM_POLICIES_MANUFACTURING_DISABLED                            = 0x00000001,
    CDM_POLICIES_PREDICTIVE_DISABLED                               = 0x00000002,
};

/**
 *  @brief Enumeration indicating the multi scome buffer size. The values
 *	can be combined using a bitwise 'OR'. The values will need to be
 *	kept in sync with the FAPI enumerator values. Also the enumeration
 *	type is used by the ATTR_MULTI_SCOM_BUFFER_MAX_SIZE. Should note
 *	that the MULTI_SCOM_BUFFER_MAX_SIZE values are of type uint32_t
 */
enum MULTI_SCOM_BUFFER_MAX_SIZE_BIT
{
    MULTI_SCOM_BUFFER_MAX_SIZE_BIT_MULTI_SCOM_BUFFER_SIZE_1KB      = 0x00000400,
    MULTI_SCOM_BUFFER_MAX_SIZE_BIT_MULTI_SCOM_BUFFER_SIZE_2KB      = 0x00000800,
    MULTI_SCOM_BUFFER_MAX_SIZE_BIT_MULTI_SCOM_BUFFER_SIZE_4KB      = 0x00001000,
    MULTI_SCOM_BUFFER_MAX_SIZE_BIT_MULTI_SCOM_BUFFER_SIZE_8KB      = 0x00002000,
    MULTI_SCOM_BUFFER_MAX_SIZE_BIT_MULTI_SCOM_BUFFER_SIZE_16KB     = 0x00004000,
    MULTI_SCOM_BUFFER_MAX_SIZE_BIT_MULTI_SCOM_BUFFER_SIZE_32KB     = 0x00008000,
    MULTI_SCOM_BUFFER_MAX_SIZE_BIT_MULTI_SCOM_BUFFER_SIZE_64KB     = 0x00010000,
    MULTI_SCOM_BUFFER_MAX_SIZE_BIT_MULTI_SCOM_BUFFER_SIZE_128KB    = 0x00020000,
    MULTI_SCOM_BUFFER_MAX_SIZE_BIT_MULTI_SCOM_BUFFER_SIZE_256KB    = 0x00040000,
    MULTI_SCOM_BUFFER_MAX_SIZE_BIT_MULTI_SCOM_BUFFER_SIZE_512KB    = 0x00080000,
    MULTI_SCOM_BUFFER_MAX_SIZE_BIT_MULTI_SCOM_BUFFER_SIZE_1MB      = 0x00100000,
};

/**
 *  @brief Enumeration indicating the role of proc as
 *	master/alt_master/not_master
 */
enum PROC_MASTER_TYPE
{
    PROC_MASTER_TYPE_ACTING_MASTER                                 = 0x00000000,
    PROC_MASTER_TYPE_MASTER_CANDIDATE                              = 0x00000001,
    PROC_MASTER_TYPE_NOT_MASTER                                    = 0x00000002,
};

/**
 *  @brief Used to inidicate if a reconfigure loop is needed
 */
enum RECONFIGURE_LOOP
{
    RECONFIGURE_LOOP_DECONFIGURE                                   = 0x00000001,
    RECONFIGURE_LOOP_BAD_DQ_BIT_SET                                = 0x00000002,
    RECONFIGURE_LOOP_RCD_PARITY_ERROR                              = 0x00000004,
};

/**
 *  @brief Enumeration indicating what role this chip has in tod topology
 */
enum TOD_ROLE
{
    TOD_ROLE_NON_MASTER                                            = 0x00000000,
    TOD_ROLE_PRIMARY                                               = 0x00000001,
    TOD_ROLE_SECONDARY                                             = 0x00000002,
};

/**
 *  @brief Memory power control settings programmed during IPL Used by OCC
 *	when exiting idle power-save mode
 */
enum MSS_MRW_POWER_CONTROL_REQUESTED
{
    MSS_MRW_POWER_CONTROL_REQUESTED_OFF                            = 0x00000000,
    MSS_MRW_POWER_CONTROL_REQUESTED_POWER_DOWN                     = 0x00000001,
    MSS_MRW_POWER_CONTROL_REQUESTED_PD_AND_STR                     = 0x00000002,
    MSS_MRW_POWER_CONTROL_REQUESTED_PD_AND_STR_CLK_STOP            = 0x00000003,
};

/**
 *  @brief Memory power control settings for IDLE powersave mode Used by
 *	OCC when entering idle power-save mode
 */
enum MSS_MRW_IDLE_POWER_CONTROL_REQUESTED
{
    MSS_MRW_IDLE_POWER_CONTROL_REQUESTED_OFF                       = 0x00000000,
    MSS_MRW_IDLE_POWER_CONTROL_REQUESTED_POWER_DOWN                = 0x00000001,
    MSS_MRW_IDLE_POWER_CONTROL_REQUESTED_PD_AND_STR                = 0x00000002,
    MSS_MRW_IDLE_POWER_CONTROL_REQUESTED_PD_AND_STR_CLK_STOP       = 0x00000003,
};

/**
 *  @brief Enumeration specifying a target's CEC degraded mode domain
 */
enum CDM_DOMAIN
{
    CDM_DOMAIN_NONE                                                = 0x00000000,
    CDM_DOMAIN_CPU                                                 = 0x00000001,
    CDM_DOMAIN_DIMM                                                = 0x00000002,
    CDM_DOMAIN_FABRIC                                              = 0x00000003,
    CDM_DOMAIN_MEM                                                 = 0x00000004,
    CDM_DOMAIN_IO                                                  = 0x00000005,
    CDM_DOMAIN_NODE                                                = 0x00000006,
    CDM_DOMAIN_CLOCK                                               = 0x00000007,
    CDM_DOMAIN_PSI                                                 = 0x00000008,
    CDM_DOMAIN_FSP                                                 = 0x00000009,
    CDM_DOMAIN_ALL                                                 = 0x0000000A,
};

/**
 *  @brief Enumeration indication which Hot Plug Controllers are supported
 *	by the current system.
 */
enum SUPPORTED_HOT_PLUG
{
    SUPPORTED_HOT_PLUG_NA                                          = 0x00000000,
    SUPPORTED_HOT_PLUG_MAX5961                                     = 0x00000001,
    SUPPORTED_HOT_PLUG_PCA9551                                     = 0x00000002,
};

/**
 *  @brief Enum for FUSED_CORE_OPTION
 */
enum FUSED_CORE_OPTION
{
    FUSED_CORE_OPTION_USING_DEFAULT_CORES                          = 0x00000000,
    FUSED_CORE_OPTION_USING_NORMAL_CORES                           = 0x00000001,
    FUSED_CORE_OPTION_USING_FUSED_CORES                            = 0x00000002,
};

/**
 *  @brief Defines which of the PSS chip selects (0 or 1) that the APSS is
 *	connected Provided by the Machine Readable Workbook. Consumer:
 *	p9_pm_pss_init
 */
enum PM_APSS_CHIP_SELECT
{
    PM_APSS_CHIP_SELECT_NONE                                       = 0x000000FF,
    PM_APSS_CHIP_SELECT_CS0                                        = 0x00000000,
    PM_APSS_CHIP_SELECT_CS1                                        = 0x00000001,
};

/**
 *  @brief Enumeration to select WOF Power Limit
 */
enum WOF_POWER_LIMIT
{
    WOF_POWER_LIMIT_NOMINAL                                        = 0x00000000,
    WOF_POWER_LIMIT_TURBO                                          = 0x00000001,
};

/**
 *  @brief Enumeration indicating the OFF setting for the core and cache
 *	chiplet DD PFET controllers
 */
enum PFET_VDD_VOFF_SEL
{
    PFET_VDD_VOFF_SEL_NOOFF                                        = 0x00000000,
    PFET_VDD_VOFF_SEL_ALLBUT1TO7OFF                                = 0x00000001,
    PFET_VDD_VOFF_SEL_ALLBUT2TO7OFF                                = 0x00000002,
    PFET_VDD_VOFF_SEL_ALLBUT3TO7OFF                                = 0x00000003,
    PFET_VDD_VOFF_SEL_ALLBUT4TO7OFF                                = 0x00000004,
    PFET_VDD_VOFF_SEL_ALLBUT5TO7OFF                                = 0x00000005,
    PFET_VDD_VOFF_SEL_ALLBUT6TO7OFF                                = 0x00000006,
    PFET_VDD_VOFF_SEL_ALLBUT7TO7OFF                                = 0x00000007,
    PFET_VDD_VOFF_SEL_ALLOFF                                       = 0x00000008,
};

/**
 *  @brief Enumeration indicating the OFF setting for the core and cache
 *	chiplet VCS PFET controllers
 */
enum PFET_VCS_VOFF_SEL
{
    PFET_VCS_VOFF_SEL_NOOFF                                        = 0x00000000,
    PFET_VCS_VOFF_SEL_ALLBUT1TO7OFF                                = 0x00000001,
    PFET_VCS_VOFF_SEL_ALLBUT2TO7OFF                                = 0x00000002,
    PFET_VCS_VOFF_SEL_ALLBUT3TO7OFF                                = 0x00000003,
    PFET_VCS_VOFF_SEL_ALLBUT4TO7OFF                                = 0x00000004,
    PFET_VCS_VOFF_SEL_ALLBUT5TO7OFF                                = 0x00000005,
    PFET_VCS_VOFF_SEL_ALLBUT6TO7OFF                                = 0x00000006,
    PFET_VCS_VOFF_SEL_ALLBUT7TO7OFF                                = 0x00000007,
    PFET_VCS_VOFF_SEL_ALLOFF                                       = 0x00000008,
};

/**
 *  @brief Enumeration defining special FAPI_POS values
 */
enum FAPI_POS
{
    FAPI_POS_NA                                                    = 0xFFFFFFFF,
};

/**
 *  @brief Processor SMP A bus width. Provided by the MRW.
 */
enum PROC_FABRIC_A_BUS_WIDTH
{
    PROC_FABRIC_A_BUS_WIDTH_2_BYTE                                 = 0x00000001,
    PROC_FABRIC_A_BUS_WIDTH_4_BYTE                                 = 0x00000002,
};

/**
 *  @brief Processor SMP X bus width. Provided by the MRW.
 */
enum PROC_FABRIC_X_BUS_WIDTH
{
    PROC_FABRIC_X_BUS_WIDTH_2_BYTE                                 = 0x00000001,
    PROC_FABRIC_X_BUS_WIDTH_4_BYTE                                 = 0x00000002,
};

/**
 *  @brief Processor SMP optics mode. 0 = default = Optics_is_X_bus 1 =
 *	Optics_is_A_bus Provided by the MRW.
 */
enum PROC_FABRIC_SMP_OPTICS_MODE
{
    PROC_FABRIC_SMP_OPTICS_MODE_OPTICS_IS_X_BUS                    = 0x00000000,
    PROC_FABRIC_SMP_OPTICS_MODE_OPTICS_IS_A_BUS                    = 0x00000001,
};

/**
 *  @brief Processor CAPI attachement protocol mode. 0 = default = no: SMPA
 *	CAPI attachement 1 = yes: SMPA CAPI attachement Provided by the
 *	MRW.
 */
enum PROC_FABRIC_CAPI_MODE
{
    PROC_FABRIC_CAPI_MODE_OFF                                      = 0x00000000,
    PROC_FABRIC_CAPI_MODE_ON                                       = 0x00000001,
};

/**
 *  @brief Enumeration for Voltage Drop Monitor enable
 */
enum VDM_ENABLE
{
    VDM_ENABLE_OFF                                                 = 0x00000000,
    VDM_ENABLE_ON                                                  = 0x00000001,
};

/**
 *  @brief Used in MR4 A3 Temperature refresh mode Should be defaulted to
 *	disable
 */
enum MSS_MRW_TEMP_REFRESH_MODE
{
    MSS_MRW_TEMP_REFRESH_MODE_DISABLE                              = 0x00000000,
    MSS_MRW_TEMP_REFRESH_MODE_ENABLE                               = 0x00000001,
};

/**
 *  @brief Pulled from the MRW, this describes the device type to the HDAT.
 *	This is for I2C devices only.
 */
enum HDAT_I2C_DEVICE_TYPE
{
    HDAT_I2C_DEVICE_TYPE_9551                                      = 0x00000001,
    HDAT_I2C_DEVICE_TYPE_955X                                      = 0x00000001,
    HDAT_I2C_DEVICE_TYPE_SEEPROM                                   = 0x00000002,
    HDAT_I2C_DEVICE_TYPE_SEEPROM_Atmel28c128                       = 0x00000002,
    HDAT_I2C_DEVICE_TYPE_NUVOTON_TPM                               = 0x00000003,
    HDAT_I2C_DEVICE_TYPE_MEX_FPGA                                  = 0x00000004,
    HDAT_I2C_DEVICE_TYPE_UCX90XX                                   = 0x00000005,
    HDAT_I2C_DEVICE_TYPE_NVLINK                                    = 0x00000006,
    HDAT_I2C_DEVICE_TYPE_9552                                      = 0x00000006,
    HDAT_I2C_DEVICE_TYPE_9553                                      = 0x00000007,
    HDAT_I2C_DEVICE_TYPE_9554                                      = 0x00000008,
    HDAT_I2C_DEVICE_TYPE_9555                                      = 0x00000009,
    HDAT_I2C_DEVICE_TYPE_SMP_or_OpenCAPI_Cable                     = 0x0000000A,
    HDAT_I2C_DEVICE_TYPE_SEEPROM_Atmel28c256                       = 0x0000000B,
    HDAT_I2C_DEVICE_TYPE_UNKNOWN                                   = 0x000000FF,
};

/**
 *  @brief Pulled from the MRW, this describes the device purpose to the
 *	HDAT. This is for I2C devices only.
 */
enum HDAT_I2C_DEVICE_PURPOSE
{
    HDAT_I2C_DEVICE_PURPOSE_CABLE_CARD_PRES                        = 0x00000001,
    HDAT_I2C_DEVICE_PURPOSE_PCI_HOTPLUG_PGOOD                      = 0x00000002,
    HDAT_I2C_DEVICE_PURPOSE_PCI_HOTPLUG_CONTROL                    = 0x00000003,
    HDAT_I2C_DEVICE_PURPOSE_TPM                                    = 0x00000004,
    HDAT_I2C_DEVICE_PURPOSE_MODULE_VPD                             = 0x00000005,
    HDAT_I2C_DEVICE_PURPOSE_DIMM_SPD                               = 0x00000006,
    HDAT_I2C_DEVICE_PURPOSE_PROC_MODULE_VPD                        = 0x00000007,
    HDAT_I2C_DEVICE_PURPOSE_SBE_SEEPROM                            = 0x00000008,
    HDAT_I2C_DEVICE_PURPOSE_PLANAR_VPD                             = 0x00000009,
    HDAT_I2C_DEVICE_PURPOSE_NVLINK_CABLE_TOPOLOGY_VERIFICATION     = 0x0000000A,
    HDAT_I2C_DEVICE_PURPOSE_NVLINK                                 = 0x0000000B,
    HDAT_I2C_DEVICE_PURPOSE_NVLINK_CABLE_MICRO_RESET               = 0x0000000B,
    HDAT_I2C_DEVICE_PURPOSE_I2C_ASSOC_WITH_NVLINK_CABLE            = 0x0000000C,
    HDAT_I2C_DEVICE_PURPOSE_WINDOW_OPEN                            = 0x0000000D,
    HDAT_I2C_DEVICE_PURPOSE_PHYSICAL_PRESENCE                      = 0x0000000E,
    HDAT_I2C_DEVICE_PURPOSE_MEX_FPGA                               = 0x0000000F,
    HDAT_I2C_DEVICE_PURPOSE_UNKNOWN                                = 0x000000FF,
};

/**
 *  @brief Enum for FUSED_CORE_MODE_HB
 */
enum FUSED_CORE_MODE_HB
{
    FUSED_CORE_MODE_HB_SMT4_DEFAULT                                = 0x00000000,
    FUSED_CORE_MODE_HB_SMT4_ONLY                                   = 0x00000001,
    FUSED_CORE_MODE_HB_SMT8_ONLY                                   = 0x00000002,
};

/**
 *  @brief Enumeration of HIDDEN_ERRLOGS_ENABLE
 */
enum HIDDEN_ERRLOGS_ENABLE
{
    HIDDEN_ERRLOGS_ENABLE_NO_HIDDEN_LOGS                           = 0x00000000,
    HIDDEN_ERRLOGS_ENABLE_ALLOW_INFORMATIONAL                      = 0x00000001,
    HIDDEN_ERRLOGS_ENABLE_ALLOW_RECOVERED                          = 0x00000002,
    HIDDEN_ERRLOGS_ENABLE_ALLOW_ALL_LOGS                           = 0x00000003,
};

/**
 *  @brief Enumeration defining the offsets into the IPMI_SENSORS array.
 */
enum IPMI_SENSOR_ARRAY
{
    IPMI_SENSOR_ARRAY_NAME_OFFSET                                  = 0x00000000,
    IPMI_SENSOR_ARRAY_NUMBER_OFFSET                                = 0x00000001,
};

/**
 *  @brief Enumeration indicating the IPMI sensor name, which will be used
 *	by hostboot when determining the sensor number to return. The
 *	sensor name consists of one byte of sensor type plus one byte of
 *	sub-type, to differentiate similar sensors under the same target.
 *	Our implementaion uses the IPMI defined entity ID as the sub-type.
 */
enum SENSOR_NAME
{
    SENSOR_NAME_PROC_TEMP                                          = 0x00000103,
    SENSOR_NAME_DIMM_TEMP                                          = 0x00000120,
    SENSOR_NAME_CORE_TEMP                                          = 0x000001D0,
    SENSOR_NAME_STATE                                              = 0x00000500,
    SENSOR_NAME_MEMBUF_TEMP                                        = 0x000001D1,
    SENSOR_NAME_GPU_TEMP                                           = 0x000001D8,
    SENSOR_NAME_GPU_MEM_TEMP                                       = 0x000001D9,
    SENSOR_NAME_GPU_STATE                                          = 0x000017D8,
    SENSOR_NAME_PROC_STATE                                         = 0x00000703,
    SENSOR_NAME_CORE_STATE                                         = 0x000007D0,
    SENSOR_NAME_DIMM_STATE                                         = 0x00000C20,
    SENSOR_NAME_MEMBUF_STATE                                       = 0x00000CD1,
    SENSOR_NAME_FW_BOOT_PROGRESS                                   = 0x00000F22,
    SENSOR_NAME_SYSTEM_EVENT                                       = 0x00001201,
    SENSOR_NAME_OS_BOOT                                            = 0x00001F23,
    SENSOR_NAME_HOST_STATUS                                        = 0x00002223,
    SENSOR_NAME_OCC_ACTIVE                                         = 0x000007D2,
    SENSOR_NAME_CORE_FREQ                                          = 0x0000C1D0,
    SENSOR_NAME_APSS_CHANNEL                                       = 0x0000C2D7,
    SENSOR_NAME_PCI_ACTIVE                                         = 0x0000C423,
    SENSOR_NAME_REBOOT_COUNT                                       = 0x0000C322,
    SENSOR_NAME_FAULT                                              = 0x0000C700,
    SENSOR_NAME_BACKPLANE_FAULT                                    = 0x0000C707,
    SENSOR_NAME_REF_CLOCK_FAULT                                    = 0x0000C7D4,
    SENSOR_NAME_PCI_CLOCK_FAULT                                    = 0x0000C7D5,
    SENSOR_NAME_TOD_CLOCK_FAULT                                    = 0x0000C7D6,
    SENSOR_NAME_APSS_FAULT                                         = 0x0000C7D7,
    SENSOR_NAME_DERATING_FACTOR                                    = 0x0000C815,
    SENSOR_NAME_REDUNDANT_PS_POLICY                                = 0x0000CA22,
    SENSOR_NAME_TPM_REQUIRED                                       = 0x0000CC03,
};

/**
 *  @brief Enumeration of possible roles a TPM can play within a node. A
 *	TPM has the primary role if it's connected to the acting master
 *	processor, otherwise it has the backup role.
 */
enum TPM_ROLE
{
    TPM_ROLE_TPM_PRIMARY                                           = 0x00000000,
    TPM_ROLE_TPM_BACKUP                                            = 0x00000001,
};

/**
 *  @brief Enumeration indicating the chip version
 */
enum CHIP_VER
{
    CHIP_VER_DD10                                                  = 0x00000010,
    CHIP_VER_DD11                                                  = 0x00000011,
    CHIP_VER_DD20                                                  = 0x00000020,
    CHIP_VER_DD21                                                  = 0x00000021,
};

/**
 *  @brief Enumeration indicating the chip HW version
 */
enum HW_VER
{
    HW_VER_FSP_HW_VER                                              = 0x00000002,
    HW_VER_BMC_HW_VER                                              = 0x00000003,
};

/**
 *  @brief Enumeration indicating the SW version
 */
enum SW_VER
{
    SW_VER_FSP_SW_VER                                              = 0x00000001,
    SW_VER_BMC_SW_VER                                              = 0x00000002,
};

/**
 *  @brief Enumeration indicating the master's FSI type
 */
enum ROLE
{
    ROLE_PRIMARY                                                   = 0x00000001,
    ROLE_BACKUP                                                    = 0x00000000,
};

/**
 *  @brief Enumeration defining the offsets into the GPU_SENSORS array.
 */
enum GPU_SENSOR_ARRAY
{
    GPU_SENSOR_ARRAY_FUNC_OFFSET                                   = 0x00000000,
    GPU_SENSOR_ARRAY_FUNC_ID_OFFSET                                = 0x00000001,
    GPU_SENSOR_ARRAY_TEMP_OFFSET                                   = 0x00000002,
    GPU_SENSOR_ARRAY_TEMP_ID_OFFSET                                = 0x00000003,
    GPU_SENSOR_ARRAY_MEM_TEMP_OFFSET                               = 0x00000004,
    GPU_SENSOR_ARRAY_MEM_TEMP_ID_OFFSET                            = 0x00000005,
    GPU_SENSOR_ARRAY_OBUS_CFG_OFFSET                               = 0x00000006,
};

/**
 *  @brief Enumeration indicating the IPMI entity ID, these values are
 *	defined in the IPMI specification. These values will be used in
 *	place of target type when events are sent to the BMC.
 */
enum ENTITY_ID
{
    ENTITY_ID_NA                                                   = 0x00000000,
    ENTITY_ID_OTHER                                                = 0x00000001,
    ENTITY_ID_PROCESSOR                                            = 0x00000003,
    ENTITY_ID_SYSTEM_BOARD                                         = 0x00000007,
    ENTITY_ID_POWER_MGMT                                           = 0x00000015,
    ENTITY_ID_CHASSIS                                              = 0x00000017,
    ENTITY_ID_MEMORY_DEVICE                                        = 0x00000020,
    ENTITY_ID_BIOS                                                 = 0x00000022,
    ENTITY_ID_OS                                                   = 0x00000023,
    ENTITY_ID_CORE                                                 = 0x000000D0,
    ENTITY_ID_MEMBUF                                               = 0x000000D1,
    ENTITY_ID_OCC                                                  = 0x000000D2,
    ENTITY_ID_REF_CLOCK                                            = 0x000000D4,
    ENTITY_ID_PCI_CLOCK                                            = 0x000000D5,
    ENTITY_ID_TOD_CLOCK                                            = 0x000000D6,
    ENTITY_ID_APSS                                                 = 0x000000D7,
    ENTITY_ID_GPU_CORE                                             = 0x000000D8,
    ENTITY_ID_GPU_MEMORY                                           = 0x000000D9,
};

/**
 *  @brief Enumeration indicating the IPMI sensor type, these values are
 *	defined in the IPMI specification. These values will be used when
 *	sending sensor reading events to the BMC.
 */
enum SENSOR_TYPE
{
    SENSOR_TYPE_NA                                                 = 0x00000000,
    SENSOR_TYPE_TEMPERATURE                                        = 0x00000001,
    SENSOR_TYPE_PROCESSOR                                          = 0x00000007,
    SENSOR_TYPE_MEMORY                                             = 0x0000000C,
    SENSOR_TYPE_SYS_FW_PROGRESS                                    = 0x0000000F,
    SENSOR_TYPE_SYS_EVENT                                          = 0x00000012,
    SENSOR_TYPE_ADDIN_CARD                                         = 0x00000017,
    SENSOR_TYPE_OS_BOOT                                            = 0x0000001F,
    SENSOR_TYPE_APCI_POWER_STATE                                   = 0x00000022,
    SENSOR_TYPE_FREQ                                               = 0x000000C1,
    SENSOR_TYPE_POWER                                              = 0x000000C2,
    SENSOR_TYPE_BOOT_COUNT                                         = 0x000000C3,
    SENSOR_TYPE_PCI_LINK_PRES                                      = 0x000000C4,
    SENSOR_TYPE_PWR_LIMIT_ACTIVE                                   = 0x000000C4,
    SENSOR_TYPE_FAULT                                              = 0x000000C7,
};

} // End namespace TARGETING

#endif // TARG_ATTRIBUTEENUMS_H

