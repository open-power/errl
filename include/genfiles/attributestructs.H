
#ifndef TARG_ATTRIBUTESTRUCTS_H
#define TARG_ATTRIBUTESTRUCTS_H

/**
 *  @file attributestructs.H
 *
 *  @brief Complex structures for host boot attributes.  This file is
 *      autogenerated and should not be altered.
 */

//******************************************************************************
// Includes
//******************************************************************************

// STD
#include <stdint.h>
#include <stdlib.h>

// Targeting component
#include <builtins.h>
#include <targeting/common/attributes.H>
#include <targeting/common/entitypath.H>

//******************************************************************************
// Complex Types
//******************************************************************************

namespace TARGETING
{

/**
 *  @brief Structure which defines a target's primary capabilities. A
 *	target can only support at most FSI SCOM and one of the other two
 *	SCOM types. Applicable for all targets. Structure is read-only.
 */
struct PrimaryCapabilities
{
    // 0b0: Target does not support FSI SCOM; 0b1: Target supports FSI SCOM
    uint8_t supportsFsiScom : 1; 

    // 0b0: Target does not support XSCOM; 0b1: Target supports FSI XSCOM
    uint8_t supportsXscom : 1; 

    // 0b0: Target does not support inband SCOM
    uint8_t supportsInbandScom : 1; 

    // Reserved for future use
    uint8_t reserved : 5; 

} PACKED;

/**
 *  @brief Structure which defines which SCOM to use at a point in time.
 *	Only applicable if target supports one or more SCOM types. Only one
 *	bit (of the first three) can ever be set at any one time.
 */
struct ScomSwitches
{
    // 0b0: Do not use FSI SCOM at this time. 0b1: Use FSI SCOM at this
    // time
    uint8_t useFsiScom : 1; 

    // 0b0: Do not use XSCOM at this time. 0b1: Use XSCOM at this time
    uint8_t useXscom : 1; 

    // 0b0: Do not use inband SCOM at this time. 0b1: Use inband SCOM at
    // this time
    uint8_t useInbandScom : 1; 

    // Reserved for future expansion
    uint8_t reserved : 5; 

} PACKED;

/**
 *  @brief FSI flags
 */
struct FsiOptionFlags
{
    // Set on FSI master chips (procs) if that chip uses slaveB to attach
    // to the acting master chip.
    uint16_t flipPort : 1; 

    // Reserved for future expansion
    uint16_t reserved : 15; 

} PACKED;

/**
 *  @brief struct - 4 booleans and a PLID
 */
struct HwasState
{
    // if this target was deconfigured, this will be a special
    // DECONFIGURED_BY_ enum, OR it will be the errlog EID that caused it,
    // either directly or by association,
    uint32_t deconfiguredByEid; 

    // 0b0: Target is not powered on (is off); 0b1: Target is powered on;
    uint8_t poweredOn : 1; 

    // 0b0: Target is not present in the system; 0b1: Target is present in
    // the system
    uint8_t present : 1; 

    // 0b0: Target is not functional; 0b1: Target is functional
    uint8_t functional : 1; 

    // FSP Only, used by DUMP applet; 0b0: target is dump capabile; 0b1:
    // target is not dump capabile;
    uint8_t dumpfunctional : 1; 

    // Set for speculative deconfig; 0b0: target not speculative deconfig;
    // 0b1: target is speculatively deconfigured;
    uint8_t specdeconfig : 1; 

} PACKED;

/**
 *  @brief Numeric POD type test structure
 */
struct NumericPodTypeTest
{
    // Entity path for testing purposes
    EntityPath fsiPath; 

    // Class for testing purposes
    CLASS className; 

    // Test uint8
    uint8_t uint8; 

    // Test uint16
    uint16_t uint16; 

    // Test uint32
    uint32_t uint32; 

    // Test uint64
    uint64_t uint64; 

    // Test int8
    int8_t int8; 

    // Test int16
    int16_t int16; 

    // Test int32
    int32_t int32; 

    // Test int64
    int64_t int64; 

} PACKED;

/**
 *  @brief Structure to define the addressing for an I2C slave device.
 */
struct EepromVpdPrimaryInfo
{
    // Entity path to the chip that contains the I2C master
    EntityPath i2cMasterPath; 

    // Port from the I2C Master device. This is a 6-bit value.
    uint8_t port; 

    // Device address on the I2C bus. This is a 7-bit value, but then
    // shifted 1 bit left.
    uint8_t devAddr; 

    // I2C master engine. This is a 2-bit value.
    uint8_t engine; 

    // The number of bytes a device requires to set its internal
    // address/offset.
    uint8_t byteAddrOffset; 

    // The number of kilobytes a device can hold. 'Zero' value possible for
    // some devices.
    uint64_t maxMemorySizeKB; 

    // The maximum number of bytes that can be written to a device at one
    // time. 'Zero' value means no maximum value is expected or checked.
    uint64_t writePageSize; 

    // The amount of time in milliseconds a device requires on the
    // completion of a write command to update its internal memory.
    uint64_t writeCycleTime; 

} PACKED;

/**
 *  @brief Structure to define the addressing for an I2C slave device.
 */
struct EepromVpdBackupInfo
{
    // Entity path to the chip that contains the I2C master
    EntityPath i2cMasterPath; 

    // Port from the I2C Master device. This is a 6-bit value.
    uint8_t port; 

    // Device address on the I2C bus. This is a 7-bit value, but then
    // shifted 1 bit left.
    uint8_t devAddr; 

    // I2C master engine. This is a 2-bit value.
    uint8_t engine; 

    // The number of bytes a device requires to set its internal
    // address/offset.
    uint8_t byteAddrOffset; 

    // The number of kilobytes a device can hold. 'Zero' value possible for
    // some devices.
    uint64_t maxMemorySizeKB; 

    // The maximum number of bytes that can be written to a device at one
    // time. 'Zero' value means no maximum value is expected or checked.
    uint64_t writePageSize; 

    // The amount of time in milliseconds a device requires on the
    // completion of a write command to update its internal memory.
    uint64_t writeCycleTime; 

} PACKED;

/**
 *  @brief Structure to define the addressing for an I2C slave device.
 */
struct EepromSbePrimaryInfo
{
    // Entity path to the chip that contains the I2C master
    EntityPath i2cMasterPath; 

    // Port from the I2C Master device. This is a 6-bit value.
    uint8_t port; 

    // Device address on the I2C bus. This is a 7-bit value, but then
    // shifted 1 bit left.
    uint8_t devAddr; 

    // I2C master engine. This is a 2-bit value.
    uint8_t engine; 

    // The number of bytes a device requires to set its internal
    // address/offset.
    uint8_t byteAddrOffset; 

    // The number of kilobytes a device can hold. 'Zero' value possible for
    // some devices.
    uint64_t maxMemorySizeKB; 

    // The maximum number of bytes that can be written to a device at one
    // time. 'Zero' value means no maximum value is expected or checked.
    uint64_t writePageSize; 

    // The amount of time in milliseconds a device requires on the
    // completion of a write command to update its internal memory.
    uint64_t writeCycleTime; 

} PACKED;

/**
 *  @brief Structure to define the addressing for an I2C slave device.
 */
struct EepromSbeBackupInfo
{
    // Entity path to the chip that contains the I2C master
    EntityPath i2cMasterPath; 

    // Port from the I2C Master device. This is a 6-bit value.
    uint8_t port; 

    // Device address on the I2C bus. This is a 7-bit value, but then
    // shifted 1 bit left.
    uint8_t devAddr; 

    // I2C master engine. This is a 2-bit value.
    uint8_t engine; 

    // The number of bytes a device requires to set its internal
    // address/offset.
    uint8_t byteAddrOffset; 

    // The number of kilobytes a device can hold. 'Zero' value possible for
    // some devices.
    uint64_t maxMemorySizeKB; 

    // The maximum number of bytes that can be written to a device at one
    // time. 'Zero' value means no maximum value is expected or checked.
    uint64_t writePageSize; 

    // The amount of time in milliseconds a device requires on the
    // completion of a write command to update its internal memory.
    uint64_t writeCycleTime; 

} PACKED;

/**
 *  @brief Structure to define the addressing for an I2C TPM.
 */
struct TpmPrimaryInfo
{
    // Boolean indicating whether this TPM is available in the system
    uint8_t tpmEnabled; 

    // Entity path to the chip that contains the I2C master
    EntityPath i2cMasterPath; 

    // Port from the I2C Master device. This is a 6-bit value.
    uint8_t port; 

    // Device address on the I2C bus for Locality 0. This is a 7-bit value,
    // but then shifted 1 bit left.
    uint8_t devAddrLocality0; 

    // Device address on the I2C bus for Locality 4. This is a 7-bit value,
    // but then shifted 1 bit left.
    uint8_t devAddrLocality4; 

    // I2C master engine. This is a 2-bit value.
    uint8_t engine; 

    // The number of bytes a device requires to set its internal
    // address/offset.
    uint8_t byteAddrOffset; 

} PACKED;

/**
 *  @brief Structure to define the addressing for an I2C TPM device.
 */
struct TpmBackupInfo
{
    // Boolean indicating whether this TPM is available in the system
    uint8_t tpmEnabled; 

    // Entity path to the chip that contains the I2C master
    EntityPath i2cMasterPath; 

    // Port from the I2C Master device. This is a 6-bit value.
    uint8_t port; 

    // Device address on the I2C bus for Locality 0. This is a 7-bit value,
    // but then shifted 1 bit left.
    uint8_t devAddrLocality0; 

    // Device address on the I2C bus for Locality 4. This is a 7-bit value,
    // but then shifted 1 bit left.
    uint8_t devAddrLocality4; 

    // I2C master engine. This is a 2-bit value.
    uint8_t engine; 

    // The number of bytes a device requires to set its internal
    // address/offset.
    uint8_t byteAddrOffset; 

} PACKED;

/**
 *  @brief Structure which defines a system's SP functions. Applicable for
 *	System target only. Structure is read-only.
 */
struct SpFunctions
{
    // If this flag is set then mailboxEnabled MUST also be set 0b0: SP
    // does not support for VPD, payload, ATTR sync, VDDR, TOD; 0b1: SP
    // supports VPD, payload, ATTR sync, VDDR, TOD
    uint32_t baseServices : 1; 

    // 0b0: SP does not initialize FSI slave logic, Hostboot must; 0b1: SP
    // does initialize FSI slave logic so Hostboot should not
    uint32_t fsiSlaveInit : 1; 

    // 0b0: There is no SP mailbox support; 0b1: There is SP mailbox
    // support
    uint32_t mailboxEnabled : 1; 

    // 0b0: SP does not initialize FSI master logic, Hostboot must; 0b1: SP
    // does initialize FSI master logic so Hostboot should not
    uint32_t fsiMasterInit : 1; 

    // 0b0: SP does not perform hardware change detection, Hostboot must;
    // 0b1: SP does perform hardware change detection (HCDB) so Hostboot
    // should not
    uint32_t hardwareChangeDetection : 1; 

    // 0b0: SP does not perform Power Line Disturbance (PLD) detection,
    // Hostboot must; 0b1: SP does perform Power Line Disturbance (PLD)
    // detection so Hostboot should not
    uint32_t powerLineDisturbance : 1; 

    // Reserved for future use
    uint32_t reserved : 26; 

} PACKED;

/**
 *  @brief Structure which defines a system's HB settings. Applicable for
 *	System target only.
 */
struct HbSettings
{
    // Enable / Disable continuous trace. 0b0: Continuous trace is
    // disabled. 0b1: Continuous trace is enabled.
    uint8_t traceContinuous : 1; 

    // Override trace debug selection for SCAN component. 0b0: TRACS
    // entries for SCAN have default behavior. 0b1: TRACS entries for SCAN
    // are enabled.
    uint8_t traceScanDebug : 1; 

    // Reserved for future use
    uint8_t reserved : 6; 

} PACKED;

/**
 *  @brief Structure which defines a they IPL types Applicable for System
 *	target only.
 */
struct CecIplType
{
    // Perform mainstore dump collection. Only valid for MPIPL 0b0: Do not
    // collect mainstore dump 0b1: Perform mainstore dump collection
    uint8_t PostDump : 1; 

    // Reserved for future use
    uint8_t reserved : 7; 

} PACKED;

/**
 *  @brief Structure which defines which I2C access method to use at a
 *	point in time. Only applicable if target supports one or more I2C
 *	types. Only one bit (of the first two) can ever be set at any one
 *	time.
 */
struct I2cSwitches
{
    // 0b0: Do not use FSI I2C at this time. 0b1: Use FSI I2C at this time
    uint8_t useFsiI2C : 1; 

    // 0b0: Do not use Host I2C at this time. 0b1: Use Host I2C at this
    // time
    uint8_t useHostI2C : 1; 

    // Reserved for future expansion
    uint8_t reserved : 6; 

} PACKED;

/**
 *  @brief Structure to define the addessing for an I2C slave device.
 */
struct GpioInfo
{
    // Entity path to the chip that contains the I2C master
    EntityPath i2cMasterPath; 

    // Port from the I2C Master device. This is a 6-bit value.
    uint8_t port; 

    // Device address on the I2C bus. This is a 7-bit value, but then
    // shifted 1 bit left.
    uint8_t devAddr; 

    // I2C master engine. This is a 2-bit value.
    uint8_t engine; 

    // Logical GPIO pin number used to enabled/disable VDDR
    uint8_t vddrPin; 

} PACKED;

/**
 *  @brief VPD flags
 */
struct VpdSwitches
{
    // Set when this target's VPD data has been loaded from EEPROM into the
    // PNOR.
    uint8_t pnorCacheValid : 1; 

    // See pnorCacheValid. Allows runtime version to be set separately from
    // common version.
    uint8_t pnorCacheValidRT : 1; 

    // Set to disable write-thru to PNOR at runtime
    uint8_t disableWriteToPnorRT : 1; 

    // Reserved for future expansion
    uint8_t reserved : 5; 

} PACKED;

} // End namespace TARGETING

#endif // TARG_ATTRIBUTESTRUCTS_H

