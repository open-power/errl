
#ifndef MAPATTRMETADATA_H
#define MAPATTRMETADATA_H

/**
 *  @file mapattrmetadata.H
 *
 *  @brief Interface to get the unordered/ordered map of all target attributes
 *  respective attribute size and read/write properties. This file is
 *  autogenerated and should not be altered.
 */

// STD
#ifndef __HOSTBOOT_MODULE
#include <tr1/unordered_map>
#else
#include <map>
#endif

// TARG
#include <targeting/common/trace.H>
#include <targeting/common/target.H>

//******************************************************************************
// Macros
//******************************************************************************

#undef TARG_NAMESPACE
#undef TARG_CLASS
#undef TARG_FUNC

//******************************************************************************
// Interface
//******************************************************************************

#ifndef __HOSTBOOT_MODULE
/*
 * @brief Specialized Hash function Template to be inserted with unordered_map
 */
namespace std
{

namespace tr1
{
    template <>
    struct hash<TARGETING::ATTRIBUTE_ID> : public unary_function<
                                            TARGETING::ATTRIBUTE_ID, size_t>
    {
        size_t operator()(const TARGETING::ATTRIBUTE_ID& attrId) const
        {
            return attrId;
        }
    };
}

}
#endif

namespace TARGETING
{

/*
 * @brief - Data Struct to contain attribute related info
 *
 * Field Description
 * @field1 - Size: Size of the attribute
 * @field2 - readWriteable: true if read and writeable else false only readable
 * @field3 - Persistency level of the attribute
 */
struct attrMetadataStr
{
    uint32_t size;
    bool readWriteable;
    const char* persistency;

    attrMetadataStr() :
        size(0), readWriteable(false), persistency(NULL) {}

    attrMetadataStr(uint32_t i_size, bool i_rw, const char* i_persistency) :
        size(i_size), readWriteable(i_rw), persistency(i_persistency) {}
};

/*
 * @brief Typedef for struct attrMetadataStr
 */
typedef struct attrMetadataStr AttrMetadataStr;

/*
 * @brief Typedef for pair<ATTRIBUTE_ID, AttrMetadataStr>
 */
typedef std::pair<ATTRIBUTE_ID, AttrMetadataStr> Pair_t;

#ifndef __HOSTBOOT_MODULE
/*
 * @brief Typedef std::tr1::unordered_map <attr, struct attrMetadataStr,
 *      hash_method>
 */
typedef std::tr1::unordered_map<ATTRIBUTE_ID, AttrMetadataStr, 
    std::tr1::hash<TARGETING::ATTRIBUTE_ID> > AttrMetadataMapper;
#else
/*
 * @brief Typedef std::map <attr, struct attrMetadataStr>
 */
typedef std::map<ATTRIBUTE_ID, AttrMetadataStr> AttrMetadataMapper;
#endif

class MapAttrMetadata
{
    public:
        /**
         *  @brief Destroy the MapAttrMetadata class
         */
        ~MapAttrMetadata();

        /**
         *  @brief Create the MapAttrMetadata class
         */
        MapAttrMetadata();

        /*
         *  @brief returns the unordered/ordered map of all attributes as
         *  key and struct attrMetadataStr as value, which contains the size
         *  of the attribute along with read/writeable properties
         *
         *  @return, returns the unordered/ordered map which has the all
         *  attributes as key and struct attrMetadataStr as value pair,
         *  variable <ATTRIBUTE_ID::struct attrMetadataStr>
         */
         const AttrMetadataMapper& getMapMetadataForAllAttributes() const;

     private:

        /* Unordered/Ordered map variable for All Attribute Ids vs Size &
         * Read/Write properties */
        AttrMetadataMapper iv_mapAttrMetadata;

        /* Disable Copy constructor and assignment operator */
        MapAttrMetadata(
            const MapAttrMetadata& i_right);

        MapAttrMetadata& operator = (
            const MapAttrMetadata& i_right);
};

/**
 *  @brief Provide singleton access to the MapAttrMetadata
 */
TARG_DECLARE_SINGLETON(TARGETING::MapAttrMetadata, theMapAttrMetadata);

#undef TARG_CLASS
#undef TARG_NAMESPACE


}// namespace TARGETING

#endif // MAPATTRMETADATA_H

