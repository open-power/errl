/*
 * Automatically generated by Hostboot's ./genErrlParsers.pl
 * Do not modify this file in the FSP tree, it is provided by
 * Hostboot and will be overwritten
 *
 * TimeStamp:   Thu Apr 12 08:28:51 2018
 * Image Id:    hb0412a_1815.861
 *
 */

#include <errlplugins.H>
#include <errlusrparser.H>
#include <srcisrc.H>

static bool SrcDataParse(ErrlUsrParser & i_parser,
                         const SrciSrc & i_src)
{
    uint32_t l_error = (i_src.reasonCode() << 8) + i_src.moduleId();
    bool l_success = true;

    switch(l_error)
    {
    case 0x170101:
        i_parser.PrintString("devdesc", "IStep failed, see other log(s) with the same PLID for reason.");
        i_parser.PrintString("moduleid", "ISTEP_REPORTING_ERROR");
        i_parser.PrintString("reasoncode", "ISTEP_FAILURE");
        i_parser.PrintString("userdata1[0:31]", "eid of first error");
        i_parser.PrintString("userdata1[32:63]", "Reason code of first error");
        i_parser.PrintString("userdata2[0:31]", "Total number of elogs included");
        i_parser.PrintString("userdata2[32:64]", "iStep and SubStep that failed");
        break;

    case 0x170604:
        i_parser.PrintString("devdesc", "Image from PNOR WINK partition invalid, too small, or too big");
        i_parser.PrintString("moduleid", "ISTEP_BUILD_WINKLE_IMAGES");
        i_parser.PrintString("reasoncode", "ISTEP_LOAD_SLW_FROM_PNOR_FAILED");
        i_parser.PrintString("userdata1", "Hi 32 bits: return code from sbe_xip_image_size Lo 32 bits: Size of memory requested");
        i_parser.PrintString("userdata2", "Size of WINK PNOR partition");
        break;

    case 0x170304:
        i_parser.PrintString("devdesc", "p8_pore_gen_xxx returned an error when attempting to change a reg value in the PORE image.");
        i_parser.PrintString("moduleid", "ISTEP_BUILD_WINKLE_IMAGES");
        i_parser.PrintString("reasoncode", "ISTEP_BAD_RC");
        i_parser.PrintString("userdata1[00:31]", "return code from p8_pore_gen_xxx function");
        i_parser.PrintString("userdata1[32:63]", "address being added to image");
        i_parser.PrintString("userdata2[00:31]", "Failing Core Id");
        i_parser.PrintString("userdata2[32:63]", "Failing Thread Id");
        break;

    case 0x170504:
        i_parser.PrintString("devdesc", "mm_block_unmap() returns error");
        i_parser.PrintString("moduleid", "ISTEP::ISTEP_BUILD_WINKLE_IMAGES");
        i_parser.PrintString("reasoncode", "ISTEP::ISTEP_MM_UNMAP_ERR");
        i_parser.PrintString("userdata1", "Return Code");
        i_parser.PrintString("userdata2", "Unmap address");
        break;

    case 0x170505:
        i_parser.PrintString("devdesc", "mm_block_unmap() returns error");
        i_parser.PrintString("moduleid", "ISTEP::ISTEP_PROC_SET_PORE_BAR");
        i_parser.PrintString("reasoncode", "ISTEP::ISTEP_MM_UNMAP_ERR");
        i_parser.PrintString("userdata1", "Return Code");
        i_parser.PrintString("userdata2", "Unmap address");
        break;

    case 0x170209:
        i_parser.PrintString("devdesc", "Attribute model inconsistency detected; Cannot represent PHB bitmask given the value of the PCI target's chip unit attribute.  Continuing without PHB enabled");
        i_parser.PrintString("moduleid", "ISTEP_DECONFIG_PHBS_BASED_ON_PCI_STATE");
        i_parser.PrintString("reasoncode", "ISTEP_TARGET_NULL");
        i_parser.PrintString("userdata1[0:31]", "HUID of PCI target with bad ATTR_CHIP_UNIT");
        i_parser.PrintString("userdata1[32:39]", "ATTR_CHIP_UNIT value");
        i_parser.PrintString("userdata2[40:47]", "# bits to shift");
        break;

    case 0x17020A:
        i_parser.PrintString("devdesc", "Caller passed a NULL processor target");
        i_parser.PrintString("moduleid", "ISTEP_COMPUTE_PCIE_CONFIG_ATTRS");
        i_parser.PrintString("reasoncode", "ISTEP_TARGET_NULL");
        break;

    case 0x170A0A:
        i_parser.PrintString("devdesc", "Caller passed a non-processor chip target or passed a processor chip target that was not present");
        i_parser.PrintString("moduleid", "ISTEP_COMPUTE_PCIE_CONFIG_ATTRS");
        i_parser.PrintString("reasoncode", "ISTEP_INVALID_TARGET_TYPE");
        i_parser.PrintString("userdata1[0:31]", "Illegal target's class");
        i_parser.PrintString("userdata1[32:63]", "Illegal target's type");
        i_parser.PrintString("userdata2[0:31]", "Illegal target's HUID");
        i_parser.PrintString("userdata2[32:63]", "Illegal target's presence (0=no, 1=yes)");
        break;

    case 0x170D0A:
        i_parser.PrintString("devdesc", "Illegal ATTR_PROC_PCIE_IOP_CONFIG attr read from a processor chip target.");
        i_parser.PrintString("moduleid", "ISTEP_COMPUTE_PCIE_CONFIG_ATTRS");
        i_parser.PrintString("reasoncode", "ISTEP_INVALID_PCIE_IOP_LANE_CONFIG");
        i_parser.PrintString("userdata1[0:31]", "Target's HUID");
        i_parser.PrintString("userdata1[32:63]", "ATTR_PROC_PCIE_IOP_CONFIG attribute value");
        break;

    case 0x170B0A:
        i_parser.PrintString("devdesc", "Illegal ATTR_PROC_PCIE_NUM_LANES attribute read from a processor chip target.");
        i_parser.PrintString("moduleid", "ISTEP_COMPUTE_PCIE_CONFIG_ATTRS");
        i_parser.PrintString("reasoncode", "ISTEP_INVALID_ATTR_VALUE");
        i_parser.PrintString("userdata1[0:31]", "Target's HUID");
        i_parser.PrintString("userdata2[32:63]", "ATTR_PROC_PCIE_NUM_LANES attribute value");
        break;

    case 0x170C0A:
        i_parser.PrintString("devdesc", "No valid PCIE IOP configuration found.  All PHBs on the processor will be disabled.");
        i_parser.PrintString("moduleid", "ISTEP_COMPUTE_PCIE_CONFIG_ATTRS");
        i_parser.PrintString("reasoncode", "ISTEP_INVALID_CONFIGURATION");
        i_parser.PrintString("userdata1[0:31]", "Target processor chip's HUID");
        i_parser.PrintString("userdata1[32:47]", "IOP 0 lane set 0 lane mask");
        i_parser.PrintString("userdata1[48:63]", "IOP 0 lane set 1 lane mask");
        i_parser.PrintString("userdata2[0:15]", "IOP 1 lane set 0 lane mask");
        i_parser.PrintString("userdata2[16:31]", "IOP 1 lane set 1 lane mask");
        i_parser.PrintString("userdata2[32:47]", "IOP 2 lane set 0 lane mask");
        i_parser.PrintString("userdata2[48:63]", "IOP 2 lane set 1 lane mask");
        break;

    case 0x170202:
        i_parser.PrintString("devdesc", "System target was NULL!");
        i_parser.PrintString("moduleid", "ISTEP_START_PAYLOAD_CALL_SHUTDOWN");
        i_parser.PrintString("reasoncode", "ISTEP_TARGET_NULL");
        i_parser.PrintString("userdata1", "<UNUSED>");
        i_parser.PrintString("userdata2", "<UNUSED>");
        break;

    case 0x170808:
        i_parser.PrintString("devdesc", "mm_block_map() returns error");
        i_parser.PrintString("moduleid", "ISTEP::ISTEP_ENABLE_CORE_CHECKSTOPS");
        i_parser.PrintString("reasoncode", "ISTEP::ISTEP_MM_MAP_ERR");
        i_parser.PrintString("userdata1", "<unused>");
        i_parser.PrintString("userdata2", "Physical address");
        break;

    case 0x170308:
        i_parser.PrintString("devdesc", "p8_pore_gen_scom_fixed returned an error when attempting to erase a reg value in the PORE image.");
        i_parser.PrintString("moduleid", "ISTEP_ENABLE_CORE_CHECKSTOPS");
        i_parser.PrintString("reasoncode", "ISTEP_BAD_RC");
        i_parser.PrintString("userdata1[00:31]", "rc from p8_pore_gen_scom_fixed function");
        i_parser.PrintString("userdata1[32:63]", "address being added to image");
        i_parser.PrintString("userdata2[00:31]", "Failing Proc HUID");
        i_parser.PrintString("userdata2[32:63]", "Failing Core Id");
        break;

    case 0x170508:
        i_parser.PrintString("devdesc", "mm_block_unmap() returns error");
        i_parser.PrintString("moduleid", "ISTEP::ISTEP_ENABLE_CORE_CHECKSTOPS");
        i_parser.PrintString("reasoncode", "ISTEP::ISTEP_MM_UNMAP_ERR");
        i_parser.PrintString("userdata1", "Return Code");
        i_parser.PrintString("userdata2", "Unmap address");
        break;

    case 0x17020B:
        i_parser.PrintString("devdesc", "System target was NULL!");
        i_parser.PrintString("moduleid", "ISTEP_LOAD_PAYLOAD");
        i_parser.PrintString("reasoncode", "ISTEP_TARGET_NULL");
        i_parser.PrintString("userdata1", "<UNUSED>");
        i_parser.PrintString("userdata2", "<UNUSED>");
        break;

    case 0x170406:
        i_parser.PrintString("devdesc", "p8_pore_gen_cpureg returned an error when attempting to change a reg value in the PORE image.");
        i_parser.PrintString("moduleid", "ISTEP_HOST_ACTIVATE_MASTER");
        i_parser.PrintString("reasoncode", "ISTEP_FAIL_MASTER_WINKLE_RC");
        i_parser.PrintString("userdata1", "return code from cpu_master_winkle");
        break;

    case 0x170303:
        i_parser.PrintString("devdesc", "Kernel returned error when trying to activate core.");
        i_parser.PrintString("moduleid", "ISTEP_HOST_ACTIVATE_SLAVE_CORES");
        i_parser.PrintString("reasoncode", "ISTEP_BAD_RC");
        i_parser.PrintString("userdata1", "PIR of failing core.");
        i_parser.PrintString("userdata2", "rc of cpu_start_core().");
        break;

    case 0x170903:
        i_parser.PrintString("devdesc", "Call to getParentAffinityTarget requesting the number of EX chips with parent affinity to a core, returned an incorrect vector size, the expected size is 1.");
        i_parser.PrintString("moduleid", "ISTEP_HOST_ACTIVATE_SLAVE_CORES");
        i_parser.PrintString("reasoncode", "ISTEP_INCORRECT_TARGET_COUNT");
        i_parser.PrintString("userdata1", "PIR of failing core.");
        i_parser.PrintString("userdata2", "number of targets returned");
        break;

    default:
        l_success = false;
        break;
    };
    return l_success;
}

static errl::SrcPlugin g_SrcPlugin(0x1700, SrcDataParse, ERRL_CID_HOSTBOOT);
