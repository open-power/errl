/*
 * Automatically generated by Hostboot's ./genErrlParsers.pl
 * Do not modify this file in the FSP tree, it is provided by
 * Hostboot and will be overwritten
 *
 * TimeStamp:   Thu Apr 12 08:28:51 2018
 * Image Id:    hb0412a_1815.861
 *
 */

#include <errlplugins.H>
#include <errlusrparser.H>
#include <srcisrc.H>

static bool SrcDataParse(ErrlUsrParser & i_parser,
                         const SrciSrc & i_src)
{
    uint32_t l_error = (i_src.reasonCode() << 8) + i_src.moduleId();
    bool l_success = true;

    switch(l_error)
    {
    case 0x1D0761:
        i_parser.PrintString("devdesc", "Invalid Basic Memory Type");
        i_parser.PrintString("moduleid", "VPD::VPD_SPD_GET_KEYWORD_VALUE");
        i_parser.PrintString("reasoncode", "VPD::VPD_INVALID_BASIC_MEMORY_TYPE");
        i_parser.PrintString("userdata1", "Basic Memory Type (Byte 2)");
        i_parser.PrintString("userdata2", "Keyword Requested");
        break;

    case 0x1D0765:
        i_parser.PrintString("devdesc", "Invalid Basic Memory Type");
        i_parser.PrintString("moduleid", "VPD::VPD_SPD_WRITE_KEYWORD_VALUE");
        i_parser.PrintString("reasoncode", "VPD::VPD_INVALID_BASIC_MEMORY_TYPE");
        i_parser.PrintString("userdata1", "Basic Memory Type (Byte 2)");
        i_parser.PrintString("userdata2", "Keyword Requested");
        break;

    case 0x1D316F:
        i_parser.PrintString("devdesc", "Unable to resolve the VPD source (PNOR or SEEPROM)");
        i_parser.PrintString("moduleid", "VPD::VPD_SPD_FETCH_DATA");
        i_parser.PrintString("reasoncode", "VPD::VPD_READ_SOURCE_UNRESOLVED");
        i_parser.PrintString("userdata1[0:31]", "Target HUID");
        i_parser.PrintString("userdata1[32:63]", "Requested VPD Source Location");
        i_parser.PrintString("userdata2[0:31]", "SPD read PNOR flag");
        i_parser.PrintString("userdata2[32:63]", "SPD read HW flag");
        break;

    case 0x1D1462:
        i_parser.PrintString("devdesc", "The table entry associated with keyword was NULL.");
        i_parser.PrintString("moduleid", "VPD::VPD_SPD_GET_VALUE");
        i_parser.PrintString("reasoncode", "VPD::VPD_NULL_ENTRY");
        i_parser.PrintString("userdata1", "SPD Keyword");
        i_parser.PrintString("userdata2[0:31]", "Buffer Size");
        i_parser.PrintString("userdata2[32:63]", "Memory Type");
        break;

    case 0x1D146B:
        i_parser.PrintString("devdesc", "The table entry associated with keyword was NULL.");
        i_parser.PrintString("moduleid", "VPD::VPD_SPD_WRITE_VALUE");
        i_parser.PrintString("reasoncode", "VPD::VPD_NULL_ENTRY");
        i_parser.PrintString("userdata1", "SPD Keyword");
        i_parser.PrintString("userdata2[0:31]", "Buffer Length");
        i_parser.PrintString("userdata2[32:63]", "Memory Type");
        break;

    case 0x1D0B6B:
        i_parser.PrintString("devdesc", "The SPD Keyword is not writable.");
        i_parser.PrintString("moduleid", "VPD::VPD_SPD_WRITE_VALUE");
        i_parser.PrintString("reasoncode", "VPD::VPD_KEYWORD_NOT_WRITABLE");
        i_parser.PrintString("userdata1", "SPD Keyword");
        i_parser.PrintString("userdata2[0:31]", "Buffer Length");
        i_parser.PrintString("userdata2[32:63]", "Memory Type");
        break;

    case 0x1D156B:
        i_parser.PrintString("devdesc", "Writes to non-byte SPD keywords are unsupported.");
        i_parser.PrintString("moduleid", "VPD::VPD_SPD_WRITE_VALUE");
        i_parser.PrintString("reasoncode", "VPD::VPD_UNSUPPORTED_WRITE");
        i_parser.PrintString("userdata1", "SPD Keyword");
        i_parser.PrintString("userdata2[0:15]", "Keyword Length (in bytes)");
        i_parser.PrintString("userdata2[16:31]", "Keyword Bitmask");
        i_parser.PrintString("userdata2[32:63]", "Memory Type");
        break;

    case 0x1D0967:
        i_parser.PrintString("devdesc", "Keyword is not a special case keyword.");
        i_parser.PrintString("moduleid", "VPD::VPD_SPD_DDR3_SPECIAL_CASES");
        i_parser.PrintString("reasoncode", "VPD::VPD_INVALID_SPD_KEYWORD");
        i_parser.PrintString("userdata1", "SPD Keyword");
        i_parser.PrintString("userdata2", "UNUSED");
        break;

    case 0x1D0968:
        i_parser.PrintString("devdesc", "Keyword is not a special case keyword.");
        i_parser.PrintString("moduleid", "VPD::VPD_SPD_DDR4_SPECIAL_CASES");
        i_parser.PrintString("reasoncode", "VPD::VPD_INVALID_SPD_KEYWORD");
        i_parser.PrintString("userdata1", "SPD Keyword");
        i_parser.PrintString("userdata2", "UNUSED");
        break;

    case 0x1D0766:
        i_parser.PrintString("devdesc", "Invalid DDR Revision");
        i_parser.PrintString("moduleid", "VPD::VPD_SPD_SPECIAL_CASES");
        i_parser.PrintString("reasoncode", "VPD::VPD_INVALID_BASIC_MEMORY_TYPE");
        i_parser.PrintString("userdata1", "SPD Keyword");
        i_parser.PrintString("userdata2", "DIMM DDR Revision");
        break;

    case 0x1D0663:
        i_parser.PrintString("devdesc", "Buffer Size provided was not big enough for the keyword requested.");
        i_parser.PrintString("moduleid", "VPD::VPD_SPD_CHECK_SIZE");
        i_parser.PrintString("reasoncode", "VPD::VPD_INSUFFICIENT_BUFFER_SIZE");
        i_parser.PrintString("userdata1", "Keyword");
        i_parser.PrintString("userdata2[0:31]", "Needed Buffer Size");
        i_parser.PrintString("userdata2[32:63]", "Expected Buffer Size");
        break;

    case 0x1D0164:
        i_parser.PrintString("devdesc", "File is not sufficiently large to read number of bytes at offset given without overrunning file.");
        i_parser.PrintString("moduleid", "VPD::VPD_SPD_READ_BINARY_FILE");
        i_parser.PrintString("reasoncode", "VPD::VPD_INSUFFICIENT_FILE_SIZE");
        i_parser.PrintString("userdata1", "File Size");
        i_parser.PrintString("userdata2[0:48]", "Starting offset into file");
        i_parser.PrintString("userdata2[49:63]", "Number of bytes to read");
        break;

    case 0x1D0D6A:
        i_parser.PrintString("devdesc", "Keyword requested was not UMM Module specific.");
        i_parser.PrintString("moduleid", "VPD::VPD_SPD_CHECK_MODULE_SPECIFIC_KEYWORD");
        i_parser.PrintString("reasoncode", "VPD::VPD_MOD_SPECIFIC_MISMATCH_UMM");
        i_parser.PrintString("userdata1[0:31]", "Module Type (byte 3[3:0])");
        i_parser.PrintString("userdata1[32:63]", "Memory Type (byte 2)");
        i_parser.PrintString("userdata2[0:31]", "SPD Keyword");
        i_parser.PrintString("userdata2[32:63]", "Module Specific flag");
        break;

    case 0x1D0E6A:
        i_parser.PrintString("devdesc", "Keyword requested was not RMM Module specific.");
        i_parser.PrintString("moduleid", "VPD::VPD_SPD_CHECK_MODULE_SPECIFIC_KEYWORD");
        i_parser.PrintString("reasoncode", "VPD::VPD_MOD_SPECIFIC_MISMATCH_RMM");
        i_parser.PrintString("userdata1[0:31]", "Module Type (byte 3[3:0])");
        i_parser.PrintString("userdata1[32:63]", "Memory Type (byte 2)");
        i_parser.PrintString("userdata2[0:31]", "SPD Keyword");
        i_parser.PrintString("userdata2[32:63]", "Module Specific flag");
        break;

    case 0x1D0F6A:
        i_parser.PrintString("devdesc", "Keyword requested was not CMM Module specific.");
        i_parser.PrintString("moduleid", "VPD::VPD_SPD_CHECK_MODULE_SPECIFIC_KEYWORD");
        i_parser.PrintString("reasoncode", "VPD::VPD_MOD_SPECIFIC_MISMATCH_CMM");
        i_parser.PrintString("userdata1[0:31]", "Module Type (byte 3[3:0])");
        i_parser.PrintString("userdata1[32:63]", "Memory Type (byte 2)");
        i_parser.PrintString("userdata2[0:31]", "SPD Keyword");
        i_parser.PrintString("userdata2[32:63]", "Module Specific flag");
        break;

    case 0x1D106A:
        i_parser.PrintString("devdesc", "Keyword requested was not LRMM Module specific.");
        i_parser.PrintString("moduleid", "VPD::VPD_SPD_CHECK_MODULE_SPECIFIC_KEYWORD");
        i_parser.PrintString("reasoncode", "VPD::VPD_MOD_SPECIFIC_MISMATCH_LRMM");
        i_parser.PrintString("userdata1[0:31]", "Module Type (byte 3[3:0])");
        i_parser.PrintString("userdata1[32:63]", "Memory Type (byte 2)");
        i_parser.PrintString("userdata2[0:31]", "SPD Keyword");
        i_parser.PrintString("userdata2[32:63]", "Module Specific flag");
        break;

    case 0x1D116A:
        i_parser.PrintString("devdesc", "Unsupported Module Type.");
        i_parser.PrintString("moduleid", "VPD::VPD_SPD_CHECK_MODULE_SPECIFIC_KEYWORD");
        i_parser.PrintString("reasoncode", "VPD::VPD_MOD_SPECIFIC_UNSUPPORTED");
        i_parser.PrintString("userdata1", "Module Type");
        i_parser.PrintString("userdata2", "Memory Type (byte 2)");
        break;

    case 0x1D116E:
        i_parser.PrintString("devdesc", "Unrecognized Module Type.");
        i_parser.PrintString("moduleid", "VPD::VPD_SPD_GET_MOD_TYPE");
        i_parser.PrintString("reasoncode", "VPD::VPD_MOD_SPECIFIC_UNSUPPORTED");
        i_parser.PrintString("userdata1", "Module Type (byte 3[3:0])");
        i_parser.PrintString("userdata2", "Memory Type (byte 2)");
        break;

    case 0x1D076C:
        i_parser.PrintString("devdesc", "Invalid DDR Revision");
        i_parser.PrintString("moduleid", "VPD::VPD_SPD_GET_KEYWORD_ENTRY");
        i_parser.PrintString("reasoncode", "VPD::VPD_INVALID_BASIC_MEMORY_TYPE");
        i_parser.PrintString("userdata1", "SPD Keyword");
        i_parser.PrintString("userdata2", "The DDR Revision");
        break;

    case 0x1D046C:
        i_parser.PrintString("devdesc", "Invalid SPD Keyword");
        i_parser.PrintString("moduleid", "VPD::VPD_SPD_GET_KEYWORD_ENTRY");
        i_parser.PrintString("reasoncode", "VPD::VPD_KEYWORD_NOT_FOUND");
        i_parser.PrintString("userdata1", "SPD Keyword");
        i_parser.PrintString("userdata2", "<UNUSED>");
        break;

    case 0x1D3650:
        i_parser.PrintString("devdesc", "presenceDetect> Invalid data length (!= 1 bytes)");
        i_parser.PrintString("moduleid", "VPD::VPD_PVPD_PRESENCEDETECT");
        i_parser.PrintString("reasoncode", "VPD::VPD_INVALID_LENGTH");
        i_parser.PrintString("userdata1", "Data Length");
        break;

    case 0x1D1a80:
        i_parser.PrintString("devdesc", "Hypervisor returned NULL address for VPD");
        i_parser.PrintString("moduleid", "VPD::VPD_RT_GET_ADDR");
        i_parser.PrintString("reasoncode", "VPD::VPD_RT_NULL_VPD_PTR");
        i_parser.PrintString("userdata1", "VPD type");
        i_parser.PrintString("userdata2", "0");
        break;

    case 0x1D1980:
        i_parser.PrintString("devdesc", "Runtime VPD interface not linked.");
        i_parser.PrintString("moduleid", "VPD::VPD_RT_GET_ADDR");
        i_parser.PrintString("reasoncode", "VPD::VPD_RT_NOT_INITIALIZED");
        i_parser.PrintString("userdata1", "VPD type");
        i_parser.PrintString("userdata2", "0");
        break;

    case 0x1D1680:
        i_parser.PrintString("devdesc", "Requested VPD type is invalid or not supported at runtime");
        i_parser.PrintString("moduleid", "VPD::VPD_RT_GET_ADDR");
        i_parser.PrintString("reasoncode", "VPD::VPD_RT_INVALID_TYPE");
        i_parser.PrintString("userdata1", "Requested VPD TYPE");
        i_parser.PrintString("userdata2", "0");
        break;

    case 0x1D1881:
        i_parser.PrintString("devdesc", "MBOX send not supported in HBRT");
        i_parser.PrintString("moduleid", "VPD::VPD_RT_WRITE_PNOR");
        i_parser.PrintString("reasoncode", "VPD::VPD_RT_WRITE_NOT_SUPPORTED");
        i_parser.PrintString("userdata1", "Target");
        i_parser.PrintString("userdata2", "0");
        break;

    case 0x1D1c83:
        i_parser.PrintString("devdesc", "MBOX send not supported in HBRT");
        i_parser.PrintString("moduleid", "VPD::VPD_SEND_MBOX_WRITE_MESSAGE");
        i_parser.PrintString("reasoncode", "VPD::VPD_MBOX_NOT_SUPPORTED_RT");
        i_parser.PrintString("userdata1", "VPD message type");
        i_parser.PrintString("userdata2", "0");
        break;

    case 0x1D3533:
        i_parser.PrintString("devdesc", "The amount of space required for the VPD cache exceeds the available space");
        i_parser.PrintString("moduleid", "VPD::VPD_IPVPD_LOAD_PNOR");
        i_parser.PrintString("reasoncode", "VPD::VPD_CACHE_SIZE_EXCEEDED");
        i_parser.PrintString("userdata1", "HUID of target chip");
        i_parser.PrintString("userdata2[00:31]", "Available size");
        i_parser.PrintString("userdata2[32:63]", "Requested size");
        break;

    case 0x1D0320:
        i_parser.PrintString("devdesc", "The record enumeration did not have a corresponding string value.");
        i_parser.PrintString("moduleid", "VPD::VPD_IPVPD_TRANSLATE_RECORD");
        i_parser.PrintString("reasoncode", "VPD::VPD_RECORD_NOT_FOUND");
        i_parser.PrintString("userdata1", "Record enumeration.");
        i_parser.PrintString("userdata2", "<UNUSED>");
        break;

    case 0x1D0421:
        i_parser.PrintString("devdesc", "The keyword enumeration did not have a corresponding string value.");
        i_parser.PrintString("moduleid", "VPD::VPD_IPVPD_TRANSLATE_KEYWORD");
        i_parser.PrintString("reasoncode", "VPD::VPD_KEYWORD_NOT_FOUND");
        i_parser.PrintString("userdata1", "Keyword Enumeration");
        i_parser.PrintString("userdata2", "<UNUSED>");
        break;

    case 0x1D3122:
        i_parser.PrintString("devdesc", "Unable to resolve the VPD source (PNOR or SEEPROM)");
        i_parser.PrintString("moduleid", "VPD::VPD_IPVPD_FIND_RECORD_OFFSET");
        i_parser.PrintString("reasoncode", "VPD::VPD_READ_SOURCE_UNRESOLVED");
        i_parser.PrintString("userdata1[0:31]", "Target HUID");
        i_parser.PrintString("userdata1[32:63]", "Requested VPD Source Location");
        i_parser.PrintString("userdata2[0:31]", "VPD write PNOR flag");
        i_parser.PrintString("userdata2[32:63]", "VPD write HW flag");
        break;

    case 0x1D0322:
        i_parser.PrintString("devdesc", "The requested record was not found in the VPD TOC.");
        i_parser.PrintString("moduleid", "VPD::VPD_IPVPD_FIND_RECORD_OFFSET");
        i_parser.PrintString("reasoncode", "VPD::VPD_RECORD_NOT_FOUND");
        i_parser.PrintString("userdata1", "Requested Record");
        i_parser.PrintString("userdata2", "Requested Keyword");
        break;

    case 0x1D3030:
        i_parser.PrintString("devdesc", "The VHDR was invalid");
        i_parser.PrintString("moduleid", "VPD::VPD_IPVPD_FIND_RECORD_OFFSET_SEEPROM");
        i_parser.PrintString("reasoncode", "VPD::VPD_RECORD_INVALID_VHDR");
        i_parser.PrintString("userdata1", "VHDR length");
        i_parser.PrintString("userdata2", "Target HUID");
        break;

    case 0x1D0330:
        i_parser.PrintString("devdesc", "The requested record was not found in the VPD VTOC.");
        i_parser.PrintString("moduleid", "VPD::VPD_IPVPD_FIND_RECORD_OFFSET_SEEPROM");
        i_parser.PrintString("reasoncode", "VPD::VPD_RECORD_NOT_FOUND");
        i_parser.PrintString("userdata1[0:31]", "Requested Record");
        i_parser.PrintString("userdata1[32:63]", "Requested Keyword");
        i_parser.PrintString("userdata2", "Target HUID");
        break;

    case 0x1D3034:
        i_parser.PrintString("devdesc", "The VHDR was invalid");
        i_parser.PrintString("moduleid", "VPD::VPD_IPVPD_GET_RECORD_LIST_SEEPROM");
        i_parser.PrintString("reasoncode", "VPD::VPD_RECORD_INVALID_VHDR");
        i_parser.PrintString("userdata1", "VHDR length");
        i_parser.PrintString("userdata2", "Target HUID");
        break;

    case 0x1D3131:
        i_parser.PrintString("devdesc", "Unable to resolve the VPD source (PNOR or SEEPROM)");
        i_parser.PrintString("moduleid", "VPD::VPD_IPVPD_FETCH_DATA");
        i_parser.PrintString("reasoncode", "VPD::VPD_READ_SOURCE_UNRESOLVED");
        i_parser.PrintString("userdata1[0:31]", "Target HUID");
        i_parser.PrintString("userdata1[32:63]", "Requested VPD Source Location");
        i_parser.PrintString("userdata2[0:31]", "VPD read PNOR flag");
        i_parser.PrintString("userdata2[32:63]", "VPD read HW flag");
        break;

    case 0x1D0523:
        i_parser.PrintString("devdesc", "Record name does not match value expected for offset read.");
        i_parser.PrintString("moduleid", "VPD::VPD_IPVPD_FIND_KEYWORD_ADDR");
        i_parser.PrintString("reasoncode", "VPD::VPD_RECORD_MISMATCH");
        i_parser.PrintString("userdata1", "Current offset into VPD");
        i_parser.PrintString("userdata2", "Start of Record offset");
        break;

    case 0x1D0423:
        i_parser.PrintString("devdesc", "Keyword was not found in Record starting at given offset.");
        i_parser.PrintString("moduleid", "VPD::VPD_IPVPD_FIND_KEYWORD_ADDR");
        i_parser.PrintString("reasoncode", "VPD::VPD_KEYWORD_NOT_FOUND");
        i_parser.PrintString("userdata1[0:31]", "Start of Record Offset");
        i_parser.PrintString("userdata1[32:63]", "Keyword Index");
        i_parser.PrintString("userdata2[0:31]", "Requested Record");
        i_parser.PrintString("userdata2[32:63]", "Requested Keyword");
        break;

    case 0x1D3432:
        i_parser.PrintString("devdesc", "Unable to resolve the VPD destination (PNOR or SEEPROM)");
        i_parser.PrintString("moduleid", "VPD::VPD_IPVPD_WRITE_KEYWORD");
        i_parser.PrintString("reasoncode", "VPD::VPD_WRITE_DEST_UNRESOLVED");
        i_parser.PrintString("userdata1[0:31]", "Target HUID");
        i_parser.PrintString("userdata1[32:63]", "Requested VPD Destination");
        i_parser.PrintString("userdata2[0:31]", "VPD write PNOR flag");
        i_parser.PrintString("userdata2[32:63]", "VPD write HW flag");
        break;

    case 0x1D0624:
        i_parser.PrintString("devdesc", "Buffer size was not greater than or equal to expected buffer size.");
        i_parser.PrintString("moduleid", "VPD::VPD_IPVPD_CHECK_BUFFER_SIZE");
        i_parser.PrintString("reasoncode", "VPD::VPD_INSUFFICIENT_BUFFER_SIZE");
        i_parser.PrintString("userdata1", "Buffer Size");
        i_parser.PrintString("userdata2", "Expected Buffer Size");
        break;

    case 0x1D3210:
        i_parser.PrintString("devdesc", "writePNOR mm_remove_pages FLUSH failed");
        i_parser.PrintString("moduleid", "VPD_WRITE_PNOR");
        i_parser.PrintString("reasoncode", "VPD_REMOVE_PAGES_FAIL");
        i_parser.PrintString("userdata1", "Requested Address");
        i_parser.PrintString("userdata2", "rc from mm_remove_pages");
        break;

    case 0x1D3312:
        i_parser.PrintString("devdesc", "Unexpected target type");
        i_parser.PrintString("moduleid", "VPD_GET_PN_AND_SN");
        i_parser.PrintString("reasoncode", "VPD_UNEXPECTED_TARGET_TYPE");
        i_parser.PrintString("userdata1", "Target HUID");
        i_parser.PrintString("userdata2", "<UNUSED>");
        break;

    case 0x1D0669:
        i_parser.PrintString("devdesc", "Buffer for checking Presence Detect was not the correct size.");
        i_parser.PrintString("moduleid", "VPD::VPD_SPD_PRESENCE_DETECT");
        i_parser.PrintString("reasoncode", "VPD::VPD_INSUFFICIENT_BUFFER_SIZE");
        i_parser.PrintString("userdata1", "Buffer Length");
        i_parser.PrintString("userdata2", "<UNUSED>");
        break;

    case 0x1D1b82:
        i_parser.PrintString("devdesc", "Reserved size in memory insufficient for runtime VPD");
        i_parser.PrintString("moduleid", "VPD::VPD_BLD_RT_IMAGE");
        i_parser.PrintString("reasoncode", "VPD::VPD_INSUFFICIENT_SPACE_FOR_IMAGE");
        i_parser.PrintString("userdata1", "Size provided");
        i_parser.PrintString("userdata2", "vpd_type | Size required");
        break;

    default:
        l_success = false;
        break;
    };
    return l_success;
}

static errl::SrcPlugin g_SrcPlugin(0x1D00, SrcDataParse, ERRL_CID_HOSTBOOT);
