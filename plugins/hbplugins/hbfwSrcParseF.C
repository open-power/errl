/*
 * Automatically generated by Hostboot's ./genErrlParsers.pl
 * Do not modify this file in the FSP tree, it is provided by
 * Hostboot and will be overwritten
 *
 * TimeStamp:   Tue May 15 13:26:15 2018
 * Image Id:    hb0515b_1820.920
 *
 */

#include <errlplugins.H>
#include <errlusrparser.H>
#include <srcisrc.H>

static bool SrcDataParse(ErrlUsrParser & i_parser,
                         const SrciSrc & i_src)
{
    uint32_t l_error = (i_src.reasonCode() << 8) + i_src.moduleId();
    bool l_success = true;

    switch(l_error)
    {
    case 0xF0D13:
        i_parser.PrintString("devdesc", "Error encountered routing IPC message");
        i_parser.PrintString("moduleid", "INTR::MOD_INTRRP_IPC");
        i_parser.PrintString("reasoncode", "INTR::RC_IPC_DATA_INVALID");
        i_parser.PrintString("userdata1", "IPC Data Area MSG Queue ID");
        i_parser.PrintString("userdata2", "PIR");
        break;

    case 0xF080D:
        i_parser.PrintString("devdesc", "Unexpected RC from issuing PSIHB EOI store");
        i_parser.PrintString("moduleid", "INTR::MOD_INTRRP_SENDEOI");
        i_parser.PrintString("reasoncode", "INTR::RC_PSIHB_ESB_EOI_FAIL");
        i_parser.PrintString("userdata1", "Value read from EOI load");
        i_parser.PrintString("userdata2", "Interrupt Source to issue EOI to");
        break;

    case 0xF0C12:
        i_parser.PrintString("devdesc", "Error encountered sending coalesce message to INTRP");
        i_parser.PrintString("moduleid", "INTR::MOD_INTRRP_XIVE_SENDEOI");
        i_parser.PrintString("reasoncode", "INTR::RC_MESSAGE_SEND_ERROR");
        i_parser.PrintString("userdata1", "RC from msg_send command");
        break;

    case 0xF090F:
        i_parser.PrintString("devdesc", "Error unmasking interrupt source");
        i_parser.PrintString("moduleid", "INTR::MOD_INTRRP_UNMASKINTERRUPT");
        i_parser.PrintString("reasoncode", "INTR::RC_XIVE_ESB_WRONG_STATE");
        i_parser.PrintString("userdata1", "Interrupt Source Number");
        i_parser.PrintString("userdata12", "MMIO Read Value for unmasking");
        break;

    case 0xF0105:
        i_parser.PrintString("devdesc", "Interrupt type already registered");
        i_parser.PrintString("moduleid", "INTR::MOD_INTRRP_REGISTERINTERRUPT");
        i_parser.PrintString("reasoncode", "INTR::RC_ALREADY_REGISTERED");
        i_parser.PrintString("userdata1", "XISR");
        i_parser.PrintString("userdata2", "0");
        break;

    case 0xF0709:
        i_parser.PrintString("devdesc", "Error mapping in memory");
        i_parser.PrintString("moduleid", "INTR::MOD_INTR_SYNC_NODES");
        i_parser.PrintString("reasoncode", "INTR::RC_CANNOT_MAP_MEMORY");
        i_parser.PrintString("userdata1", "physical address");
        i_parser.PrintString("userdata2", "Block size requested");
        break;

    case 0xF0708:
        i_parser.PrintString("devdesc", "Error mapping in memory");
        i_parser.PrintString("moduleid", "INTR::MOD_INTR_INIT_MPIPLAREA");
        i_parser.PrintString("reasoncode", "INTR::RC_CANNOT_MAP_MEMORY");
        i_parser.PrintString("userdata1", "physical address");
        i_parser.PrintString("userdata2", "Size");
        break;

    case 0xF070A:
        i_parser.PrintString("devdesc", "Error mapping in memory");
        i_parser.PrintString("moduleid", "INTR::MOD_INTR_SYNC_ADDNODE");
        i_parser.PrintString("reasoncode", "INTR::RC_CANNOT_MAP_MEMORY");
        i_parser.PrintString("userdata1", "physical address");
        i_parser.PrintString("userdata2", "Size");
        break;

    case 0xF0203:
        i_parser.PrintString("devdesc", "Interrupt resource provider not initialized yet.");
        i_parser.PrintString("moduleid", "INTR::MOD_INTR_REGISTER");
        i_parser.PrintString("reasoncode", "INTR::RC_REGISTRY_NOT_READY");
        i_parser.PrintString("userdata1", "Interrupt type to register");
        i_parser.PrintString("userdata2", "0");
        break;

    case 0xF0301:
        i_parser.PrintString("devdesc", "Interrupt resource provider not initialized yet.");
        i_parser.PrintString("moduleid", "INTR::MOD_INTR_ENABLE");
        i_parser.PrintString("reasoncode", "INTR::RC_RP_NOT_INITIALIZED");
        i_parser.PrintString("userdata1", "MSG_INTR_ENABLE");
        i_parser.PrintString("userdata2", "0");
        break;

    case 0xF0302:
        i_parser.PrintString("devdesc", "Interrupt resource provider not initialized yet.");
        i_parser.PrintString("moduleid", "INTR::MOD_INTR_DISABLE");
        i_parser.PrintString("reasoncode", "INTR::RC_RP_NOT_INITIALIZED");
        i_parser.PrintString("userdata1", "MSG_INTR_DISABLE");
        i_parser.PrintString("userdata2", "0");
        break;

    case 0xF030B:
        i_parser.PrintString("devdesc", "Interrupt resource provider not initialized yet.");
        i_parser.PrintString("moduleid", "INTR::MOD_INTR_ADDHBNODE");
        i_parser.PrintString("reasoncode", "INTR::RC_RP_NOT_INITIALIZED");
        i_parser.PrintString("userdata1", "MSG_INTR_ADD_HBNODE");
        i_parser.PrintString("userdata2", "hbNode to add");
        break;

    case 0xF0306:
        i_parser.PrintString("devdesc", "Interrupt resource provider not initialized yet.");
        i_parser.PrintString("moduleid", "INTR::MOD_INTR_ENABLE_PSI_INTR");
        i_parser.PrintString("reasoncode", "INTR::RC_RP_NOT_INITIALIZED");
        i_parser.PrintString("userdata1", "MSG_INTR_ENABLE_PSI_INTR");
        i_parser.PrintString("userdata2", "0");
        break;

    default:
        l_success = false;
        break;
    };
    return l_success;
}

static errl::SrcPlugin g_SrcPlugin(0xF00, SrcDataParse, ERRL_CID_HOSTBOOT);
