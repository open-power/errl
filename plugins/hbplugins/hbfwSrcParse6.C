/*
 * Automatically generated by Hostboot's ./genErrlParsers.pl
 * Do not modify this file in the FSP tree, it is provided by
 * Hostboot and will be overwritten
 *
 * TimeStamp:   Tue May 15 13:26:15 2018
 * Image Id:    hb0515b_1820.920
 *
 */

#include <errlplugins.H>
#include <errlusrparser.H>
#include <srcisrc.H>

static bool SrcDataParse(ErrlUsrParser & i_parser,
                         const SrciSrc & i_src)
{
    uint32_t l_error = (i_src.reasonCode() << 8) + i_src.moduleId();
    bool l_success = true;

    switch(l_error)
    {
    case 0x6310A:
        i_parser.PrintString("devdesc", "Error parsing secure header");
        i_parser.PrintString("moduleid", "SECUREBOOT::MOD_SECURE_CONT_HDR_PARSE");
        i_parser.PrintString("reasoncode", "PNOR::RC_BAD_SECURE_MAGIC_NUM");
        i_parser.PrintString("userdata1", "Actual magic number");
        i_parser.PrintString("userdata2", "Expected magic number");
        break;

    case 0x604D2:
        i_parser.PrintString("devdesc", "SPnorRP::initDaemon> Error from mm_alloc_block");
        i_parser.PrintString("moduleid", "PNOR::MOD_SPNORRP_ALLOCATE_BLOCK");
        i_parser.PrintString("reasoncode", "PNOR::RC_EXTERNAL_ERROR");
        i_parser.PrintString("userdata1", "Requested Address");
        i_parser.PrintString("userdata2", "rc from mm_alloc_block");
        break;

    case 0x604D5:
        i_parser.PrintString("devdesc", "Could not set permissions of the given PNOR section");
        i_parser.PrintString("moduleid", "PNOR::MOD_SPNORRP_SET_PERMISSION");
        i_parser.PrintString("reasoncode", "PNOR::RC_EXTERNAL_ERROR");
        i_parser.PrintString("userdata1", "Requested Address");
        i_parser.PrintString("userdata2", "rc from mm_set_permission");
        break;

    case 0x604D9:
        i_parser.PrintString("devdesc", "mm_remove_pages failed");
        i_parser.PrintString("moduleid", "PNOR::MOD_SPNORRP_REMOVE_PAGES");
        i_parser.PrintString("reasoncode", "PNOR::RC_EXTERNAL_ERROR");
        i_parser.PrintString("userdata1", "virtual address");
        i_parser.PrintString("userdata2[00:31]", "rc from mm_remove_pages");
        i_parser.PrintString("userdata2[32:63]", "The size of memory attempted to remove");
        break;

    case 0x634D4:
        i_parser.PrintString("devdesc", "Cannot verify unsigned PNOR section");
        i_parser.PrintString("moduleid", "PNOR::MOD_SPNORRP_VERIFYSECTIONS");
        i_parser.PrintString("reasoncode", "PNOR::RC_UNSIGNED_PNOR_SECTION");
        i_parser.PrintString("userdata1", "PNOR section requested to verify");
        i_parser.PrintString("userdata2", "0");
        break;

    case 0x639D4:
        i_parser.PrintString("devdesc", "Virtual address of PNOR section is not in Secure Space");
        i_parser.PrintString("moduleid", "PNOR::MOD_SPNORRP_VERIFYSECTIONS");
        i_parser.PrintString("reasoncode", "PNOR::RC_SECURE_VADDR_MISMATCH");
        i_parser.PrintString("userdata1", "PNOR section");
        i_parser.PrintString("userdata2", "PNOR section virtual address");
        break;

    case 0x638D4:
        i_parser.PrintString("devdesc", "Total Container Size smaller than Protected Payload and Header size");
        i_parser.PrintString("moduleid", "PNOR::MOD_SPNORRP_VERIFYSECTIONS");
        i_parser.PrintString("reasoncode", "PNOR::RC_SECURE_TOTAL_SIZE_INVAL");
        i_parser.PrintString("userdata1", "PNOR section");
        i_parser.PrintString("userdata2", "Protected Payload Size plus Header Size");
        break;

    case 0x63AD4:
        i_parser.PrintString("devdesc", "PNOR section size smaller than total container size");
        i_parser.PrintString("moduleid", "PNOR::MOD_SPNORRP_VERIFYSECTIONS");
        i_parser.PrintString("reasoncode", "PNOR::RC_SECURE_SIZE_MISMATCH");
        i_parser.PrintString("userdata1", "PNOR section");
        i_parser.PrintString("userdata2", "Total Container Size");
        break;

    case 0x63CD4:
        i_parser.PrintString("devdesc", "Verified Protected Payload size does not match what was parsed by PnorRp");
        i_parser.PrintString("moduleid", "PNOR::MOD_SPNORRP_VERIFYSECTIONS");
        i_parser.PrintString("reasoncode", "PNOR::RC_SECURE_PRO_SIZE_MISMATCH");
        i_parser.PrintString("userdata1", "PNOR section");
        i_parser.PrintString("userdata2", "Protected Payload Size");
        break;

    case 0x63BD4:
        i_parser.PrintString("devdesc", "Protected Payload Size not Page aligned");
        i_parser.PrintString("moduleid", "PNOR::MOD_SPNORRP_VERIFYSECTIONS");
        i_parser.PrintString("reasoncode", "PNOR::RC_NOT_PAGE_ALIGNED");
        i_parser.PrintString("userdata1", "PNOR section");
        i_parser.PrintString("userdata2", "Protected Payload Size");
        break;

    case 0x637D3:
        i_parser.PrintString("devdesc", "Secure unload of sections that critical to hostboot operation are not allowed.");
        i_parser.PrintString("moduleid", "PNOR::MOD_SPNORRP_WAITFORMESSAGE");
        i_parser.PrintString("reasoncode", "PNOR::RC_SECURE_UNLOAD_DISALLOWED");
        i_parser.PrintString("userdata1", "Section Id");
        break;

    case 0x635D3:
        i_parser.PrintString("devdesc", "Not a loaded section");
        i_parser.PrintString("moduleid", "PNOR::MOD_SPNORRP_WAITFORMESSAGE");
        i_parser.PrintString("reasoncode", "PNOR::RC_NOT_A_LOADED_SECTION");
        i_parser.PrintString("userdata1", "Section attempted to unload");
        break;

    case 0x636D3:
        i_parser.PrintString("devdesc", "Not a supported section");
        i_parser.PrintString("moduleid", "PNOR::MOD_SPNORRP_WAITFORMESSAGE");
        i_parser.PrintString("reasoncode", "PNOR::RC_NOT_A_SUPPORTED_SECTION");
        i_parser.PrintString("userdata1", "Section attempted to unload");
        break;

    case 0x601D3:
        i_parser.PrintString("devdesc", "PnorRP::waitForMessage> Unrecognized message type");
        i_parser.PrintString("moduleid", "PNOR::MOD_SPNORRP_WAITFORMESSAGE");
        i_parser.PrintString("reasoncode", "PNOR::RC_INVALID_MESSAGE_TYPE");
        i_parser.PrintString("userdata1", "Message type");
        i_parser.PrintString("userdata2", "Requested Virtual Address");
        break;

    case 0x604D6:
        i_parser.PrintString("devdesc", "Secure Boot: Failed to securely load or unload signed boot firmware.");
        i_parser.PrintString("moduleid", "MOD_PNORRP_LOADUNLOADSECURESECTION");
        i_parser.PrintString("reasoncode", "RC_EXTERNAL_ERROR");
        i_parser.PrintString("userdata1", "returncode from msg_sendrecv() or msg->data[1]");
        i_parser.PrintString("userdata2[0:31]", "SPNOR message type [LOAD | UNLOAD]");
        i_parser.PrintString("userdata2[32:63]", "Section ID");
        break;

    case 0x62FD7:
        i_parser.PrintString("devdesc", "Hostboot Base and Extend code do not match versions.");
        i_parser.PrintString("moduleid", "MOD_SPNORRP_BASE_EXT_VER_CHK");
        i_parser.PrintString("reasoncode", "RC_BASE_EXT_MISMATCH");
        i_parser.PrintString("userdata1", "First 8 bytes of hash of measured SW signatures");
        i_parser.PrintString("userdata2", "First 8 bytes of hash of stored SW signatures in hash page table");
        break;

    case 0x630D8:
        i_parser.PrintString("devdesc", "Key transition flag not set in outer SBKT container containing new hw keys");
        i_parser.PrintString("moduleid", "MOD_SPNORRP_KEY_TRAN_CHK");
        i_parser.PrintString("reasoncode", "RC_KEY_TRAN_FLAG_UNSET");
        i_parser.PrintString("userdata1", "0");
        i_parser.PrintString("userdata2", "0");
        break;

    case 0x60215:
        i_parser.PrintString("devdesc", "PnorDD::eraseFlash> Address not on erase boundary");
        i_parser.PrintString("moduleid", "PNOR::MOD_PNORDD_ERASEFLASH");
        i_parser.PrintString("reasoncode", "PNOR::RC_INVALID_ADDRESS");
        i_parser.PrintString("userdata1", "Flash Address");
        i_parser.PrintString("userdata2", "Nearest Erase Boundary");
        break;

    case 0x60261:
        i_parser.PrintString("devdesc", "SfcFake::readFlash> Requested access exceeded the bounds of the allocated PNOR space");
        i_parser.PrintString("moduleid", "PNOR::MOD_SFCFAKE_READFLASH");
        i_parser.PrintString("reasoncode", "PNOR::RC_INVALID_ADDRESS");
        i_parser.PrintString("userdata1[0:31]", "PNOR Address");
        i_parser.PrintString("userdata1[32:63]", "Bytes to read");
        i_parser.PrintString("userdata2[0:31]", "<unused>");
        i_parser.PrintString("userdata2[32:63]", "Size of allocated PNOR space");
        break;

    case 0x60262:
        i_parser.PrintString("devdesc", "SfcFake::writeFlash> Requested access exceeded the bounds of the allocated PNOR space");
        i_parser.PrintString("moduleid", "PNOR::MOD_SFCFAKE_WRITEFLASH");
        i_parser.PrintString("reasoncode", "PNOR::RC_INVALID_ADDRESS");
        i_parser.PrintString("userdata1[0:31]", "PNOR Address");
        i_parser.PrintString("userdata1[32:63]", "Bytes to write");
        i_parser.PrintString("userdata2[0:31]", "<unused>");
        i_parser.PrintString("userdata2[32:63]", "Size of allocated PNOR space");
        break;

    case 0x60263:
        i_parser.PrintString("devdesc", "SfcFake::writeFlash> Requested access exceeded the bounds of the allocated PNOR space");
        i_parser.PrintString("moduleid", "PNOR::MOD_SFCFAKE_ERASEFLASH");
        i_parser.PrintString("reasoncode", "PNOR::RC_INVALID_ADDRESS");
        i_parser.PrintString("userdata1[0:31]", "PNOR Address");
        i_parser.PrintString("userdata1[32:63]", "<unused>");
        i_parser.PrintString("userdata2[0:31]", "Bytes in erase block");
        i_parser.PrintString("userdata2[32:63]", "Size of allocated PNOR space");
        break;

    case 0x60764:
        i_parser.PrintString("devdesc", "SfcFake::sendSpiCmd> Function is not supported");
        i_parser.PrintString("moduleid", "PNOR::MOD_SFCFAKE_SENDSPICMD");
        i_parser.PrintString("reasoncode", "PNOR::RC_UNSUPPORTED_OPERATION");
        i_parser.PrintString("userdata1[0:31]", "Op Code");
        i_parser.PrintString("userdata1[32:63]", "Address");
        i_parser.PrintString("userdata2", "<unused>");
        break;

    case 0x62B06:
        i_parser.PrintString("devdesc", "Expected buffer to have contents of TOC, instead was NULL");
        i_parser.PrintString("moduleid", "PNOR::MOD_PNORRP_READTOC");
        i_parser.PrintString("reasoncode", "PNOR::RC_NULL_TOC_BUFFER");
        i_parser.PrintString("userdata1", "Address of toc buffer");
        i_parser.PrintString("userdata2", "Error code");
        break;

    case 0x60C0E:
        i_parser.PrintString("devdesc", "PNOR::validateAltMaster> Fail verifying FFS Header on Master Candidate PNOR TOC0");
        i_parser.PrintString("moduleid", "PNOR::MOD_PNORVALID_MAIN");
        i_parser.PrintString("reasoncode", "PNOR::RC_PARTITION_TABLE_INVALID");
        i_parser.PrintString("userdata1", "Master Candidate Processor Target");
        i_parser.PrintString("userdata2", "<unused>");
        break;

    case 0x60C0F:
        i_parser.PrintString("devdesc", "PNOR::validateMagic> Fail verifying FFS Magic Number in Header on Master");
        i_parser.PrintString("moduleid", "PNOR::MOD_PNORVALID_MAGIC");
        i_parser.PrintString("reasoncode", "PNOR::RC_PARTITION_TABLE_INVALID");
        i_parser.PrintString("userdata1", "Magic Number read");
        i_parser.PrintString("userdata2", "<unused>");
        break;

    case 0x61BB0:
        i_parser.PrintString("devdesc", "invalid section passed to getSectionInfo  or section prohibited by secureboot");
        i_parser.PrintString("moduleid", "PNOR::MOD_RTPNOR_GETSECTIONINFO");
        i_parser.PrintString("reasoncode", "PNOR::RC_RTPNOR_INVALID_SECTION");
        i_parser.PrintString("userdata1", "PNOR::SectionId");
        i_parser.PrintString("userdata2[0:15]", "Inhibited by secureboot");
        i_parser.PrintString("userdata2[16:31]", "Indication of a secure section");
        i_parser.PrintString("userdata2[32:47]", "Indication of a pre-verified section");
        i_parser.PrintString("userdata2[48:63]", "0");
        break;

    case 0x61DB0:
        i_parser.PrintString("devdesc", "section size is zero");
        i_parser.PrintString("moduleid", "PNOR::MOD_RTPNOR_GETSECTIONINFO");
        i_parser.PrintString("reasoncode", "PNOR::RC_SECTION_SIZE_IS_ZERO");
        i_parser.PrintString("userdata1", "PNOR::SectionId");
        break;

    case 0x603B1:
        i_parser.PrintString("devdesc", "invalid section passed to flush");
        i_parser.PrintString("moduleid", "PNOR::MOD_RTPNOR_FLUSH");
        i_parser.PrintString("reasoncode", "PNOR::RC_INVALID_SECTION");
        i_parser.PrintString("userdata1", "PNOR::SectionId");
        break;

    case 0x61DB1:
        i_parser.PrintString("devdesc", "section size is zero");
        i_parser.PrintString("moduleid", "PNOR::MOD_RTPNOR_FLUSH");
        i_parser.PrintString("reasoncode", "PNOR::RC_SECTION_SIZE_IS_ZERO");
        i_parser.PrintString("userdata1", "PNOR::SectionId");
        break;

    case 0x616B2:
        i_parser.PrintString("devdesc", "g_hostInterfaces->pnor_read failed");
        i_parser.PrintString("moduleid", "PNOR::MOD_RTPNOR_READFROMDEVICE");
        i_parser.PrintString("reasoncode", "PNOR::RC_PNOR_READ_FAILED");
        i_parser.PrintString("userdata1[00:31]", "rc returned from pnor_read");
        i_parser.PrintString("userdata1[32:63]", "section ID");
        i_parser.PrintString("userdata2[00:31]", "offset within the section");
        i_parser.PrintString("userdata2[32:63]", "size of data read in bytes");
        break;

    case 0x62AB2:
        i_parser.PrintString("devdesc", "Amount of data read from pnor does not match expected size");
        i_parser.PrintString("moduleid", "PNOR::MOD_RTPNOR_READFROMDEVICE");
        i_parser.PrintString("reasoncode", "PNOR::RC_WRONG_SIZE_FROM_READ");
        i_parser.PrintString("userdata1[00:31]", "section ID");
        i_parser.PrintString("userdata1[32:63]", "requested size of read");
        i_parser.PrintString("userdata2[00:31]", "requested start offset into flash");
        i_parser.PrintString("userdata2[32:63]", "actual amount read");
        break;

    case 0x61FB2:
        i_parser.PrintString("devdesc", "g_hostInterfaces->pnor_read not supported");
        i_parser.PrintString("moduleid", "PNOR::MOD_RTPNOR_READFROMDEVICE");
        i_parser.PrintString("reasoncode", "PNOR::RC_PNOR_READ_NOT_SUPPORTED");
        break;

    case 0x61CB2:
        i_parser.PrintString("devdesc", "UNCORRECTABLE ECC");
        i_parser.PrintString("moduleid", "PNOR::MOD_RTPNOR_READFROMDEVICE");
        i_parser.PrintString("reasoncode", "PNOR::RC_UNCORRECTABLE_ECC");
        break;

    case 0x617B2:
        i_parser.PrintString("devdesc", "error writing corrected data back to PNOR");
        i_parser.PrintString("moduleid", "PNOR::MOD_RTPNOR_READFROMDEVICE");
        i_parser.PrintString("reasoncode", "PNOR::RC_PNOR_WRITE_FAILED");
        i_parser.PrintString("userdata1", "rc returned from pnor_write");
        i_parser.PrintString("userdata2", "Expected size of write");
        break;

    case 0x617B3:
        i_parser.PrintString("devdesc", "g_hostInterfaces->pnor_write failed");
        i_parser.PrintString("moduleid", "PNOR::MOD_RTPNOR_WRITETODEVICE");
        i_parser.PrintString("reasoncode", "PNOR::RC_PNOR_WRITE_FAILED");
        i_parser.PrintString("userdata1[00:31]", "rc returned from pnor_write");
        i_parser.PrintString("userdata1[32:63]", "section ID");
        i_parser.PrintString("userdata2[00:31]", "offset within the section");
        i_parser.PrintString("userdata2[32:63]", "size of data written in bytes");
        break;

    case 0x620B3:
        i_parser.PrintString("devdesc", "g_hostInterfaces->pnor_write not supported");
        i_parser.PrintString("moduleid", "PNOR::MOD_RTPNOR_WRITETODEVICE");
        i_parser.PrintString("reasoncode", "PNOR::RC_PNOR_WRITE_NOT_SUPPORTED");
        break;

    case 0x627B4:
        i_parser.PrintString("devdesc", "getSideInfo> Side not supported");
        i_parser.PrintString("moduleid", "PNOR::MOD_RTPNOR_GETSIDEINFO");
        i_parser.PrintString("reasoncode", "PNOR::RC_INVALID_PNOR_SIDE");
        i_parser.PrintString("userdata1", "Requested SIDE");
        i_parser.PrintString("userdata2", "0");
        break;

    case 0x61E0A:
        i_parser.PrintString("devdesc", "mm_remove_pages failed");
        i_parser.PrintString("moduleid", "PNOR::MOD_PNORRP_FLUSH");
        i_parser.PrintString("reasoncode", "PNOR::RC_MM_REMOVE_PAGES_FAILED");
        i_parser.PrintString("userdata1", "section Id");
        i_parser.PrintString("userdata2", "RC");
        break;

    case 0x60909:
        i_parser.PrintString("devdesc", "PNOR startup task returned an error.");
        i_parser.PrintString("moduleid", "PNOR::MOD_PNORRP_DIDSTARTUPFAIL");
        i_parser.PrintString("reasoncode", "PNOR::RC_BAD_STARTUP_RC");
        i_parser.PrintString("userdata1", "return code pnorrp");
        i_parser.PrintString("userdata2", "return code spnorrp");
        break;

    case 0x60405:
        i_parser.PrintString("devdesc", "PnorRP::initDaemon> Error from mm_alloc_block");
        i_parser.PrintString("moduleid", "PNOR::MOD_PNORRP_INITDAEMON");
        i_parser.PrintString("reasoncode", "PNOR::RC_EXTERNAL_ERROR");
        i_parser.PrintString("userdata1", "Requested Address");
        i_parser.PrintString("userdata2", "rc from mm_alloc_block");
        break;

    case 0x6270D:
        i_parser.PrintString("devdesc", "PnorRP::getSideInfo> Side not supported");
        i_parser.PrintString("moduleid", "PNOR::MOD_PNORRP_GETSIDEINFO");
        i_parser.PrintString("reasoncode", "PNOR::RC_INVALID_PNOR_SIDE");
        i_parser.PrintString("userdata1", "Requested SIDE");
        i_parser.PrintString("userdata2", "0");
        break;

    case 0x60503:
        i_parser.PrintString("devdesc", "PnorRP::getSectionInfo> RP not properly initialized");
        i_parser.PrintString("moduleid", "PNOR::MOD_PNORRP_GETSECTIONINFO");
        i_parser.PrintString("reasoncode", "PNOR::RC_STARTUP_FAIL");
        i_parser.PrintString("userdata1", "Requested Section");
        i_parser.PrintString("userdata2", "Startup RC");
        break;

    case 0x60303:
        i_parser.PrintString("devdesc", "PnorRP::getSectionInfo> Invalid Address for read/write or prohibited by secureboot");
        i_parser.PrintString("moduleid", "PNOR::MOD_PNORRP_GETSECTIONINFO");
        i_parser.PrintString("reasoncode", "PNOR::RC_INVALID_SECTION");
        i_parser.PrintString("userdata1", "Size of section");
        i_parser.PrintString("userdata2[0:7]", "TOC used");
        i_parser.PrintString("userdata2[8:15]", "Inhibited flag");
        i_parser.PrintString("userdata2[16:23]", "Requested Section");
        break;

    case 0x61D03:
        i_parser.PrintString("devdesc", "Protected Payload Size is 0");
        i_parser.PrintString("moduleid", "PNOR::MOD_PNORRP_GETSECTIONINFO");
        i_parser.PrintString("reasoncode", "PNOR::RC_SECTION_SIZE_IS_ZERO");
        i_parser.PrintString("userdata1", "PNOR section");
        i_parser.PrintString("userdata2", "Section's secure flag");
        break;

    case 0x6290E:
        i_parser.PrintString("devdesc", "PnorRP::setSideInfo> No valid TOCs found");
        i_parser.PrintString("moduleid", "PNOR::MOD_PNORRP_SETSIDEINFO");
        i_parser.PrintString("reasoncode", "PNOR::RC_INVALID_TOC");
        i_parser.PrintString("userdata1", "Side Id");
        i_parser.PrintString("userdata2[00:31]", "primary toc");
        i_parser.PrintString("userdata2[32:63]", "backup toc");
        break;

    case 0x60101:
        i_parser.PrintString("devdesc", "PnorRP::waitForMessage> Unrecognized message type");
        i_parser.PrintString("moduleid", "PNOR::MOD_PNORRP_WAITFORMESSAGE");
        i_parser.PrintString("reasoncode", "PNOR::RC_INVALID_MESSAGE_TYPE");
        i_parser.PrintString("userdata1", "Message type");
        i_parser.PrintString("userdata2", "Requested Virtual Address");
        break;

    case 0x60601:
        i_parser.PrintString("devdesc", "PnorRP::waitForMessage> Unrecognized message type");
        i_parser.PrintString("moduleid", "PNOR::MOD_PNORRP_WAITFORMESSAGE");
        i_parser.PrintString("reasoncode", "PNOR::RC_INVALID_ASYNC_MESSAGE");
        i_parser.PrintString("userdata1", "Message type");
        i_parser.PrintString("userdata2", "Requested Virtual Address");
        break;

    case 0x60201:
        i_parser.PrintString("devdesc", "PnorRP::computeDeviceAddr> Virtual Address outside known PNOR range");
        i_parser.PrintString("moduleid", "PNOR::MOD_PNORRP_WAITFORMESSAGE");
        i_parser.PrintString("reasoncode", "PNOR::RC_INVALID_ADDRESS");
        i_parser.PrintString("userdata1", "Virtual Address");
        i_parser.PrintString("userdata2", "Base PNOR Address");
        break;

    case 0x60204:
        i_parser.PrintString("devdesc", "PnorRP::computeSection> Invalid Address");
        i_parser.PrintString("moduleid", "PNOR::MOD_PNORRP_COMPUTESECTION");
        i_parser.PrintString("reasoncode", "PNOR::RC_INVALID_ADDRESS");
        i_parser.PrintString("userdata1", "Requested Virtual Address");
        i_parser.PrintString("userdata2", "<unused>");
        break;

    case 0x6210B:
        i_parser.PrintString("devdesc", "Non ECC protected section is passed to fixECC");
        i_parser.PrintString("moduleid", "PNOR::MOD_PNORRP_FIXECC");
        i_parser.PrintString("reasoncode", "PNOR::RC_NON_ECC_PROTECTED_SECTION");
        i_parser.PrintString("userdata1", "Section ID");
        i_parser.PrintString("userdata2", "0");
        break;

    case 0x63D06:
        i_parser.PrintString("devdesc", "Could not set permissions of the given PNOR section to READ_ONLY");
        i_parser.PrintString("moduleid", "PNOR::MOD_PNORRP_READTOC");
        i_parser.PrintString("reasoncode", "PNOR::RC_READ_ONLY_PERM_FAIL");
        i_parser.PrintString("userdata1", "PNOR section id");
        i_parser.PrintString("userdata2", "PNOR section vaddr");
        break;

    case 0x62306:
        i_parser.PrintString("devdesc", "Could not set permissions of the given PNOR section to WRITABLE/WRITE_TRACKED");
        i_parser.PrintString("moduleid", "PNOR::MOD_PNORRP_READTOC");
        i_parser.PrintString("reasoncode", "PNOR::RC_WRITE_TRACKED_PERM_FAIL");
        i_parser.PrintString("userdata1", "PNOR section id");
        i_parser.PrintString("userdata2", "PNOR section vaddr");
        break;

    case 0x615E0:
        i_parser.PrintString("devdesc", "astMbox::doMessage> Timeout waiting for message response");
        i_parser.PrintString("moduleid", "PNOR::MOD_ASTMBOXDD_DO_MESSAGE");
        i_parser.PrintString("reasoncode", "PNOR::RC_SFC_TIMEOUT");
        i_parser.PrintString("userdata1[48:55]", "mbox status 1 reg");
        i_parser.PrintString("userdata1[56:63]", "mbox flag reg");
        break;

    case 0x632E0:
        i_parser.PrintString("devdesc", "astMbox::doMessage> Timeout waiting for message response");
        i_parser.PrintString("moduleid", "PNOR::MOD_ASTMBOXDD_DO_MESSAGE");
        i_parser.PrintString("reasoncode", "PNOR::RC_MBOX_BAD_SEQUENCE");
        i_parser.PrintString("userdata1[48:55]", "mbox status 1 reg");
        i_parser.PrintString("userdata1[56:63]", "mbox flag reg");
        i_parser.PrintString("userdata2[32:39]", "original command code");
        i_parser.PrintString("userdata2[40:47]", "response command code");
        i_parser.PrintString("userdata2[48:55]", "sequence wanted");
        i_parser.PrintString("userdata2[56:63]", "sequence obtained");
        break;

    case 0x633E0:
        i_parser.PrintString("devdesc", "astMbox::doMessage> Timeout waiting for message response");
        i_parser.PrintString("moduleid", "PNOR::MOD_ASTMBOXDD_DO_MESSAGE");
        i_parser.PrintString("reasoncode", "PNOR::RC_MBOX_ERROR_STATUS");
        i_parser.PrintString("userdata1[48:55]", "mbox status 1 reg");
        i_parser.PrintString("userdata1[56:63]", "mbox flag reg");
        i_parser.PrintString("userdata2[32:39]", "original command code");
        i_parser.PrintString("userdata2[40:47]", "response command code");
        i_parser.PrintString("userdata2[48:55]", "sequence number");
        i_parser.PrintString("userdata2[56:63]", "status code");
        break;

    case 0x608E0:
        i_parser.PrintString("devdesc", "astMbox::doMessage> LPC Error communicating                            with the mailbox");
        i_parser.PrintString("moduleid", "PNOR::MOD_ASTMBOXDD_DO_MESSAGE");
        i_parser.PrintString("reasoncode", "PNOR::RC_LPC_ERROR");
        break;

    case 0x61480:
        i_parser.PrintString("devdesc", "SfcAST2X00::enableWriteMode> Unable to enable write mode on the PNOR flash");
        i_parser.PrintString("moduleid", "PNOR::MOD_SFCAST2X00_ENABLEWRITEMODE");
        i_parser.PrintString("reasoncode", "PNOR::RC_CANNOT_ENABLE_WRITES");
        i_parser.PrintString("userdata1[24:31]", "Output from RDSR");
        i_parser.PrintString("userdata1[32:63]", "NOR chip id");
        i_parser.PrintString("userdata2", "<unused>");
        break;

    case 0x61583:
        i_parser.PrintString("devdesc", "SfcAST2X00::pollOpComplete> Timeout during write or erase operation");
        i_parser.PrintString("moduleid", "PNOR::MOD_SFCAST2X00_POLLOPCOMPLETE");
        i_parser.PrintString("reasoncode", "PNOR::RC_SFC_TIMEOUT");
        i_parser.PrintString("userdata1[0:31]", "NOR Flash Chip ID");
        i_parser.PrintString("userdata1[32:63]", "Total poll time (ns)");
        i_parser.PrintString("userdata2[56:63]", "Output of RDSR command");
        break;

    case 0x61543:
        i_parser.PrintString("devdesc", "SfcIBM::pollOpComplete> Error or timeout from SFC Status Register");
        i_parser.PrintString("moduleid", "PNOR::MOD_SFCIBM_POLLOPCOMPLETE");
        i_parser.PrintString("reasoncode", "PNOR::RC_SFC_TIMEOUT");
        i_parser.PrintString("userdata1[0:31]", "NOR Flash Chip ID");
        i_parser.PrintString("userdata1[32:63]", "Total poll time (ns)");
        i_parser.PrintString("userdata2[0:31]", "SFC Status Register");
        break;

    case 0x60245:
        i_parser.PrintString("devdesc", "PnorDD::eraseFlash> Address not on erase boundary");
        i_parser.PrintString("moduleid", "PNOR::MOD_SFCIBM_ERASEFLASH");
        i_parser.PrintString("reasoncode", "PNOR::RC_INVALID_ADDRESS");
        i_parser.PrintString("userdata1", "Flash address being erased");
        i_parser.PrintString("userdata2", "Nearest Erase Boundary");
        break;

    case 0x61046:
        i_parser.PrintString("devdesc", "SfcIBM::checkForErrors> Error(s) found in SFC and/or LPC Slave Status Registers");
        i_parser.PrintString("moduleid", "PNOR::MOD_SFCIBM_CHECKFORERRORS");
        i_parser.PrintString("reasoncode", "PNOR::RC_ERROR_IN_STATUS_REG");
        i_parser.PrintString("userdata1[0:31]", "SFC Status Register");
        i_parser.PrintString("userdata1[32:63]", "LPC Slave Status Register");
        i_parser.PrintString("userdata2", "Reset Level");
        break;

    case 0x60747:
        i_parser.PrintString("devdesc", "SfcIBM::hwReset> Unsupported Reset Level requested");
        i_parser.PrintString("moduleid", "PNOR::MOD_SFCIBM_HWRESET");
        i_parser.PrintString("reasoncode", "PNOR::RC_UNSUPPORTED_OPERATION");
        i_parser.PrintString("userdata1", "Unsupported Reset Level Parameter");
        i_parser.PrintString("userdata2", "<unused>");
        break;

    case 0x60BA0:
        i_parser.PrintString("devdesc", "micronFlagStatus> Error or timeout from Micron Flag Status Register");
        i_parser.PrintString("moduleid", "PNOR::MOD_NORMICRON_MICRONFLAGSTATUS");
        i_parser.PrintString("reasoncode", "PNOR::RC_MICRON_INCOMPLETE");
        i_parser.PrintString("userdata1[0:31]", "Micron Flag status register");
        i_parser.PrintString("userdata2", "NOR Flash Chip ID");
        break;

    default:
        l_success = false;
        break;
    };
    return l_success;
}

static errl::SrcPlugin g_SrcPlugin(0x600, SrcDataParse, ERRL_CID_HOSTBOOT);
