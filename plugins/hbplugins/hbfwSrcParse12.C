/*
 * Automatically generated by Hostboot's ./genErrlParsers.pl
 * Do not modify this file in the FSP tree, it is provided by
 * Hostboot and will be overwritten
 *
 * TimeStamp:   Tue May 15 13:26:15 2018
 * Image Id:    hb0515b_1820.920
 *
 */

#include <errlplugins.H>
#include <errlusrparser.H>
#include <srcisrc.H>

static bool SrcDataParse(ErrlUsrParser & i_parser,
                         const SrciSrc & i_src)
{
    uint32_t l_error = (i_src.reasonCode() << 8) + i_src.moduleId();
    bool l_success = true;

    switch(l_error)
    {
    case 0x120401:
        i_parser.PrintString("devdesc", "Cannot unmap the source table section");
        i_parser.PrintString("moduleid", "DUMP::DUMP_COLLECT");
        i_parser.PrintString("reasoncode", "DUMP::DUMP_CANNOT_UNMAP_SRC");
        i_parser.PrintString("userdata1", "VA address of the MDST to unmap");
        i_parser.PrintString("userdata2", "rc value from unmap");
        break;

    case 0x120501:
        i_parser.PrintString("devdesc", "Cannot unmap the source table section");
        i_parser.PrintString("moduleid", "DUMP::DUMP_COLLECT");
        i_parser.PrintString("reasoncode", "DUMP::DUMP_CANNOT_UNMAP_DEST");
        i_parser.PrintString("userdata1", "VA address of the MDDT to unmap");
        i_parser.PrintString("userdata2", "rc value from unmap");
        break;

    case 0x120A01:
        i_parser.PrintString("devdesc", "MDDT table is not big enough to hold all src entries");
        i_parser.PrintString("moduleid", "DUMP::DUMP_COLLECT");
        i_parser.PrintString("reasoncode", "DUMP::DUMP_MDDT_INSUFFICIENT_ENTRIES");
        i_parser.PrintString("userdata1", "Source Entires bytes left to copy");
        i_parser.PrintString("userdata2", "Index into the MDST table");
        break;

    case 0x120901:
        i_parser.PrintString("devdesc", "MDDT table is not big enough to hold all src entries");
        i_parser.PrintString("moduleid", "DUMP::DUMP_COLLECT");
        i_parser.PrintString("reasoncode", "DUMP::DUMP_MDDT_INSUFFICIENT_SPACE");
        i_parser.PrintString("userdata1", "Source Entires bytes left to copy");
        i_parser.PrintString("userdata2", "Index into the MDST table");
        break;

    case 0x120701:
        i_parser.PrintString("devdesc", "MDRT table is not big enough to hold all entries");
        i_parser.PrintString("moduleid", "DUMP::DUMP_COLLECT");
        i_parser.PrintString("reasoncode", "DUMP::DUMP_MDRT_INSUFFICIENT_SPACE");
        i_parser.PrintString("userdata1", "Index into the MDRT");
        i_parser.PrintString("userdata2", "max entries allowed given space allocated");
        break;

    case 0x120B01:
        i_parser.PrintString("devdesc", "MDST table entry with page aligned is greater than 32GB");
        i_parser.PrintString("moduleid", "DUMP::DUMP_COLLECT");
        i_parser.PrintString("reasoncode", "DUMP::DUMP_MDST_INVALID_TABLE_SIZE");
        i_parser.PrintString("userdata1", "Size of Source Table Entry");
        i_parser.PrintString("userdata2", "Size of Page Aligned Source Table Entry");
        break;

    case 0x120C01:
        i_parser.PrintString("devdesc", "MDDT table entry with page aligned is greater than 32GB");
        i_parser.PrintString("moduleid", "DUMP::DUMP_COLLECT");
        i_parser.PrintString("reasoncode", "DUMP::DUMP_MDDT_INVALID_TABLE_SIZE");
        i_parser.PrintString("userdata1", "Size of Destination Table Entry");
        i_parser.PrintString("userdata2", "Size of Page Aligned Destination Table Entry");
        break;

    case 0x120201:
        i_parser.PrintString("devdesc", "Invalid address and size returned from HDAT");
        i_parser.PrintString("moduleid", "DUMP::DUMP_COLLECT");
        i_parser.PrintString("reasoncode", "DUMP::DUMP_NO_HDAT_ADDR");
        i_parser.PrintString("userdata1", "Address returned");
        i_parser.PrintString("userdata2", "Table type Requested");
        break;

    case 0x120202:
        i_parser.PrintString("devdesc", "Invalid address and size returned from HDAT");
        i_parser.PrintString("moduleid", "DUMP::DUMP_SEND_MBOX_MSG");
        i_parser.PrintString("reasoncode", "DUMP::DUMP_NO_HDAT_ADDR");
        i_parser.PrintString("userdata1", "Address returned");
        i_parser.PrintString("userdata2", "Table type Requested");
        break;

    default:
        l_success = false;
        break;
    };
    return l_success;
}

static errl::SrcPlugin g_SrcPlugin(0x1200, SrcDataParse, ERRL_CID_HOSTBOOT);
