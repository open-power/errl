/*
 * Automatically generated by Hostboot's ./genErrlParsers.pl
 * Do not modify this file in the FSP tree, it is provided by
 * Hostboot and will be overwritten
 *
 * TimeStamp:   Thu Apr 12 08:28:51 2018
 * Image Id:    hb0412a_1815.861
 *
 */

#include <errlplugins.H>
#include <errlusrparser.H>
#include <srcisrc.H>

static bool SrcDataParse(ErrlUsrParser & i_parser,
                         const SrciSrc & i_src)
{
    uint32_t l_error = (i_src.reasonCode() << 8) + i_src.moduleId();
    bool l_success = true;

    switch(l_error)
    {
    case 0xF0507:
        i_parser.PrintString("devdesc", "Unsupported ISN Requested");
        i_parser.PrintString("moduleid", "INTR::MOD_INTR_INIT_XIVR");
        i_parser.PrintString("reasoncode", "INTR::RC_BAD_ISN");
        i_parser.PrintString("userdata1", "Interrupt type to register");
        i_parser.PrintString("userdata2", "0");
        break;

    case 0xF0105:
        i_parser.PrintString("devdesc", "Interrupt type already registered");
        i_parser.PrintString("moduleid", "INTR::MOD_INTRRP_REGISTERINTERRUPT");
        i_parser.PrintString("reasoncode", "INTR::RC_ALREADY_REGISTERED");
        i_parser.PrintString("userdata1", "XISR");
        i_parser.PrintString("userdata2", "0");
        break;

    case 0xF0404:
        i_parser.PrintString("devdesc", "The virtual address is not a valid IO address");
        i_parser.PrintString("moduleid", "INTR::MOD_INTRRP_CHECKADDRESS");
        i_parser.PrintString("reasoncode", "INTR::RC_BAD_VIRTUAL_IO_ADDRESS");
        i_parser.PrintString("userdata1", "The bad virtual address");
        i_parser.PrintString("userdata2", "0");
        break;

    case 0xF0709:
        i_parser.PrintString("devdesc", "Error mapping in memory");
        i_parser.PrintString("moduleid", "INTR::MOD_INTR_SYNC_NODES");
        i_parser.PrintString("reasoncode", "INTR::RC_CANNOT_MAP_MEMORY");
        i_parser.PrintString("userdata1", "physical address");
        i_parser.PrintString("userdata2", "Block size requested");
        break;

    case 0xF0708:
        i_parser.PrintString("devdesc", "Error mapping in memory");
        i_parser.PrintString("moduleid", "INTR::MOD_INTR_INIT_MPIPLAREA");
        i_parser.PrintString("reasoncode", "INTR::RC_CANNOT_MAP_MEMORY");
        i_parser.PrintString("userdata1", "physical address");
        i_parser.PrintString("userdata2", "Size");
        break;

    case 0xF070A:
        i_parser.PrintString("devdesc", "Error mapping in memory");
        i_parser.PrintString("moduleid", "INTR::MOD_INTR_SYNC_ADDNODE");
        i_parser.PrintString("reasoncode", "INTR::RC_CANNOT_MAP_MEMORY");
        i_parser.PrintString("userdata1", "physical address");
        i_parser.PrintString("userdata2", "Size");
        break;

    case 0xF070C:
        i_parser.PrintString("devdesc", "Error mapping in memory");
        i_parser.PrintString("moduleid", "INTR::MOD_INTR_EXTRACTNODEINFO");
        i_parser.PrintString("reasoncode", "INTR::RC_CANNOT_MAP_MEMORY");
        i_parser.PrintString("userdata1", "physical address");
        i_parser.PrintString("userdata2", "Size");
        break;

    case 0xF0203:
        i_parser.PrintString("devdesc", "Interrupt resource provider not initialized yet.");
        i_parser.PrintString("moduleid", "INTR::MOD_INTR_REGISTER");
        i_parser.PrintString("reasoncode", "INTR::RC_REGISTRY_NOT_READY");
        i_parser.PrintString("userdata1", "Interrupt type to register");
        i_parser.PrintString("userdata2", "0");
        break;

    case 0xF0301:
        i_parser.PrintString("devdesc", "Interrupt resource provider not initialized yet.");
        i_parser.PrintString("moduleid", "INTR::MOD_INTR_ENABLE");
        i_parser.PrintString("reasoncode", "INTR::RC_RP_NOT_INITIALIZED");
        i_parser.PrintString("userdata1", "MSG_INTR_ENABLE");
        i_parser.PrintString("userdata2", "0");
        break;

    case 0xF0302:
        i_parser.PrintString("devdesc", "Interrupt resource provider not initialized yet.");
        i_parser.PrintString("moduleid", "INTR::MOD_INTR_DISABLE");
        i_parser.PrintString("reasoncode", "INTR::RC_RP_NOT_INITIALIZED");
        i_parser.PrintString("userdata1", "MSG_INTR_DISABLE");
        i_parser.PrintString("userdata2", "0");
        break;

    case 0xF0306:
        i_parser.PrintString("devdesc", "Interrupt resource provider not initialized yet.");
        i_parser.PrintString("moduleid", "INTR::MOD_INTR_ENABLE_PSI_INTR");
        i_parser.PrintString("reasoncode", "INTR::RC_RP_NOT_INITIALIZED");
        i_parser.PrintString("userdata1", "MSG_INTR_ENABLE_PSI_INTR");
        i_parser.PrintString("userdata2", "0");
        break;

    case 0xF030B:
        i_parser.PrintString("devdesc", "Interrupt resource provider not initialized yet.");
        i_parser.PrintString("moduleid", "INTR::MOD_INTR_ADDHBNODE");
        i_parser.PrintString("reasoncode", "INTR::RC_RP_NOT_INITIALIZED");
        i_parser.PrintString("userdata1", "MSG_INTR_ADD_HBNODE");
        i_parser.PrintString("userdata2", "hbNode to add");
        break;

    default:
        l_success = false;
        break;
    };
    return l_success;
}

static errl::SrcPlugin g_SrcPlugin(0xF00, SrcDataParse, ERRL_CID_HOSTBOOT);
