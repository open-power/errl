/*
 * Automatically generated by Hostboot's ./genErrlParsers.pl
 * Do not modify this file in the FSP tree, it is provided by
 * Hostboot and will be overwritten
 *
 * TimeStamp:   Thu Apr 12 08:28:51 2018
 * Image Id:    hb0412a_1815.861
 *
 */

#include <errlplugins.H>
#include <errlusrparser.H>
#include <srcisrc.H>

static bool SrcDataParse(ErrlUsrParser & i_parser,
                         const SrciSrc & i_src)
{
    uint32_t l_error = (i_src.reasonCode() << 8) + i_src.moduleId();
    bool l_success = true;

    switch(l_error)
    {
    case 0xC8182:
        i_parser.PrintString("devdesc", "Attempt to create a GARD Record for a target that is not GARDable (not DECONFIG_GARDABLE or not present)");
        i_parser.PrintString("moduleid", "HWAS::MOD_PLAT_DECONFIG_GARD");
        i_parser.PrintString("reasoncode", "HWAS::RC_TARGET_NOT_GARDABLE");
        i_parser.PrintString("userdata1", "HUID of input target // GARD errlog EID");
        i_parser.PrintString("userdata2", "ATTR_DECONFIG_GARDABLE // ATTR_HWAS_STATE.present");
        break;

    case 0xC8282:
        i_parser.PrintString("devdesc", "Attempt to create a GARD Record and the GARD Repository is full");
        i_parser.PrintString("moduleid", "HWAS::MOD_PLAT_DECONFIG_GARD");
        i_parser.PrintString("reasoncode", "HWAS::RC_GARD_REPOSITORY_FULL");
        i_parser.PrintString("userdata1", "HUID of input target // GARD errlog EID");
        break;

    case 0xC0B03:
        i_parser.PrintString("devdesc", "checkCriticalResources found a critical resource to be deconfigured");
        i_parser.PrintString("moduleid", "MOD_CHECK_MIN_HW");
        i_parser.PrintString("reasoncode", "RC_SYSAVAIL_MISSING_CRITICAL_RESOURCE");
        i_parser.PrintString("userdata1[00:31]", "Number of critical resources");
        i_parser.PrintString("userdata1[32:63]", "HUID of first critical resource found");
        i_parser.PrintString("userdata2[00:31]", "HUID of second critical resource found, if present");
        i_parser.PrintString("userdata2[32:63]", "HUID of third critical resource found, if present");
        break;

    case 0xC0803:
        i_parser.PrintString("devdesc", "checkMinimumHardware found no functional nodes on the system");
        i_parser.PrintString("moduleid", "MOD_CHECK_MIN_HW");
        i_parser.PrintString("reasoncode", "RC_SYSAVAIL_NO_NODES_FUNC");
        break;

    case 0xC0703:
        i_parser.PrintString("devdesc", "checkMinimumHardware found no functional master processor on this node");
        i_parser.PrintString("moduleid", "MOD_CHECK_MIN_HW");
        i_parser.PrintString("reasoncode", "RC_SYSAVAIL_NO_PROCS_FUNC");
        i_parser.PrintString("userdata1[00:31]", "HUID of node");
        i_parser.PrintString("userdata2[00:31]", "number of present procs");
        i_parser.PrintString("userdata2[32:63]", "number of present functional non-master procs");
        break;

    case 0xC0503:
        i_parser.PrintString("devdesc", "checkMinimumHardware found no functional processor cores on the master proc");
        i_parser.PrintString("moduleid", "MOD_CHECK_MIN_HW");
        i_parser.PrintString("reasoncode", "RC_SYSAVAIL_NO_CORES_FUNC");
        i_parser.PrintString("userdata1[00:31]", "HUID of node");
        i_parser.PrintString("userdata1[32:63]", "HUID of master proc");
        i_parser.PrintString("userdata2[00:31]", "number of present, non-functional cores");
        break;

    case 0xC0603:
        i_parser.PrintString("devdesc", "checkMinimumHardware found no functional dimm cards.");
        i_parser.PrintString("moduleid", "MOD_CHECK_MIN_HW");
        i_parser.PrintString("reasoncode", "RC_SYSAVAIL_NO_MEMORY_FUNC");
        i_parser.PrintString("userdata1[00:31]", "HUID of node");
        i_parser.PrintString("userdata2[00:31]", "number of present, non-functional dimms");
        break;

    case 0xC0903:
        i_parser.PrintString("devdesc", "checkMinimumHardware found no functional membufs");
        i_parser.PrintString("moduleid", "MOD_CHECK_MIN_HW");
        i_parser.PrintString("reasoncode", "RC_SYSAVAIL_NO_MEMBUFS_FUNC");
        i_parser.PrintString("userdata1[00:31]", "HUID of node");
        i_parser.PrintString("userdata2[00:31]", "number of present nonfunctional membufs");
        break;

    case 0xC0403:
        i_parser.PrintString("devdesc", "Insufficient hardware to continue.");
        i_parser.PrintString("moduleid", "MOD_CHECK_MIN_HW");
        i_parser.PrintString("reasoncode", "RC_SYSAVAIL_INSUFFICIENT_HW");
        break;

    case 0xC0302:
        i_parser.PrintString("devdesc", "Invalid target encountered in processing of HW callout");
        i_parser.PrintString("moduleid", "HWAS::MOD_PROCESS_CALLOUT");
        i_parser.PrintString("reasoncode", "HWAS::RC_INVALID_TARGET");
        i_parser.PrintString("userdata1", "callout errlog PLID");
        break;

    case 0xC0A04:
        i_parser.PrintString("devdesc", "A gard record was not applied due to a lack of resources.");
        i_parser.PrintString("moduleid", "MOD_DECONFIG_TARGETS_FROM_GARD");
        i_parser.PrintString("reasoncode", "RC_RESOURCE_RECOVERED");
        i_parser.PrintString("userdata1[00:31]", "HUID the resource");
        i_parser.PrintString("userdata2[00:31]", "EID from the gard record.");
        break;

    case 0xC0101:
        i_parser.PrintString("devdesc", "Attempt to deconfigure a target that is not deconfigurable or not present.");
        i_parser.PrintString("moduleid", "HWAS::MOD_DECONFIG_GARD");
        i_parser.PrintString("reasoncode", "HWAS::RC_TARGET_NOT_DECONFIGURABLE");
        i_parser.PrintString("userdata1[00:31]", "HUID of input target");
        i_parser.PrintString("userdata1[32:63]", "GARD errlog EID");
        i_parser.PrintString("userdata2[00:31]", "ATTR_DECONFIG_GARDABLE");
        i_parser.PrintString("userdata2[32:63]", "ATTR_HWAS_STATE.present");
        break;

    case 0xC8481:
        i_parser.PrintString("devdesc", "HWAS host_gard: no masterCore found");
        i_parser.PrintString("moduleid", "MOD_HOST_GARD");
        i_parser.PrintString("reasoncode", "RC_MASTER_CORE_NULL");
        i_parser.PrintString("userdata1", "0");
        i_parser.PrintString("userdata2", "0");
        break;

    case 0xC8383:
        i_parser.PrintString("devdesc", "platReadIDEC> Invalid chipid from hardware (all FFs)");
        i_parser.PrintString("moduleid", "HWAS::MOD_PLAT_READIDEC");
        i_parser.PrintString("reasoncode", "HWAS::RC_BAD_CHIPID");
        i_parser.PrintString("userdata1", "Target HUID");
        i_parser.PrintString("userdata2", "<unused>");
        break;

    default:
        l_success = false;
        break;
    };
    return l_success;
}

static errl::SrcPlugin g_SrcPlugin(0xC00, SrcDataParse, ERRL_CID_HOSTBOOT);
