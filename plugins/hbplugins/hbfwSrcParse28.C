/*
 * Automatically generated by Hostboot's ./genErrlParsers.pl
 * Do not modify this file in the FSP tree, it is provided by
 * Hostboot and will be overwritten
 *
 * TimeStamp:   Tue May 15 13:26:15 2018
 * Image Id:    hb0515b_1820.920
 *
 */

#include <errlplugins.H>
#include <errlusrparser.H>
#include <srcisrc.H>

static bool SrcDataParse(ErrlUsrParser & i_parser,
                         const SrciSrc & i_src)
{
    uint32_t l_error = (i_src.reasonCode() << 8) + i_src.moduleId();
    bool l_success = true;

    switch(l_error)
    {
    case 0x281002:
        i_parser.PrintString("devdesc", "Timeout waiting for upstream FIFO to have room to write");
        i_parser.PrintString("moduleid", "SBEIO_FIFO");
        i_parser.PrintString("reasoncode", "SBEIO_FIFO_UPSTREAM_TIMEOUT");
        i_parser.PrintString("userdata1", "Timeout in NS");
        break;

    case 0x281102:
        i_parser.PrintString("devdesc", "EOT not received before downstream buffer full.");
        i_parser.PrintString("moduleid", "SBEIO_FIFO");
        i_parser.PrintString("reasoncode", "SBEIO_FIFO_NO_DOWNSTREAM_EOT");
        i_parser.PrintString("userdata1", "FIFO command class and command");
        i_parser.PrintString("userdata2", "Response buffer size");
        break;

    case 0x281202:
        i_parser.PrintString("devdesc", "The distance to the status header is not within the response buffer.");
        i_parser.PrintString("moduleid", "SBEIO_FIFO");
        i_parser.PrintString("reasoncode", "SBEIO_FIFO_INVALID_STATUS_DISTANCE");
        i_parser.PrintString("userdata1", "FIFO command class and command");
        i_parser.PrintString("userdata2[0:15]", "Distance to status in words");
        i_parser.PrintString("userdata2[16:31]", "Bytes received");
        i_parser.PrintString("userdata2[32:63]", "Response buffer size");
        break;

    case 0x281302:
        i_parser.PrintString("devdesc", "Status header does not start with magic number or non-zero primary or secondary status");
        i_parser.PrintString("moduleid", "SBEIO_FIFO");
        i_parser.PrintString("reasoncode", "SBEIO_FIFO_RESPONSE_ERROR");
        i_parser.PrintString("userdata1", "FIFO command class and command");
        i_parser.PrintString("userdata2[0:31]", "Should be magic value 0xC0DE");
        i_parser.PrintString("userdata1[32:47]", "Primary Status");
        i_parser.PrintString("userdata1[48:63]", "Secondary Status");
        break;

    case 0x281402:
        i_parser.PrintString("devdesc", "Timeout waiting for downstream FIFO to have data to receive");
        i_parser.PrintString("moduleid", "SBEIO_FIFO");
        i_parser.PrintString("reasoncode", "SBEIO_FIFO_DOWNSTREAM_TIMEOUT");
        i_parser.PrintString("userdata1", "Timeout in NS");
        i_parser.PrintString("userdata2", "FIFO Status");
        break;

    case 0x280301:
        i_parser.PrintString("devdesc", "SBE PSU device driver not ready to receive next command.");
        i_parser.PrintString("moduleid", "SBEIO_PSU");
        i_parser.PrintString("reasoncode", "SBEIO_PSU_NOT_READY");
        i_parser.PrintString("userdata1[0:15]", "Reserved");
        i_parser.PrintString("userdata1[16:31]", "Request Control Flags");
        i_parser.PrintString("userdata1[32:47]", "Request Sequence ID");
        i_parser.PrintString("userdata1[48:55]", "Request Command Class");
        i_parser.PrintString("userdata1[56:63]", "Request Command");
        i_parser.PrintString("userdata2", "Host to SBE door bell register");
        break;

    case 0x280201:
        i_parser.PrintString("devdesc", "Unexpected sequence number or non zero primary or secondary status");
        i_parser.PrintString("moduleid", "SBEIO_PSU");
        i_parser.PrintString("reasoncode", "SBEIO_PSU_RESPONSE_ERROR");
        i_parser.PrintString("userdata1[0:31]", "Indirect size or 9 for direct command");
        i_parser.PrintString("userdata1[32:47]", "Request Sequence ID");
        i_parser.PrintString("userdata1[48:55]", "Request Command Class");
        i_parser.PrintString("userdata1[56:63]", "Request Command");
        i_parser.PrintString("userdata2[0:15]", "Response Primary Status");
        i_parser.PrintString("userdata2[16:31]", "Response Secondary Status");
        i_parser.PrintString("userdata2[32:47]", "Response Sequence ID");
        i_parser.PrintString("userdata2[48:55]", "Response Command Class");
        i_parser.PrintString("userdata2[56:63]", "Response Command");
        break;

    case 0x280401:
        i_parser.PrintString("devdesc", "Timeout waiting for PSU command to complete");
        i_parser.PrintString("moduleid", "SBEIO_PSU");
        i_parser.PrintString("reasoncode", "SBEIO_PSU_FFDC_MISSING");
        i_parser.PrintString("userdata1[00:15]", "Primary Status in mbox4");
        i_parser.PrintString("userdata1[16:31]", "Sequence Id in mbox4");
        i_parser.PrintString("userdata1[32:63]", "Processor Target");
        i_parser.PrintString("userdata2", "Failing Request");
        break;

    case 0x280101:
        i_parser.PrintString("devdesc", "Timeout waiting for PSU command to complete");
        i_parser.PrintString("moduleid", "SBEIO_PSU");
        i_parser.PrintString("reasoncode", "SBEIO_PSU_RESPONSE_TIMEOUT");
        i_parser.PrintString("userdata1[00:15]", "Primary Status in mbox4");
        i_parser.PrintString("userdata1[16:31]", "Secondary Status");
        i_parser.PrintString("userdata1[32:63]", "Processor Target");
        i_parser.PrintString("userdata2", "Failing Request");
        break;

    case 0x281502:
        i_parser.PrintString("devdesc", "Request length must be 8 bytes");
        i_parser.PrintString("moduleid", "SBEIO_FIFO");
        i_parser.PrintString("reasoncode", "SBEIO_FIFO_INVALID_LENGTH");
        i_parser.PrintString("userdata1", "Request Address");
        i_parser.PrintString("userdata2", "Invalid request length");
        break;

    case 0x281602:
        i_parser.PrintString("devdesc", "Invalide operation. Read and Write supported.");
        i_parser.PrintString("moduleid", "SBEIO_FIFO");
        i_parser.PrintString("reasoncode", "SBEIO_FIFO_INVALID_OPERATION");
        i_parser.PrintString("userdata1", "Request Address");
        i_parser.PrintString("userdata2", "Request operation");
        break;

    case 0x28530E:
        i_parser.PrintString("devdesc", "PRD detected an error with the SBE and HB failed to recover");
        i_parser.PrintString("moduleid", "SBEIO_HANDLE_VITAL_ATTN");
        i_parser.PrintString("reasoncode", "SBEIO_NO_RECOVERY_ACTION");
        i_parser.PrintString("userdata1", "Huid of processor");
        i_parser.PrintString("userdata2", "Unused");
        break;

    case 0x28540E:
        i_parser.PrintString("devdesc", "We expected an error log to be returned from                           p9_extract_rc but there wasn't one");
        i_parser.PrintString("moduleid", "SBEIO_HANDLE_VITAL_ATTN");
        i_parser.PrintString("reasoncode", "SBEIO_EXTRACT_RC_ERROR");
        i_parser.PrintString("userdata1", "Huid of processor");
        i_parser.PrintString("userdata2", "Return action from extract_rc");
        break;

    case 0x285E0A:
        i_parser.PrintString("devdesc", "There was a problem attempting to boot SBE on the slave processor");
        i_parser.PrintString("moduleid", "SBEIO_EXTRACT_RC_HANDLER");
        i_parser.PrintString("reasoncode", "SBEIO_SLAVE_FAILED_TO_BOOT");
        i_parser.PrintString("userdata1", "Bool to describe if FFDC data is found");
        i_parser.PrintString("userdata2", "HUID of proc");
        break;

    case 0x28530A:
        i_parser.PrintString("devdesc", "There is no recovery action on the SBE. We're deconfiguring this proc");
        i_parser.PrintString("moduleid", "SBEIO_EXTRACT_RC_HANDLER");
        i_parser.PrintString("reasoncode", "SBEIO_NO_RECOVERY_ACTION");
        i_parser.PrintString("userdata1", "SBE current error");
        i_parser.PrintString("userdata2", "HUID of proc");
        break;

    case 0x285C0A:
        i_parser.PrintString("devdesc", "We have already flipped seeprom sides once and we should not have attempted to flip again");
        i_parser.PrintString("moduleid", "SBEIO_EXTRACT_RC_HANDLER");
        i_parser.PrintString("reasoncode", "SBEIO_EXCEED_MAX_SIDE_SWITCHES");
        i_parser.PrintString("userdata1", "Switch Sides Count");
        i_parser.PrintString("userdata2", "HUID of proc");
        break;

    case 0x285D0A:
        i_parser.PrintString("devdesc", "We have already done the max attempts for the current seeprom side. For some reason we are attempting to do another boot.");
        i_parser.PrintString("moduleid", "SBEIO_EXTRACT_RC_HANDLER");
        i_parser.PrintString("reasoncode", "SBEIO_EXCEED_MAX_SIDE_BOOTS");
        i_parser.PrintString("userdata1", "# of boots attempts on this side");
        i_parser.PrintString("userdata2", "HUID of proc");
        break;

    case 0x28520A:
        i_parser.PrintString("devdesc", "SBE booted from unexpected side.");
        i_parser.PrintString("moduleid", "SBEIO_EXTRACT_RC_HANDLER");
        i_parser.PrintString("reasoncode", "SBEIO_BOOTED_UNEXPECTED_SIDE");
        i_parser.PrintString("userdata1", "0");
        i_parser.PrintString("userdata2", "HUID of working proc");
        break;

    case 0x285B0C:
        i_parser.PrintString("devdesc", "Unexpected number of FFDC packages in buffer");
        i_parser.PrintString("moduleid", "SBEIO_GET_FFDC_HANDLER");
        i_parser.PrintString("reasoncode", "SBEIO_MORE_FFDC_THAN_EXPECTED");
        i_parser.PrintString("userdata1", "Maximum expected packages");
        i_parser.PrintString("userdata2", "Number of FFDC packages");
        break;

    case 0x28570C:
        i_parser.PrintString("devdesc", "FFDC returned by SBE after failing to reach runtime");
        i_parser.PrintString("moduleid", "SBEIO_GET_FFDC_HANDLER");
        i_parser.PrintString("reasoncode", "SBEIO_RETURNED_FFDC");
        i_parser.PrintString("userdata1", "Processor Target");
        i_parser.PrintString("userdata2", "Number of FFDC packages");
        break;

    case 0x285006:
        i_parser.PrintString("devdesc", "Unsecure Memory Region Does Not Exist");
        i_parser.PrintString("moduleid", "SBEIO_MEM_REGION");
        i_parser.PrintString("reasoncode", "SBEIO_MEM_REGION_DOES_NOT_EXIST");
        i_parser.PrintString("userdata1", "Starting Address of Unsecure Memory Region");
        i_parser.PrintString("userdata2", "Number of Unsecure Memory Regions");
        break;

    case 0x285106:
        i_parser.PrintString("devdesc", "Attempt To Open Too Many Unsecure Memory Regions");
        i_parser.PrintString("moduleid", "SBEIO_MEM_REGION");
        i_parser.PrintString("reasoncode", "SBEIO_EXCEEDS_MAXIMUM_MEM_REGIONS");
        i_parser.PrintString("userdata1", "Current Count of Unsecure Memory Regions");
        i_parser.PrintString("userdata2", "Maximum Number of Unsecure Memomory Regions");
        break;

    case 0x283A07:
        i_parser.PrintString("devdesc", "SBEIO RT Process Pass-through command RuntimeRT Interface pointer not set.");
        i_parser.PrintString("moduleid", "SBEIO::SBEIO_RUNTIME_ATTR_OVERRIDE");
        i_parser.PrintString("reasoncode", "SBEIO::SBEIO_RT_NO_INTERFACE_POINTER");
        i_parser.PrintString("userdata1", "Processor HUID");
        i_parser.PrintString("userdata2", "Reserved");
        break;

    case 0x283C07:
        i_parser.PrintString("devdesc", "SBEIO RT Process Pass-through command RuntimeRT Interface pointer for apply_attr_override not set.");
        i_parser.PrintString("moduleid", "SBEIO::SBEIO_RUNTIME_ATTR_OVERRIDE");
        i_parser.PrintString("reasoncode", "SBEIO::SBEIO_RT_NO_APPLY_ATTR_FUNCTION");
        i_parser.PrintString("userdata1", "Processor HUID");
        i_parser.PrintString("userdata2", "Reserved");
        break;

    case 0x283305:
        i_parser.PrintString("devdesc", "SBEIO RT Read Pass-through command invalid version.");
        i_parser.PrintString("moduleid", "SBEIO::SBEIO_RUNTIME");
        i_parser.PrintString("reasoncode", "SBEIO::SBEIO_RT_INVALID_VERSION");
        i_parser.PrintString("userdata1[0:31]", "SBE Header version");
        i_parser.PrintString("userdata1[32:63]", "Command Header version");
        i_parser.PrintString("userdata2", "Processor HUID");
        break;

    case 0x283405:
        i_parser.PrintString("devdesc", "SBEIO RT Read Pass-through command message size is too large.");
        i_parser.PrintString("moduleid", "SBEIO::SBEIO_RUNTIME");
        i_parser.PrintString("reasoncode", "SBEIO::SBEIO_RT_MSG_SIZE_TOO_LARGE");
        i_parser.PrintString("userdata1[0:31]", "Processor HUID");
        i_parser.PrintString("userdata1[32:63]", "Message Size");
        i_parser.PrintString("userdata2", "Reserved");
        break;

    case 0x283505:
        i_parser.PrintString("devdesc", "SBEIO RT Read Pass-through command data offset is too small.");
        i_parser.PrintString("moduleid", "SBEIO::SBEIO_RUNTIME");
        i_parser.PrintString("reasoncode", "SBEIO::SBEIO_RT_DATA_OFFSET_TOO_SMALL");
        i_parser.PrintString("userdata1[0:31]", "Processor HUID");
        i_parser.PrintString("userdata1[32:63]", "Data Offset");
        i_parser.PrintString("userdata2", "Minimum Data Offset");
        break;

    case 0x283605:
        i_parser.PrintString("devdesc", "SBEIO RT Read Pass-through command data offset is too large.");
        i_parser.PrintString("moduleid", "SBEIO::SBEIO_RUNTIME");
        i_parser.PrintString("reasoncode", "SBEIO::SBEIO_RT_DATA_TOO_LARGE");
        i_parser.PrintString("userdata1[0:31]", "Processor HUID");
        i_parser.PrintString("userdata1[32:63]", "Data Offset");
        i_parser.PrintString("userdata2[0:31]", "Message Size");
        i_parser.PrintString("userdata2[32:63]", "Data Size");
        break;

    case 0x283905:
        i_parser.PrintString("devdesc", "SBEIO RT Process Pass-through command function not found.");
        i_parser.PrintString("moduleid", "SBEIO::SBEIO_RUNTIME");
        i_parser.PrintString("reasoncode", "SBEIO::SBEIO_RT_FUNCTION_NOT_FOUND");
        i_parser.PrintString("userdata1[0:31]", "Processor HUID");
        i_parser.PrintString("userdata1[32:63]", "Request Command");
        i_parser.PrintString("userdata2", "Sequence ID");
        break;

    case 0x283105:
        i_parser.PrintString("devdesc", "SBEIO RT Process Pass-through command function not set.");
        i_parser.PrintString("moduleid", "SBEIO::SBEIO_RUNTIME");
        i_parser.PrintString("reasoncode", "SBEIO::SBEIO_RT_FUNCTION_NOT_SET");
        i_parser.PrintString("userdata1[0:31]", "Processor HUID");
        i_parser.PrintString("userdata1[32:63]", "Request Command");
        i_parser.PrintString("userdata2", "Sequence ID");
        break;

    case 0x283205:
        i_parser.PrintString("devdesc", "SBEIO RT Process Pass-through command response data size too large.");
        i_parser.PrintString("moduleid", "SBEIO::SBEIO_RUNTIME");
        i_parser.PrintString("reasoncode", "SBEIO::SBEIO_RT_RSP_DATA_TOO_LARGE");
        i_parser.PrintString("userdata1[0:31]", "Processor HUID");
        i_parser.PrintString("userdata1[32:63]", "Request Command");
        i_parser.PrintString("userdata2[0:31]", "Sequence ID");
        i_parser.PrintString("userdata2[32:63]", "Response Data Size");
        break;

    case 0x283705:
        i_parser.PrintString("devdesc", "SBEIO RT Check Pass-through command response field was altered.");
        i_parser.PrintString("moduleid", "SBEIO::SBEIO_RUNTIME");
        i_parser.PrintString("reasoncode", "SBEIO::SBEIO_RT_RSP_FIELD_ALTERED");
        i_parser.PrintString("userdata1[0:31]", "Processor HUID");
        i_parser.PrintString("userdata1[32:63]", "Request Command");
        i_parser.PrintString("userdata2", "Sequence ID");
        break;

    case 0x283805:
        i_parser.PrintString("devdesc", "SBEIO RT Process Pass-through command SBE Communication buffer not set.");
        i_parser.PrintString("moduleid", "SBEIO::SBEIO_RUNTIME");
        i_parser.PrintString("reasoncode", "SBEIO::SBEIO_RT_NO_SBE_COMM_BUFFER");
        i_parser.PrintString("userdata1", "Processor HUID");
        i_parser.PrintString("userdata2", "Reserved");
        break;

    case 0x283A05:
        i_parser.PrintString("devdesc", "SBEIO RT Process Pass-through command Runtime Interface pointer not set.");
        i_parser.PrintString("moduleid", "SBEIO::SBEIO_RUNTIME");
        i_parser.PrintString("reasoncode", "SBEIO::SBEIO_RT_NO_INTERFACE_POINTER");
        i_parser.PrintString("userdata1", "Processor HUID");
        i_parser.PrintString("userdata2", "Reserved");
        break;

    case 0x283B05:
        i_parser.PrintString("devdesc", "SBEIO RT Process Pass-through command Runtime Interface function pointer not set.");
        i_parser.PrintString("moduleid", "SBEIO::SBEIO_RUNTIME");
        i_parser.PrintString("reasoncode", "SBEIO::SBEIO_RT_NO_INTERFACE_FUNCTION");
        i_parser.PrintString("userdata1", "Processor HUID");
        i_parser.PrintString("userdata2", "Reserved");
        break;

    case 0x283D0E:
        i_parser.PrintString("devdesc", "Unable to inform OPAL of SBE failure");
        i_parser.PrintString("moduleid", "SBEIO_HANDLE_VITAL_ATTN");
        i_parser.PrintString("reasoncode", "SBEIO_RT_NULL_FIRMWARE_REQUEST_PTR");
        i_parser.PrintString("userdata1", "HUID of target");
        i_parser.PrintString("userdata2", "none");
        break;

    case 0x281904:
        i_parser.PrintString("devdesc", "Attempted FIFO chip op on Master Proc");
        i_parser.PrintString("moduleid", "SBEIO_FIFO_CONTINUE_MPIPL");
        i_parser.PrintString("reasoncode", "SBEIO_FIFO_SENTINEL_TARGET");
        break;

    case 0x281702:
        i_parser.PrintString("devdesc", "Null target passed");
        i_parser.PrintString("moduleid", "SBEIO_FIFO");
        i_parser.PrintString("reasoncode", "SBEIO_FIFO_NULL_TARGET");
        i_parser.PrintString("userdata1", "Request Address");
        break;

    case 0x281902:
        i_parser.PrintString("devdesc", "Master Sentinel target is not supported");
        i_parser.PrintString("moduleid", "SBEIO_FIFO");
        i_parser.PrintString("reasoncode", "SBEIO_FIFO_SENTINEL_TARGET");
        i_parser.PrintString("userdata1", "Request Address");
        break;

    case 0x281802:
        i_parser.PrintString("devdesc", "Master Proc is not supported");
        i_parser.PrintString("moduleid", "SBEIO_FIFO");
        i_parser.PrintString("reasoncode", "SBEIO_FIFO_MASTER_TARGET");
        i_parser.PrintString("userdata1", "Request Address");
        i_parser.PrintString("userdata2", "HUID of master proc");
        break;

    case 0x281A03:
        i_parser.PrintString("devdesc", "If the size of the FFDC package exceeds our allocated buffer size, we log it.");
        i_parser.PrintString("moduleid", "SBEIO_FFDC_PARSER");
        i_parser.PrintString("reasoncode", "SBEIO_FFDC_PARSER_BUFF_OVERFLOW");
        i_parser.PrintString("userdata1", "size of FFDC package that overflows the buffer");
        break;

    default:
        l_success = false;
        break;
    };
    return l_success;
}

static errl::SrcPlugin g_SrcPlugin(0x2800, SrcDataParse, ERRL_CID_HOSTBOOT);
