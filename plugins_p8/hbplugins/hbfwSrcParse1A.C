/*
 * Automatically generated by Hostboot's ./genErrlParsers.pl
 * Do not modify this file in the FSP tree, it is provided by
 * Hostboot and will be overwritten
 *
 * TimeStamp:   Thu Apr 12 08:28:51 2018
 * Image Id:    hb0412a_1815.861
 *
 */

#include <errlplugins.H>
#include <errlusrparser.H>
#include <srcisrc.H>

static bool SrcDataParse(ErrlUsrParser & i_parser,
                         const SrciSrc & i_src)
{
    uint32_t l_error = (i_src.reasonCode() << 8) + i_src.moduleId();
    bool l_success = true;

    switch(l_error)
    {
    case 0x1A0E0E:
        i_parser.PrintString("devdesc", "TCE Table size requested too large.");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_TCE_MAP");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_TCE_INVALID_SIZE");
        i_parser.PrintString("userdata1", "Address of the TCE Table");
        i_parser.PrintString("userdata2", "Size of of the table that is too large?");
        break;

    case 0x1A0F0E:
        i_parser.PrintString("devdesc", "TCE Table not page aligned.");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_TCE_MAP");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_TCE_ADDR_NOT_ALIGNED");
        i_parser.PrintString("userdata1", "Address of the TCE Table");
        i_parser.PrintString("userdata2", "none");
        break;

    case 0x1A110E:
        i_parser.PrintString("devdesc", "Device Map Fail");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_TCE_MAP");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_TCE_DEV_MAP_FAIL");
        i_parser.PrintString("userdata1", "Address to be mapped");
        i_parser.PrintString("userdata2", "return Code from DevMap");
        break;

    case 0x1A110A:
        i_parser.PrintString("devdesc", "PSI Bridge device Map failed");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_TCE_INIT_HDW");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_TCE_DEV_MAP_FAIL");
        i_parser.PrintString("userdata1", "Address to be mapped PsiBridgeAddr");
        i_parser.PrintString("userdata2", "Tce Phys Addr");
        break;

    case 0x1A120A:
        i_parser.PrintString("devdesc", "Device UnMap Failure");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_TCE_INIT_HDW");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_TCE_DEV_UNMAP_FAIL");
        i_parser.PrintString("userdata1", "Virtual Addr");
        i_parser.PrintString("userdata2", "return Code from devUnMap");
        break;

    case 0x1A100B:
        i_parser.PrintString("devdesc", "TCE Table has not been initialized yet");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_TCE_ALLOCATE");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_TCE_INIT_NOT_RUN");
        i_parser.PrintString("userdata1", "Address to start TCE");
        i_parser.PrintString("userdata2", "Size of the address space tring to get TCEs for.");
        break;

    case 0x1A0F0B:
        i_parser.PrintString("devdesc", "The Physical Address for the TCE entry is not page aligned.");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_TCE_ALLOCATE");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_TCE_ADDR_NOT_ALIGNED");
        i_parser.PrintString("userdata1", "Address to start TCE");
        i_parser.PrintString("userdata2", "Size of the address space tring to get TCEs for.");
        break;

    case 0x1A0E0B:
        i_parser.PrintString("devdesc", "The size requested is too large for the table");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_TCE_ALLOCATE");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_TCE_INVALID_SIZE");
        i_parser.PrintString("userdata1", "Address to start TCE");
        i_parser.PrintString("userdata2", "Size of the address space tring to get TCEs for.");
        break;

    case 0x1A140B:
        i_parser.PrintString("devdesc", "The size requested is too large.");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_TCE_ALLOCATE");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_TCE_NOT_ENOUGH_FREE_ENTRIES");
        i_parser.PrintString("userdata1", "Address to start TCE");
        i_parser.PrintString("userdata2", "Size of the address space trying to get TCEs for.");
        break;

    case 0x1A0E0C:
        i_parser.PrintString("devdesc", "The size requested is too large for the table space avail starting at the Token passed in.");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_TCE_DEALLOCATE");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_TCE_INVALID_SIZE");
        i_parser.PrintString("userdata1", "starting index");
        i_parser.PrintString("userdata2", "number of TCEs needed for this request");
        break;

    case 0x1A150C:
        i_parser.PrintString("devdesc", "The deallocate went across TCE Allocate space.");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_TCE_DEALLOCATE");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_TCE_ENTRY_NOT_CONTIGUOUS");
        i_parser.PrintString("userdata1", "i_startingToken");
        i_parser.PrintString("userdata2", "Size of the address space trying to deallocate");
        break;

    case 0x1A0B08:
        i_parser.PrintString("devdesc", "HDAT data block falls outside valid range");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_HDATSERVICE_VERIFY_HDAT_ADDRESS");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_INVALID_ADDRESS");
        i_parser.PrintString("userdata1", "Start of address range under test");
        i_parser.PrintString("userdata2", "Size of address range under test");
        break;

    case 0x1A0203:
        i_parser.PrintString("devdesc", "HDAT Header data not as expected");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_HDATSERVICE_CHECK_HEADER");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_BAD_HDAT_HEADER");
        i_parser.PrintString("userdata1[0:15]", "Actual Header: id");
        i_parser.PrintString("userdata1[16:31]", "Actual Header: version");
        i_parser.PrintString("userdata1[32:63]", "Actual Header: name");
        i_parser.PrintString("userdata2[0:15]", "Expected Header: id");
        i_parser.PrintString("userdata2[16:31]", "Expected Header: version");
        i_parser.PrintString("userdata2[32:63]", "Expected Header: name");
        break;

    case 0x1A0304:
        i_parser.PrintString("devdesc", "Tuple is unallocated");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_HDATSERVICE_CHECK_TUPLE");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_BAD_HDAT_TUPLE");
        i_parser.PrintString("userdata1", "Absolute address");
        i_parser.PrintString("userdata2[0:31]", "Allocated Count");
        i_parser.PrintString("userdata2[32:63]", "Allocated Size");
        break;

    case 0x1A0406:
        i_parser.PrintString("devdesc", "Section is not valid in standalone mode");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_HDATSERVICE_GET_STANDALONE_SECTION");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_INVALID_STANDALONE");
        i_parser.PrintString("userdata1", "Section ID");
        i_parser.PrintString("userdata2", "Section Instance Number");
        break;

    case 0x1A0511:
        i_parser.PrintString("devdesc", "Error mapping in memory");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_HDATSERVICE_MAPREGION");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_CANNOT_MAP_MEMORY");
        i_parser.PrintString("userdata1", "Starting Address");
        i_parser.PrintString("userdata2", "Size");
        break;

    case 0x1A0807:
        i_parser.PrintString("devdesc", "There is no host data for specified kind of payload");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_HDATSERVICE_GETHOSTDATASECTION");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_INVALID_PAYLOAD_KIND");
        i_parser.PrintString("userdata1", "ATTR_PAYLOAD_KIND");
        i_parser.PrintString("userdata2", "Requested Section");
        break;

    case 0x1A0907:
        i_parser.PrintString("devdesc", "Requested instance of HSVC_NODE_DATA is unallocated");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_HDATSERVICE_GETHOSTDATASECTION");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_NO_HSVC_NODE_DATA_FOUND");
        i_parser.PrintString("userdata1", "Mainstore address of first node_data_header");
        i_parser.PrintString("userdata2[0:31]", "Requested Instance");
        i_parser.PrintString("userdata2[32:63]", "Bitmask of discovered instances");
        break;

    case 0x1A0C07:
        i_parser.PrintString("devdesc", "Unknown section requested");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_HDATSERVICE_GETHOSTDATASECTION");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_INVALID_SECTION");
        i_parser.PrintString("userdata1", "Section Id");
        i_parser.PrintString("userdata2", "<unused>");
        break;

    case 0x1A0A0F:
        i_parser.PrintString("devdesc", "NACA data doesn't seem right");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_HDATSERVICE_FINDSPIRA");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_BAD_NACA");
        i_parser.PrintString("userdata1", "Mainstore address of NACA");
        i_parser.PrintString("userdata2[0:31]", "Payload Base Address");
        i_parser.PrintString("userdata2[32:63]", "Payload Kind");
        break;

    case 0x1A160F:
        i_parser.PrintString("devdesc", "Could not find a valid SPIRA of any type");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_HDATSERVICE_FINDSPIRA");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_NO_SPIRA");
        i_parser.PrintString("userdata1[0:31]", "RC for Legacy SPIRA fail");
        i_parser.PrintString("userdata1[32:64]", "EID for Legacy SPIRA fail");
        i_parser.PrintString("userdata2[0:31]", "RC for SPIRA-S fail");
        i_parser.PrintString("userdata2[32:64]", "EID for SPIRA-S fail");
        break;

    case 0x1A0810:
        i_parser.PrintString("devdesc", "There is no host data for specified kind of payload");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_HDATSERVICE_UPDATE_SECTION_ACTUAL");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_INVALID_PAYLOAD_KIND");
        i_parser.PrintString("userdata1", "ATTR_PAYLOAD_KIND");
        i_parser.PrintString("userdata2", "Requested Section");
        break;

    case 0x1A0C10:
        i_parser.PrintString("devdesc", "Unknown section requested");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_HDATSERVICE_UPDATE_SECTION_ACTUAL");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_INVALID_SECTION");
        i_parser.PrintString("userdata1", "Section Id");
        i_parser.PrintString("userdata2", "<unused>");
        break;

    case 0x1A0C01:
        i_parser.PrintString("devdesc", "Invalid memory values for HSVC_SYSTEM_DATA");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_RUNTIME_POP_SYS_ATTR");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_INVALID_SECTION");
        i_parser.PrintString("userdata1", "Returned address: sys_data_addr");
        i_parser.PrintString("userdata2", "Returned size: sys_data_size");
        break;

    case 0x1A1801:
        i_parser.PrintString("devdesc", "Not enough space allocated by HDAT for HostServices System Data");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_RUNTIME_POP_SYS_ATTR");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_NOT_ENOUGH_SPACE");
        i_parser.PrintString("userdata1", "Required size");
        i_parser.PrintString("userdata2", "Available size");
        break;

    case 0x1A0101:
        i_parser.PrintString("devdesc", "Error retrieving FAPI attribute");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_RUNTIME_POP_SYS_ATTR");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_ATTR_GET_FAIL");
        i_parser.PrintString("userdata1", "Return code from FAPI_ATTR_GET");
        i_parser.PrintString("userdata2", "FAPI Attribute Id that failed");
        break;

    case 0x1A0C02:
        i_parser.PrintString("devdesc", "Invalid memory values for HSVC_NODE_DATA");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_RUNTIME_POP_NODE_ATTR");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_INVALID_SECTION");
        i_parser.PrintString("userdata1", "Returned address: node_data_addr");
        i_parser.PrintString("userdata2", "Returned size: node_data_size");
        break;

    case 0x1A1802:
        i_parser.PrintString("devdesc", "Not enough space allocated by HDAT for HostServices Node Data");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_RUNTIME_POP_NODE_ATTR");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_NOT_ENOUGH_SPACE");
        i_parser.PrintString("userdata1", "Required size");
        i_parser.PrintString("userdata2", "Available size");
        break;

    case 0x1A0102:
        i_parser.PrintString("devdesc", "Error retrieving FAPI attribute");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_RUNTIME_POP_NODE_ATTR");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_ATTR_GET_FAIL");
        i_parser.PrintString("userdata1", "Return code from FAPI_ATTR_GET");
        i_parser.PrintString("userdata2", "FAPI Attribute Id that failed");
        break;

    default:
        l_success = false;
        break;
    };
    return l_success;
}

static errl::SrcPlugin g_SrcPlugin(0x1A00, SrcDataParse, ERRL_CID_HOSTBOOT);
