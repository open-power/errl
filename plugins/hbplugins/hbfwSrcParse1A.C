/*
 * Automatically generated by Hostboot's ./genErrlParsers.pl
 * Do not modify this file in the FSP tree, it is provided by
 * Hostboot and will be overwritten
 *
 * TimeStamp:   Tue May 15 13:26:15 2018
 * Image Id:    hb0515b_1820.920
 *
 */

#include <errlplugins.H>
#include <errlusrparser.H>
#include <srcisrc.H>

static bool SrcDataParse(ErrlUsrParser & i_parser,
                         const SrciSrc & i_src)
{
    uint32_t l_error = (i_src.reasonCode() << 8) + i_src.moduleId();
    bool l_success = true;

    switch(l_error)
    {
    case 0x1A3824:
        i_parser.PrintString("devdesc", "The Firmware Request call failed");
        i_parser.PrintString("moduleid", "MOD_RT_FIRMWARE_REQUEST");
        i_parser.PrintString("reasoncode", "RC_FW_REQUEST_RESET_RELOAD_ERR");
        i_parser.PrintString("userdata1[0:31]", "Hypervisor return code");
        i_parser.PrintString("userdata1[32:63]", "Firmware Request type (HCODE Update) ||                                  sequence number (FSP MSG) ||                                  i2cMaster & lock operation");
        i_parser.PrintString("userdata2[0:31]", "SCOM address (HCODE Update) ||                                  MBOX message type (FSP MSG) ||                                  chipID");
        i_parser.PrintString("userdata2[32:63]", "SCOM data (HCODE Update) ||                                  Message Type (FSP MSG) ||                                  SBE state");
        break;

    case 0x1A3924:
        i_parser.PrintString("devdesc", "The Firmware Request call failed");
        i_parser.PrintString("moduleid", "MOD_RT_FIRMWARE_REQUEST");
        i_parser.PrintString("reasoncode", "RC_FW_REQUEST_ERR");
        i_parser.PrintString("userdata1[0:31]", "Hypervisor return code");
        i_parser.PrintString("userdata1[32:63]", "Firmware Request type (HCODE Update) ||                                  sequence number (FSP MSG) ||                                  i2cMaster & lock operation");
        i_parser.PrintString("userdata2[0:31]", "SCOM address (HCODE Update) ||                                  MBOX message type (FSP MSG) ||                                  chipId");
        i_parser.PrintString("userdata2[32:63]", "SCOM data (HCODE Update) ||                                  Message Type (FSP MSG)  ||                                  SBE state");
        break;

    case 0x1A3724:
        i_parser.PrintString("devdesc", "The Firmware Request call failed");
        i_parser.PrintString("moduleid", "MOD_RT_FIRMWARE_REQUEST");
        i_parser.PrintString("reasoncode", "RC_FW_REQUEST_HWSV_ERR");
        i_parser.PrintString("userdata1[0:31]", "HWSV error log id (PLID)");
        i_parser.PrintString("userdata1[32:63]", "Sequence number");
        i_parser.PrintString("userdata2[0:31]", "MBOX message type");
        i_parser.PrintString("userdata2[32:63]", "Message Type");
        break;

    case 0x1A3523:
        i_parser.PrintString("devdesc", "SBE error recovery attempt failed");
        i_parser.PrintString("moduleid", "MOD_RT_FIRMWARE_NOTIFY");
        i_parser.PrintString("reasoncode", "RC_SBE_RT_INVALID_HUID");
        i_parser.PrintString("userdata1", "HUID of target");
        i_parser.PrintString("userdata2", "HWSV error log id (plid)");
        break;

    case 0x1A3423:
        i_parser.PrintString("devdesc", "SBE error recovery attempt failed");
        i_parser.PrintString("moduleid", "MOD_RT_FIRMWARE_NOTIFY");
        i_parser.PrintString("reasoncode", "RC_FW_REQUEST_RT_NULL_PTR");
        i_parser.PrintString("userdata1", "HUID of target");
        i_parser.PrintString("userdata2", "HWSV error log id (plid)");
        break;

    case 0x1A3C25:
        i_parser.PrintString("devdesc", "Attribute failed to update on HBRT side");
        i_parser.PrintString("moduleid", "MOD_RT_ATTR_SYNC_REQUEST");
        i_parser.PrintString("reasoncode", "RC_ATTR_UPDATE_FAILED");
        i_parser.PrintString("userdata1[0:31]", "Target HUID");
        i_parser.PrintString("userdata1[32:63]", "Attribute ID");
        i_parser.PrintString("userdata2[0:31]", "Data Size");
        i_parser.PrintString("userdata2[32:63]", "Up to 4 bytes of attribute data");
        break;

    case 0x1A3223:
        i_parser.PrintString("devdesc", "Error with Firmware Notify request");
        i_parser.PrintString("moduleid", "MOD_RT_FIRMWARE_NOTIFY");
        i_parser.PrintString("reasoncode", "RC_FW_NOTIFY_RT_INVALID_MSG");
        i_parser.PrintString("userdata1[0:31]", "Firmware Request type");
        i_parser.PrintString("userdata1[32:63]", "Sequence number (FSP msg)");
        i_parser.PrintString("userdata2[0:31]", "MBOX message type (FSP msg)");
        i_parser.PrintString("userdata2[32:63]", "Message Type (FSP msg)");
        break;

    case 0x1A300E:
        i_parser.PrintString("devdesc", "Trying to load invalid lid");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_PREVERLIDMGR_LOAD_FROM_PNOR");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_INVALID_LID");
        i_parser.PrintString("userdata1", "PNOR section");
        i_parser.PrintString("userdata2", "Lid id mapped from PNOR section");
        break;

    case 0x1A310E:
        i_parser.PrintString("devdesc", "No content after Section header or size was parsed from secure header incorrectly.");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_PREVERLIDMGR_LOAD_FROM_PNOR");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_PREVER_INVALID_SIZE");
        i_parser.PrintString("userdata1", "PNOR section");
        i_parser.PrintString("userdata2", "Size of section including header");
        break;

    case 0x1A310F:
        i_parser.PrintString("devdesc", "No space left for fake header injection");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_PREVERLIDMGR_LOAD_IMAGE");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_PREVER_INVALID_SIZE");
        i_parser.PrintString("userdata1", "Size of section including space for header");
        i_parser.PrintString("userdata2", "Size of header");
        break;

    case 0x1A1B12:
        i_parser.PrintString("devdesc", "No processor targeting target was found for the given targeting target");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_CUST_COMP_NON_PHYP_RT_TARGET");
        i_parser.PrintString("reasoncode", "RUNTIME::RT_NO_PROC_TARGET");
        i_parser.PrintString("userdata1", "Input targeting target's HUID");
        break;

    case 0x1A1912:
        i_parser.PrintString("devdesc", "No associated DMI targeting target(s) found for given MEMBUF targeting target");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_CUST_COMP_NON_PHYP_RT_TARGET");
        i_parser.PrintString("reasoncode", "RUNTIME::RT_UNIT_TARGET_NOT_FOUND");
        i_parser.PrintString("userdata1", "MEMBUF targeting target's HUID");
        break;

    case 0x1A1A12:
        i_parser.PrintString("devdesc", "The targeting type of the input targeting target is not supported by runtime code");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_CUST_COMP_NON_PHYP_RT_TARGET");
        i_parser.PrintString("reasoncode", "RUNTIME::RT_TARGET_TYPE_NOT_SUPPORTED");
        i_parser.PrintString("userdata1", "Targeting target's HUID");
        i_parser.PrintString("userdata2", "Targeting target's type");
        break;

    case 0x1A1A13:
        i_parser.PrintString("devdesc", "Targeting target's type not supported by runtime code");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_CUST_CONF_HBRT_HYP_IDS");
        i_parser.PrintString("reasoncode", "RUNTIME::RT_TARGET_TYPE_NOT_SUPPORTED");
        i_parser.PrintString("userdata1", "Target's HUID");
        i_parser.PrintString("userdata2", "Target's targeting type");
        break;

    case 0x1A0B08:
        i_parser.PrintString("devdesc", "HDAT data block falls outside valid range");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_HDATSERVICE_VERIFY_HDAT_ADDRESS");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_INVALID_ADDRESS");
        i_parser.PrintString("userdata1", "Start of address range under test");
        i_parser.PrintString("userdata2", "Size of address range under test");
        break;

    case 0x1A0203:
        i_parser.PrintString("devdesc", "HDAT Header data not as expected");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_HDATSERVICE_CHECK_HEADER");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_BAD_HDAT_HEADER");
        i_parser.PrintString("userdata1[0:15]", "Actual Header: id");
        i_parser.PrintString("userdata1[16:31]", "Actual Header: version");
        i_parser.PrintString("userdata1[32:63]", "Actual Header: name");
        i_parser.PrintString("userdata2[0:15]", "Expected Header: id");
        i_parser.PrintString("userdata2[16:31]", "Expected Header: version");
        i_parser.PrintString("userdata2[32:63]", "Expected Header: name");
        break;

    case 0x1A0304:
        i_parser.PrintString("devdesc", "Tuple is unallocated");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_HDATSERVICE_CHECK_TUPLE");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_BAD_HDAT_TUPLE");
        i_parser.PrintString("userdata1", "Absolute address");
        i_parser.PrintString("userdata2[0:31]", "Allocated Count");
        i_parser.PrintString("userdata2[32:63]", "Allocated Size");
        break;

    case 0x1A0406:
        i_parser.PrintString("devdesc", "Section is not valid in standalone mode");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_HDATSERVICE_GET_STANDALONE_SECTION");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_INVALID_STANDALONE");
        i_parser.PrintString("userdata1", "Section ID");
        i_parser.PrintString("userdata2", "Section Instance Number");
        break;

    case 0x1A050B:
        i_parser.PrintString("devdesc", "Error mapping in memory");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_HDATSERVICE_MAPREGION");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_CANNOT_MAP_MEMORY");
        i_parser.PrintString("userdata1", "Starting Address");
        i_parser.PrintString("userdata2", "Size");
        break;

    case 0x1A0807:
        i_parser.PrintString("devdesc", "There is no host data for specified kind of payload");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_HDATSERVICE_GETHOSTDATASECTION");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_INVALID_PAYLOAD_KIND");
        i_parser.PrintString("userdata1", "ATTR_PAYLOAD_KIND");
        i_parser.PrintString("userdata2", "Requested Section");
        break;

    case 0x1A2007:
        i_parser.PrintString("devdesc", "Invalid instance requested for Reserved Hostboot Memory section");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_HDATSERVICE_GETHOSTDATASECTION");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_INVALID_RHB_INSTANCE");
        i_parser.PrintString("userdata1", "Requested instance");
        i_parser.PrintString("userdata2", "Entry count");
        break;

    case 0x1A0C07:
        i_parser.PrintString("devdesc", "Unknown section requested");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_HDATSERVICE_GETHOSTDATASECTION");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_INVALID_SECTION");
        i_parser.PrintString("userdata1", "Section Id");
        i_parser.PrintString("userdata2", "<unused>");
        break;

    case 0x1A0A09:
        i_parser.PrintString("devdesc", "NACA data doesn't seem right");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_HDATSERVICE_FINDSPIRA");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_BAD_NACA");
        i_parser.PrintString("userdata1", "Mainstore address of NACA");
        i_parser.PrintString("userdata2[0:31]", "Payload Base Address");
        i_parser.PrintString("userdata2[32:63]", "Payload Kind");
        break;

    case 0x1A1609:
        i_parser.PrintString("devdesc", "Could not find a valid SPIRA of any type");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_HDATSERVICE_FINDSPIRA");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_NO_SPIRA");
        i_parser.PrintString("userdata1[0:31]", "RC for Legacy SPIRA fail");
        i_parser.PrintString("userdata1[32:64]", "EID for Legacy SPIRA fail");
        i_parser.PrintString("userdata2[0:31]", "RC for SPIRA-S fail");
        i_parser.PrintString("userdata2[32:64]", "EID for SPIRA-S fail");
        break;

    case 0x1A080A:
        i_parser.PrintString("devdesc", "There is no host data for specified kind of payload");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_HDATSERVICE_UPDATE_SECTION_ACTUAL");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_INVALID_PAYLOAD_KIND");
        i_parser.PrintString("userdata1", "ATTR_PAYLOAD_KIND");
        i_parser.PrintString("userdata2", "Requested Section");
        break;

    case 0x1A0C0A:
        i_parser.PrintString("devdesc", "Unknown section requested");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_HDATSERVICE_UPDATE_SECTION_ACTUAL");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_INVALID_SECTION");
        i_parser.PrintString("userdata1", "Section Id");
        i_parser.PrintString("userdata2", "<unused>");
        break;

    case 0x1A230C:
        i_parser.PrintString("devdesc", "Unsupported section requested");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_HDATSERVICE_GETINSTANCECOUNT");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_INSTANCES_UNSUPPORTED");
        i_parser.PrintString("userdata1", "Section Id");
        i_parser.PrintString("userdata2", "<unused>");
        break;

    case 0x1A260D:
        i_parser.PrintString("devdesc", "Unsupported section requested");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_HDATSERVICE_GETANDCHECKTUPLE");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_GETTUPLE_UNSUPPORTED");
        i_parser.PrintString("userdata1", "Section Id");
        i_parser.PrintString("userdata2", "<unused>");
        break;

    case 0x1A0517:
        i_parser.PrintString("devdesc", "Error mapping a virtual memory map");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_MAP_PHYS_ADDR");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_CANNOT_MAP_MEMORY");
        i_parser.PrintString("userdata1", "Phys address we are trying to map");
        i_parser.PrintString("userdata2", "Size of memory we are trying to map");
        break;

    case 0x1A1C18:
        i_parser.PrintString("devdesc", "Error unmapping a virtual memory map");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_UNMAP_VIRT_ADDR");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_UNMAP_FAIL");
        i_parser.PrintString("userdata1", "Virtual address we are trying to unmap");
        i_parser.PrintString("userdata2", "0");
        break;

    case 0x1A3D26:
        i_parser.PrintString("devdesc", "Hostboot attempted to reserve memory past allowed range. Bottom limit = Hostboot HRMOR + 64M, top limit = 256M - 4K.");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_CHECK_HB_RES_MEM_LIMIT");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_HB_RES_MEM_EXCEEDED");
        i_parser.PrintString("userdata1", "Starting address");
        i_parser.PrintString("userdata2", "Size of the section");
        break;

    case 0x1A2720:
        i_parser.PrintString("devdesc", "Unable to fill in HB data memory");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_FILL_RSVMEM_HBDATA");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_EXCEEDED_MEMORY");
        i_parser.PrintString("userdata1", "Total size needed");
        i_parser.PrintString("userdata2", "Size allowed");
        break;

    case 0x1A2A19:
        i_parser.PrintString("devdesc", "The TPM data hdat section doesn't have enough space");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_POPULATE_TPMINFOBYNODE");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_TPM_HDAT_OUT_OF_SPACE");
        i_parser.PrintString("userdata1", "Size of hdat data struct");
        i_parser.PrintString("userdata2", "Max size of hdat data struct");
        break;

    case 0x1A2B19:
        i_parser.PrintString("devdesc", "TPM data hdat struct format value doesn't match");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_POPULATE_TPMINFOBYNODE");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_TPM_HDAT_ID_MISMATCH");
        i_parser.PrintString("userdata1", "hdat struct format value");
        i_parser.PrintString("userdata2", "Expected hdat struct format value");
        break;

    case 0x1A2C19:
        i_parser.PrintString("devdesc", "TPM data hdat struct name eye catcher doesn't match");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_POPULATE_TPMINFOBYNODE");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_TPM_HDAT_EYE_CATCH_MISMATCH");
        i_parser.PrintString("userdata1", "hdat struct name eye catcher");
        i_parser.PrintString("userdata2", "Expected hdat eye catch");
        break;

    case 0x1A2D19:
        i_parser.PrintString("devdesc", "TPM does not have a processor");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_POPULATE_TPMINFOBYNODE");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_TPM_MISSING_PROC");
        i_parser.PrintString("userdata1", "Number of processors");
        i_parser.PrintString("userdata2", "0");
        break;

    case 0x1A3A19:
        i_parser.PrintString("devdesc", "Failed to convert virtual address to physical address");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_POPULATE_TPMINFOBYNODE");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_TPM_HDAT_VIRT_TO_PHYS_ERR");
        i_parser.PrintString("userdata1", "Requested virtual address to convert");
        break;

    case 0x1A3B19:
        i_parser.PrintString("devdesc", "Failed to map physical memory to virtual memory");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_POPULATE_TPMINFOBYNODE");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_TPM_HDAT_MAP_BLOCK_ERR");
        i_parser.PrintString("userdata1", "Aligned physical address to map");
        i_parser.PrintString("userdata2", "Aligned size or region to map");
        break;

    case 0x1A2E19:
        i_parser.PrintString("devdesc", "Bad PCRD section version");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_POPULATE_TPMINFOBYNODE");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_TPM_HDAT_BAD_VERSION");
        i_parser.PrintString("userdata1", "hdat version");
        i_parser.PrintString("userdata2", "Expected support version");
        break;

    case 0x1A2F19:
        i_parser.PrintString("devdesc", "HDAT PCRD reported more than the max number of i2c devices");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_POPULATE_TPMINFOBYNODE");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_TPM_HDAT_BAD_NUM_I2C");
        i_parser.PrintString("userdata1", "hdat array count");
        i_parser.PrintString("userdata2", "max number of i2c devices");
        break;

    case 0x1A2119:
        i_parser.PrintString("devdesc", "Found duplicate I2C link IDs in PCRD section of HDAT. System security cannot be guaranteed.");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_POPULATE_TPMINFOBYNODE");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_DUPLICATE_I2C_LINK_IDS");
        i_parser.PrintString("userdata1", "I2C Link ID");
        break;

    case 0x1A2219:
        i_parser.PrintString("devdesc", "An I2C device in the PCRD does not have a match in the MRW. Physical presence detection will not be available.");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_POPULATE_TPMINFOBYNODE");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_I2C_DEVICE_NOT_IN_MRW");
        i_parser.PrintString("userdata1", "I2C Link ID");
        break;

    case 0x1A2419:
        i_parser.PrintString("devdesc", "An I2C device in the PCRD has a duplicate match in the MRW. Physical presence detection will still be available.");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_POPULATE_TPMINFOBYNODE");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_I2C_DEVICE_DUPLICATE_IN_MRW");
        i_parser.PrintString("userdata1", "I2C Link ID");
        break;

    case 0x1A2519:
        i_parser.PrintString("devdesc", "An I2C device in the MRW has no match in the PCRD.");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_POPULATE_TPMINFOBYNODE");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_EXTRA_I2C_DEVICE_IN_MRW");
        i_parser.PrintString("userdata1", "[0:7] I2C engine");
        i_parser.PrintString("userdata1", "[8:15] I2C masterPort");
        i_parser.PrintString("userdata1", "[16:23] I2C slave deviceType");
        i_parser.PrintString("userdata1", "[24:31] I2C slave address");
        i_parser.PrintString("userdata1", "[32:39] I2C slave port");
        i_parser.PrintString("userdata1", "[40:47] I2C device purpose");
        i_parser.PrintString("userdata1", "[48:63] Bus speed in KHz");
        i_parser.PrintString("userdata2", "master chip HUID");
        break;

    case 0x1A3E22:
        i_parser.PrintString("devdesc", "messages from other nodes have not returned in time");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_SEND_SBE_SYSCONFIG,");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_SEND_SBE_TIMER_EXPIRED,");
        i_parser.PrintString("userdata1", "Message Type IPC_QUERY_CHIPINFO or IPC_SET_SBE_CHIPINFO");
        i_parser.PrintString("userdata2", "Number of nodes that have not responded");
        break;

    case 0x1A3F22:
        i_parser.PrintString("devdesc", "sendSBESystemConfig timer thread failed");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_SEND_SBE_SYSCONFIG,");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_HOST_TIMER_THREAD_FAIL,,");
        i_parser.PrintString("userdata1", "l_tidretrc,");
        i_parser.PrintString("userdata2", "l_childsts,");
        break;

    case 0x1A2821:
        i_parser.PrintString("devdesc", "Unable to pin read/write attribute memory");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_ATTR_RUNTIME_CHECK_PREP_FAIL");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_UNABLE_TO_PIN_ATTR_MEM");
        i_parser.PrintString("userdata1", "Message return code from message handler");
        i_parser.PrintString("userdata2", "Return code from msg_sendrecv function");
        break;

    case 0x1A2921:
        i_parser.PrintString("devdesc", "Unable to unpin read/write attribute memory");
        i_parser.PrintString("moduleid", "RUNTIME::MOD_ATTR_RUNTIME_CHECK_PREP_FAIL");
        i_parser.PrintString("reasoncode", "RUNTIME::RC_UNABLE_TO_UNPIN_ATTR_MEM");
        i_parser.PrintString("userdata1", "Message return code from message handler");
        i_parser.PrintString("userdata2", "Return code from msg_sendrecv function");
        break;

    case 0x1A1D15:
        i_parser.PrintString("devdesc", "PM load complex unknown mode");
        i_parser.PrintString("moduleid", "MOD_PM_RT_LOAD_PM_COMPLEX");
        i_parser.PrintString("reasoncode", "RC_PM_RT_UNKNOWN_MODE");
        i_parser.PrintString("userdata1", "HBRT PM Mode");
        i_parser.PrintString("userdata2", "HUID");
        break;

    case 0x1A1E16:
        i_parser.PrintString("devdesc", "HCODE scom update runtime interface not linked.");
        i_parser.PrintString("moduleid", "MOD_PM_RT_HCODE_UPDATE");
        i_parser.PrintString("reasoncode", "RC_PM_RT_INTERFACE_ERR");
        i_parser.PrintString("userdata1[0:31]", "Target HUID");
        i_parser.PrintString("userdata1[32:63]", "SCOM restore section");
        i_parser.PrintString("userdata2", "SCOM address");
        break;

    case 0x1A1F16:
        i_parser.PrintString("devdesc", "HCODE SCOM update error");
        i_parser.PrintString("moduleid", "MOD_PM_RT_HCODE_UPDATE");
        i_parser.PrintString("reasoncode", "RC_PM_RT_HCODE_UPDATE_ERR");
        i_parser.PrintString("userdata1", "Hypervisor return code");
        i_parser.PrintString("userdata2", "SCOM address");
        break;

    default:
        l_success = false;
        break;
    };
    return l_success;
}

static errl::SrcPlugin g_SrcPlugin(0x1A00, SrcDataParse, ERRL_CID_HOSTBOOT);
