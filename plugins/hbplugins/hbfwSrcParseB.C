/*
 * Automatically generated by Hostboot's ./genErrlParsers.pl
 * Do not modify this file in the FSP tree, it is provided by
 * Hostboot and will be overwritten
 *
 * TimeStamp:   Tue May 15 13:26:15 2018
 * Image Id:    hb0515b_1820.920
 *
 */

#include <errlplugins.H>
#include <errlusrparser.H>
#include <srcisrc.H>

static bool SrcDataParse(ErrlUsrParser & i_parser,
                         const SrciSrc & i_src)
{
    uint32_t l_error = (i_src.reasonCode() << 8) + i_src.moduleId();
    bool l_success = true;

    switch(l_error)
    {
    case 0xB0d05:
        i_parser.PrintString("devdesc", "AttrOverrideSection too big to fit in remaining chunk of pnor section");
        i_parser.PrintString("moduleid", "TARG_GET_ATTR_OVER");
        i_parser.PrintString("reasoncode", "TARG_RC_ATTR_OVER_PNOR_SEC_SPACE_FAIL");
        i_parser.PrintString("userdata1", "PNOR Section specified");
        i_parser.PrintString("userdata2", "Size of AttrOverrideSection");
        break;

    case 0xB0e05:
        i_parser.PrintString("devdesc", "Serialized attribute override chunk too big to fit in remaining chunck of pnor section");
        i_parser.PrintString("moduleid", "TARG_GET_ATTR_OVER");
        i_parser.PrintString("reasoncode", "TARG_RC_ATTR_OVER_ATTR_DATA_SIZE_FAIL");
        i_parser.PrintString("userdata1", "PNOR Section specified");
        i_parser.PrintString("userdata2", "Size of Serialized attribute override");
        break;

    case 0xB1205:
        i_parser.PrintString("devdesc", "No tank layer was specified for attribute override.");
        i_parser.PrintString("moduleid", "TARG_GET_ATTR_OVER");
        i_parser.PrintString("reasoncode", "TARG_RC_WRITE_ATTR_OVER_NO_TANK_LAYER");
        i_parser.PrintString("userdata1", "PNOR Section specified");
        i_parser.PrintString("userdata2", "Chunk location with no tank layer");
        break;

    case 0xB1105:
        i_parser.PrintString("devdesc", "Attribute override is in the wrong pnor section needs to be moved to the section associated with its attribute tank layer");
        i_parser.PrintString("moduleid", "TARG_GET_ATTR_OVER");
        i_parser.PrintString("reasoncode", "TARG_RC_WRITE_ATTR_OVER_WRONG_PNOR_SEC");
        i_parser.PrintString("userdata1", "Tank Layer of attribute");
        i_parser.PrintString("userdata2", "PNOR Section specified");
        break;

    case 0xB1905:
        i_parser.PrintString("devdesc", "Attribute override is in the FAPI Tank which is not supported");
        i_parser.PrintString("moduleid", "TARG_GET_ATTR_OVER");
        i_parser.PrintString("reasoncode", "TARG_RC_ATTR_OVER_FAPI_TANK_NOT_SUPPORTED");
        i_parser.PrintString("userdata1", "Tank Layer of attribute");
        i_parser.PrintString("userdata2", "PNOR Section specified");
        break;

    case 0xB0f06:
        i_parser.PrintString("devdesc", "Failure applying given attribute override on given target");
        i_parser.PrintString("moduleid", "TARG_WRITE_PERM_ATTR");
        i_parser.PrintString("reasoncode", "TARG_RC_WRITE_PERM_ATTR_FAIL");
        i_parser.PrintString("userdata1", "Target specified");
        i_parser.PrintString("userdata2", "Attribute specified");
        break;

    case 0xB1006:
        i_parser.PrintString("devdesc", "Given target does not have given attribute to apply override");
        i_parser.PrintString("moduleid", "TARG_WRITE_PERM_ATTR");
        i_parser.PrintString("reasoncode", "TARG_RC_WRITE_PERM_ATTR_TARGET_FAIL");
        i_parser.PrintString("userdata1", "Target specified");
        i_parser.PrintString("userdata2", "Attribute specified");
        break;

    case 0xB8080:
        i_parser.PrintString("devdesc", "The caller passed an invalid node target to find the master proc handle.");
        i_parser.PrintString("moduleid", "TARG_MOD_QUERY_MASTER_PROC_CHIP");
        i_parser.PrintString("reasoncode", "TARG_RC_INVALID_NODE");
        i_parser.PrintString("userData1", "HUID of Target Passed");
        break;

    case 0xB8180:
        i_parser.PrintString("devdesc", "The caller passed an invalid node target to find the master proc handle");
        i_parser.PrintString("moduleid", "TARG_MOD_QUERY_MASTER_PROC_CHIP");
        i_parser.PrintString("reasoncode", "TARG_RC_TARGET_NOT_FOUND");
        i_parser.PrintString("userData1", "HUID of Target Passed");
        break;

    case 0xB8081:
        i_parser.PrintString("devdesc", "The caller passed an invalid node target.");
        i_parser.PrintString("moduleid", "TARG_MOD_SET_MASTER_NODE");
        i_parser.PrintString("reasoncode", "TARG_RC_INVALID_NODE");
        i_parser.PrintString("userData1", "HUID of Target Passed");
        break;

    case 0xB8988:
        i_parser.PrintString("devdesc", "For some reason attr IDs in hbMutexAttrIds list are not matching the attribute IDs that target service is seeing. This is causing incorrect matching Make sure mutexattribute.H in genfiles has good values");
        i_parser.PrintString("moduleid", "TARG_SVC_RESET_MUTEX");
        i_parser.PrintString("reasoncode", "TARG_SVC_MISSING_ATTR");
        i_parser.PrintString("userdata1", "Attribute Id we attempted to read");
        i_parser.PrintString("userdata2", "Huid of target we attempted to read");
        break;

    case 0xB0282:
        i_parser.PrintString("devdesc", "The eyecatch value observed in memory does not match the expected value of PNOR_TARG_EYE_CATCHER and therefore the contents of the Attribute sections are unable to be parsed.");
        i_parser.PrintString("moduleid", "TARG_MOD_ATTRRP_RT");
        i_parser.PrintString("reasoncode", "TARG_RC_BAD_EYECATCH");
        i_parser.PrintString("userdata1", "Observed Header Eyecatch Value");
        i_parser.PrintString("userdata2", "Memory address referenced.");
        break;

    case 0xB0c03:
        i_parser.PrintString("devdesc", "Targeting target's type not supported by runtime code");
        i_parser.PrintString("moduleid", "TARG_RT_GET_RT_TARGET");
        i_parser.PrintString("reasoncode", "TARG_RT_TARGET_TYPE_NOT_SUPPORTED");
        i_parser.PrintString("userdata1", "Target's HUID");
        i_parser.PrintString("userdata2", "target's targeting type");
        break;

    case 0xB0c04:
        i_parser.PrintString("devdesc", "Can't find targeting target for given runtime target ID");
        i_parser.PrintString("moduleid", "TARGETING::TARG_RT_GET_HB_TARGET");
        i_parser.PrintString("reasoncode", "TARGETING::TARG_RT_TARGET_TYPE_NOT_SUPPORTED");
        i_parser.PrintString("userdata1", "Runtime target ID");
        i_parser.PrintString("userdata2", "0");
        break;

    case 0xB8386:
        i_parser.PrintString("devdesc", "Bad eyecatcher in the new lid data");
        i_parser.PrintString("moduleid", "TARGETING::TARG_RT_VALIDATEDATA");
        i_parser.PrintString("reasoncode", "TARGETING::TARG_RT_BAD_EYECATCHER_LID");
        i_parser.PrintString("userdata1", "Eyecatcher from LID");
        i_parser.PrintString("userdata2", "Expected eyecatcher");
        break;

    case 0xB8486:
        i_parser.PrintString("devdesc", "Bad eyecatcher in the existing attribute data");
        i_parser.PrintString("moduleid", "TARGETING::TARG_RT_VALIDATEDATA");
        i_parser.PrintString("reasoncode", "TARGETING::TARG_RT_BAD_EYECATCHER_MEM");
        i_parser.PrintString("userdata1", "Eyecatcher from existing memory");
        i_parser.PrintString("userdata2", "Expected eyecatcher");
        break;

    case 0xB8586:
        i_parser.PrintString("devdesc", "Section number mismatch between new and old data");
        i_parser.PrintString("moduleid", "TARGETING::TARG_RT_VALIDATEDATA");
        i_parser.PrintString("reasoncode", "TARGETING::TARG_RT_SECTION_NUM_MISMATCH");
        i_parser.PrintString("userdata1", "Number of sections in lid");
        i_parser.PrintString("userdata2", "Number of sections in existing mem");
        break;

    case 0xB8686:
        i_parser.PrintString("devdesc", "Section number mismatch between new and old data");
        i_parser.PrintString("moduleid", "TARGETING::TARG_RT_VALIDATEDATA");
        i_parser.PrintString("reasoncode", "TARGETING::TARG_RT_SECTION_MISMATCH");
        i_parser.PrintString("userdata1", "Section number");
        i_parser.PrintString("userdata2[00:31]", "Section type in the lid");
        i_parser.PrintString("userdata2[32:63]", "Section type in the memory");
        break;

    case 0xB8787:
        i_parser.PrintString("devdesc", "Could not find attribute data in lid");
        i_parser.PrintString("moduleid", "TARGETING::TARG_RT_SAVERESTOREATTRS");
        i_parser.PrintString("reasoncode", "TARGETING::TARG_RT_MISSING_ATTR");
        i_parser.PrintString("userdata1", "Attribute Id");
        i_parser.PrintString("userdata2", "HUID of target");
        break;

    case 0xB8885:
        i_parser.PrintString("devdesc", "There is a mismatch with the sizes of the lid and/or reserved memory section");
        i_parser.PrintString("moduleid", "TARGETING::TARG_RT_HBRT_UPDATE_PREP");
        i_parser.PrintString("reasoncode", "TARGETING::TARG_RT_BAD_ATTR_SIZES");
        i_parser.PrintString("userdata1[00:31]", "Lid size");
        i_parser.PrintString("userdata1[32:63]", "Attribute size in lid");
        i_parser.PrintString("userdata2[00:31]", "Reserved mem size");
        i_parser.PrintString("userdata2[32:63]", "unused");
        break;

    case 0xB0508:
        i_parser.PrintString("devdesc", "The attribute resource provider was unable to satisfy a message request from the VMM portion of the kernel.  This was either due to an address outside a valid range or a message request that is invalid for the attribute section containing the address.");
        i_parser.PrintString("moduleid", "TARG_MSG_SERVICE_TASK");
        i_parser.PrintString("reasoncode", "TARG_RC_ATTR_MSG_FAIL");
        i_parser.PrintString("userdata1", "Virtual Address");
        i_parser.PrintString("userdata2", "(Msg Type << 32) | Section #");
        break;

    case 0xB1507:
        i_parser.PrintString("devdesc", "While attempting to unmap a virtual addr for our targeting information the kernel returned an error");
        i_parser.PrintString("moduleid", "TARG_PARSE_ATTR_SECT_HEADER");
        i_parser.PrintString("reasoncode", "TARG_RC_MM_BLOCK_UNMAP_FAIL");
        i_parser.PrintString("userdata1", "return code");
        i_parser.PrintString("userdata2", "Unmap virtual address");
        break;

    case 0xB1307:
        i_parser.PrintString("devdesc", "While attempting to map a phys addr to a virtual addr for our targeting information the kernel returned an error");
        i_parser.PrintString("moduleid", "TARG_PARSE_ATTR_SECT_HEADER");
        i_parser.PrintString("reasoncode", "TARG_RC_MM_BLOCK_MAP_FAIL");
        i_parser.PrintString("userdata1", "physical address of target info");
        i_parser.PrintString("userdata2", "size we tried to map");
        break;

    case 0xB0207:
        i_parser.PrintString("devdesc", "The eyecatch value observed in PNOR does not match the expected value of PNOR_TARG_EYE_CATCHER and therefore the contents of the Attribute PNOR section are unable to be parsed.");
        i_parser.PrintString("moduleid", "TARG_PARSE_ATTR_SECT_HEADER");
        i_parser.PrintString("reasoncode", "TARG_RC_BAD_EYECATCH");
        i_parser.PrintString("userdata1", "Observed Header Eyecatch Value");
        i_parser.PrintString("userdata2", "Expected Eyecatch Value");
        break;

    case 0xB0609:
        i_parser.PrintString("devdesc", "Found unhandled attribute section type");
        i_parser.PrintString("moduleid", "TARG_CREATE_VMM_SECTIONS");
        i_parser.PrintString("reasoncode", "TARG_RC_UNHANDLED_ATTR_SEC_TYPE");
        i_parser.PrintString("userdata1", "Section type");
        break;

    case 0xB0309:
        i_parser.PrintString("devdesc", "While attempting to allocate a virtual memory block for an attribute section, the kernel returned an error.");
        i_parser.PrintString("moduleid", "TARG_CREATE_VMM_SECTIONS");
        i_parser.PrintString("reasoncode", "TARG_RC_MM_BLOCK_FAIL");
        i_parser.PrintString("userdata1", "vAddress attempting to allocate.");
        i_parser.PrintString("userdata2", "RC from kernel.");
        break;

    case 0xB0409:
        i_parser.PrintString("devdesc", "While attempting to set permissions on a virtual memory block for an attribute section, the kernel returned an error.");
        i_parser.PrintString("moduleid", "TARG_CREATE_VMM_SECTIONS");
        i_parser.PrintString("reasoncode", "TARG_RC_MM_PERM_FAIL");
        i_parser.PrintString("userdata1", "vAddress attempting to allocate.");
        i_parser.PrintString("userdata2", "(kernel-rc << 32) | (Permissions)");
        break;

    case 0xB8284:
        i_parser.PrintString("devdesc", "Size of attribute data exceeds available buffer space");
        i_parser.PrintString("moduleid", "TARG_MOD_SAVE_ATTR_TANK");
        i_parser.PrintString("reasoncode", "TARG_SPACE_OVERRUN");
        i_parser.PrintString("userdata1", "Maximum Available size");
        i_parser.PrintString("userdata2", "Required size");
        break;

    case 0xB8283:
        i_parser.PrintString("devdesc", "Size of override data exceeds available buffer space");
        i_parser.PrintString("moduleid", "TARG_MOD_SAVE_OVERRIDE_TANK");
        i_parser.PrintString("reasoncode", "TARG_SPACE_OVERRUN");
        i_parser.PrintString("userdata1[00:31]", "Maximum Available size");
        i_parser.PrintString("userdata1[32:63]", "Required size");
        i_parser.PrintString("userdata2[00:31]", "Chunk Size");
        i_parser.PrintString("userdata2[32:63]", "Previous Size");
        break;

    case 0xB0902:
        i_parser.PrintString("devdesc", "The attribute synchronization from the FSP failed.");
        i_parser.PrintString("moduleid", "TARG_MOD_ATTR_SYNC");
        i_parser.PrintString("reasoncode", "TARG_RC_ATTR_SYNC_TO_HB_FAIL");
        i_parser.PrintString("userdata1", "return code");
        i_parser.PrintString("userdata2", "section to sync");
        break;

    case 0xB0702:
        i_parser.PrintString("devdesc", "The attribute synchronization code on the FSP side was unable to complete the sync operation successfully.");
        i_parser.PrintString("moduleid", "TARG_MOD_ATTR_SYNC");
        i_parser.PrintString("reasoncode", "TARG_RC_ATTR_SYNC_TO_FSP_FAIL");
        i_parser.PrintString("userdata1", "return code from FSP attribute sync");
        i_parser.PrintString("userdata2[0:31]", "page count for this section");
        i_parser.PrintString("userdata2[31:63]", "section ID of for section being sync'd");
        break;

    case 0xB0802:
        i_parser.PrintString("devdesc", "The attribute synchronization code on the FSP side was unable to fulfill the sync to HostBoot request.");
        i_parser.PrintString("moduleid", "TARG_MOD_ATTR_SYNC");
        i_parser.PrintString("reasoncode", "TARG_RC_ATTR_SYNC_REQUEST_TO_HB_FAIL");
        i_parser.PrintString("userdata1", "return code from FSP");
        i_parser.PrintString("userdata2", "section to sync");
        break;

    case 0xB0101:
        i_parser.PrintString("devdesc", "User Details unit test - create target user detail data");
        i_parser.PrintString("moduleid", "TARG_MOD_TEST");
        i_parser.PrintString("reasoncode", "TARG_RC_TEST_TARGET_FFDC");
        i_parser.PrintString("userdata1", "Test data 1");
        i_parser.PrintString("userdata2", "Test data 2");
        break;

    case 0xB160B:
        i_parser.PrintString("devdesc", "Invalid enum value for attribute.");
        i_parser.PrintString("moduleid", "TARGETING::TARG_HANDLE_ENUM_CHECK_FAILURE");
        i_parser.PrintString("reasoncode", "TARGETING::TARG_RC_ATTRIBUTE_ENUM_CHECK_FAIL");
        i_parser.PrintString("userdata1[00:31]", "Target's HUID");
        i_parser.PrintString("userdata1[32:63]", "Attribute ID");
        i_parser.PrintString("userdata2", "Invalid value");
        break;

    case 0xB170C:
        i_parser.PrintString("devdesc", "Invalid range for attribute value.");
        i_parser.PrintString("moduleid", "TARGETING::TARG_HANDLE_RANGE_CHECK_FAILURE");
        i_parser.PrintString("reasoncode", "TARGETING::TARG_RC_ATTRIBUTE_RANGE_CHECK_FAIL");
        i_parser.PrintString("userdata1[00:31]", "Target's HUID");
        i_parser.PrintString("userdata1[32:64]", "Attribute ID");
        i_parser.PrintString("userdata2", "Value that was out of range");
        break;

    default:
        l_success = false;
        break;
    };
    return l_success;
}

static errl::SrcPlugin g_SrcPlugin(0xB00, SrcDataParse, ERRL_CID_HOSTBOOT);
