/*
 * Automatically generated by Hostboot's ./genErrlParsers.pl
 * Do not modify this file in the FSP tree, it is provided by
 * Hostboot and will be overwritten
 *
 * TimeStamp:   Tue May 15 13:26:15 2018
 * Image Id:    hb0515b_1820.920
 *
 */

#include <errlplugins.H>
#include <errlusrparser.H>
#include <srcisrc.H>

static bool SrcDataParse(ErrlUsrParser & i_parser,
                         const SrciSrc & i_src)
{
    uint32_t l_error = (i_src.reasonCode() << 8) + i_src.moduleId();
    bool l_success = true;

    switch(l_error)
    {
    case 0xE0801:
        i_parser.PrintString("devdesc", "I2C Buffer Length + Offset > Max Size");
        i_parser.PrintString("moduleid", "EEPROM_PERFORM_OP");
        i_parser.PrintString("reasoncode", "EEPROM_OVERFLOW_ERROR");
        i_parser.PrintString("userdata1[0:31]", "Offset");
        i_parser.PrintString("userdata1[32:63]", "Buffer Length");
        i_parser.PrintString("userdata2", "Device Max Size (in KB)");
        break;

    case 0xE0101:
        i_parser.PrintString("devdesc", "Invalid operation type.");
        i_parser.PrintString("moduleid", "EEPROM_PERFORM_OP");
        i_parser.PrintString("reasoncode", "EEPROM_INVALID_OPERATION");
        i_parser.PrintString("userdata1", "Operation Type");
        i_parser.PrintString("userdata2", "Chip to Access");
        break;

    case 0xE0903:
        i_parser.PrintString("devdesc", "I2C write page size is zero.");
        i_parser.PrintString("moduleid", "EEPROM_WRITE");
        i_parser.PrintString("reasoncode", "EEPROM_I2C_WRITE_PAGE_SIZE_ZERO");
        i_parser.PrintString("userdata1", "HUID of target");
        i_parser.PrintString("userdata2", "Chip to Access");
        break;

    case 0xE0204:
        i_parser.PrintString("devdesc", "The Device type not supported (addrSize)");
        i_parser.PrintString("moduleid", "EEPROM_PREPAREADDRESS");
        i_parser.PrintString("reasoncode", "EEPROM_INVALID_DEVICE_TYPE");
        i_parser.PrintString("userdata1", "Address Size (aka Device Type)");
        i_parser.PrintString("userdata2", "EEPROM chip");
        break;

    case 0xE0405:
        i_parser.PrintString("devdesc", "Invalid EEPROM chip to access");
        i_parser.PrintString("moduleid", "EEPROM_READATTRIBUTES");
        i_parser.PrintString("reasoncode", "EEPROM_INVALID_CHIP");
        i_parser.PrintString("userdata1", "EEPROM Chip");
        i_parser.PrintString("userdata2", "HUID of target");
        break;

    case 0xE0305:
        i_parser.PrintString("devdesc", "EEPROM attribute was not found");
        i_parser.PrintString("moduleid", "EEPROM_READATTRIBUTES");
        i_parser.PrintString("reasoncode", "EEPROM_ATTR_INFO_NOT_FOUND");
        i_parser.PrintString("userdata1", "HUID of target");
        i_parser.PrintString("userdata2", "EEPROM chip");
        break;

    case 0xE0705:
        i_parser.PrintString("devdesc", "Invalid address offset size");
        i_parser.PrintString("moduleid", "EEPROM_READATTRIBUTES");
        i_parser.PrintString("reasoncode", "EEPROM_INVALID_ADDR_OFFSET_SIZE");
        i_parser.PrintString("userdata1", "HUID of target");
        i_parser.PrintString("userdata2", "Address Offset Size");
        break;

    case 0xE0506:
        i_parser.PrintString("devdesc", "I2C master entity path doesn't exist.");
        i_parser.PrintString("moduleid", "EEPROM_GETI2CMASTERTARGET");
        i_parser.PrintString("reasoncode", "EEPROM_I2C_MASTER_PATH_ERROR");
        i_parser.PrintString("userdata1[00:31]", "Attribute Chip Type Enum");
        i_parser.PrintString("userdata1[32:63]", "HUID of target");
        i_parser.PrintString("userdata2", "Compressed Entity Path");
        break;

    case 0xE0606:
        i_parser.PrintString("devdesc", "I2C master path target is null.");
        i_parser.PrintString("moduleid", "EEPROM_GETI2CMASTERTARGET");
        i_parser.PrintString("reasoncode", "EEPROM_TARGET_NULL");
        i_parser.PrintString("userdata1[00:31]", "Attribute Chip Type Enum");
        i_parser.PrintString("userdata1[32:63]", "HUID of target");
        i_parser.PrintString("userdata2", "Compressed Entity Path");
        break;

    default:
        l_success = false;
        break;
    };
    return l_success;
}

static errl::SrcPlugin g_SrcPlugin(0xE00, SrcDataParse, ERRL_CID_HOSTBOOT);
